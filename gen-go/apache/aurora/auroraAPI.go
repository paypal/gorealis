// Code generated by Thrift Compiler (0.14.0). DO NOT EDIT.

package aurora

import(
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"time"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

type ResponseCode int64
const (
  ResponseCode_INVALID_REQUEST ResponseCode = 0
  ResponseCode_OK ResponseCode = 1
  ResponseCode_ERROR ResponseCode = 2
  ResponseCode_WARNING ResponseCode = 3
  ResponseCode_AUTH_FAILED ResponseCode = 4
  ResponseCode_JOB_UPDATING_ERROR ResponseCode = 5
  ResponseCode_ERROR_TRANSIENT ResponseCode = 6
)

func (p ResponseCode) String() string {
  switch p {
  case ResponseCode_INVALID_REQUEST: return "INVALID_REQUEST"
  case ResponseCode_OK: return "OK"
  case ResponseCode_ERROR: return "ERROR"
  case ResponseCode_WARNING: return "WARNING"
  case ResponseCode_AUTH_FAILED: return "AUTH_FAILED"
  case ResponseCode_JOB_UPDATING_ERROR: return "JOB_UPDATING_ERROR"
  case ResponseCode_ERROR_TRANSIENT: return "ERROR_TRANSIENT"
  }
  return "<UNSET>"
}

func ResponseCodeFromString(s string) (ResponseCode, error) {
  switch s {
  case "INVALID_REQUEST": return ResponseCode_INVALID_REQUEST, nil 
  case "OK": return ResponseCode_OK, nil 
  case "ERROR": return ResponseCode_ERROR, nil 
  case "WARNING": return ResponseCode_WARNING, nil 
  case "AUTH_FAILED": return ResponseCode_AUTH_FAILED, nil 
  case "JOB_UPDATING_ERROR": return ResponseCode_JOB_UPDATING_ERROR, nil 
  case "ERROR_TRANSIENT": return ResponseCode_ERROR_TRANSIENT, nil 
  }
  return ResponseCode(0), fmt.Errorf("not a valid ResponseCode string")
}


func ResponseCodePtr(v ResponseCode) *ResponseCode { return &v }

func (p ResponseCode) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ResponseCode) UnmarshalText(text []byte) error {
q, err := ResponseCodeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ResponseCode) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ResponseCode(v)
return nil
}

func (p * ResponseCode) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type MaintenanceMode int64
const (
  MaintenanceMode_NONE MaintenanceMode = 1
  MaintenanceMode_SCHEDULED MaintenanceMode = 2
  MaintenanceMode_DRAINING MaintenanceMode = 3
  MaintenanceMode_DRAINED MaintenanceMode = 4
)

func (p MaintenanceMode) String() string {
  switch p {
  case MaintenanceMode_NONE: return "NONE"
  case MaintenanceMode_SCHEDULED: return "SCHEDULED"
  case MaintenanceMode_DRAINING: return "DRAINING"
  case MaintenanceMode_DRAINED: return "DRAINED"
  }
  return "<UNSET>"
}

func MaintenanceModeFromString(s string) (MaintenanceMode, error) {
  switch s {
  case "NONE": return MaintenanceMode_NONE, nil 
  case "SCHEDULED": return MaintenanceMode_SCHEDULED, nil 
  case "DRAINING": return MaintenanceMode_DRAINING, nil 
  case "DRAINED": return MaintenanceMode_DRAINED, nil 
  }
  return MaintenanceMode(0), fmt.Errorf("not a valid MaintenanceMode string")
}


func MaintenanceModePtr(v MaintenanceMode) *MaintenanceMode { return &v }

func (p MaintenanceMode) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *MaintenanceMode) UnmarshalText(text []byte) error {
q, err := MaintenanceModeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *MaintenanceMode) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = MaintenanceMode(v)
return nil
}

func (p * MaintenanceMode) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//The mode for a volume mount
type Mode int64
const (
  Mode_RW Mode = 1
  Mode_RO Mode = 2
)

func (p Mode) String() string {
  switch p {
  case Mode_RW: return "RW"
  case Mode_RO: return "RO"
  }
  return "<UNSET>"
}

func ModeFromString(s string) (Mode, error) {
  switch s {
  case "RW": return Mode_RW, nil 
  case "RO": return Mode_RO, nil 
  }
  return Mode(0), fmt.Errorf("not a valid Mode string")
}


func ModePtr(v Mode) *Mode { return &v }

func (p Mode) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Mode) UnmarshalText(text []byte) error {
q, err := ModeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Mode) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Mode(v)
return nil
}

func (p * Mode) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Defines the policy for launching a new cron job when one is already running.
type CronCollisionPolicy int64
const (
  CronCollisionPolicy_KILL_EXISTING CronCollisionPolicy = 0
  CronCollisionPolicy_CANCEL_NEW CronCollisionPolicy = 1
  CronCollisionPolicy_RUN_OVERLAP CronCollisionPolicy = 2
)

func (p CronCollisionPolicy) String() string {
  switch p {
  case CronCollisionPolicy_KILL_EXISTING: return "KILL_EXISTING"
  case CronCollisionPolicy_CANCEL_NEW: return "CANCEL_NEW"
  case CronCollisionPolicy_RUN_OVERLAP: return "RUN_OVERLAP"
  }
  return "<UNSET>"
}

func CronCollisionPolicyFromString(s string) (CronCollisionPolicy, error) {
  switch s {
  case "KILL_EXISTING": return CronCollisionPolicy_KILL_EXISTING, nil 
  case "CANCEL_NEW": return CronCollisionPolicy_CANCEL_NEW, nil 
  case "RUN_OVERLAP": return CronCollisionPolicy_RUN_OVERLAP, nil 
  }
  return CronCollisionPolicy(0), fmt.Errorf("not a valid CronCollisionPolicy string")
}


func CronCollisionPolicyPtr(v CronCollisionPolicy) *CronCollisionPolicy { return &v }

func (p CronCollisionPolicy) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *CronCollisionPolicy) UnmarshalText(text []byte) error {
q, err := CronCollisionPolicyFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *CronCollisionPolicy) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = CronCollisionPolicy(v)
return nil
}

func (p * CronCollisionPolicy) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//States that a task may be in.
type ScheduleStatus int64
const (
  ScheduleStatus_INIT ScheduleStatus = 11
  ScheduleStatus_THROTTLED ScheduleStatus = 16
  ScheduleStatus_PENDING ScheduleStatus = 0
  ScheduleStatus_ASSIGNED ScheduleStatus = 9
  ScheduleStatus_STARTING ScheduleStatus = 1
  ScheduleStatus_RUNNING ScheduleStatus = 2
  ScheduleStatus_FINISHED ScheduleStatus = 3
  ScheduleStatus_PREEMPTING ScheduleStatus = 13
  ScheduleStatus_RESTARTING ScheduleStatus = 12
  ScheduleStatus_DRAINING ScheduleStatus = 17
  ScheduleStatus_FAILED ScheduleStatus = 4
  ScheduleStatus_KILLED ScheduleStatus = 5
  ScheduleStatus_KILLING ScheduleStatus = 6
  ScheduleStatus_LOST ScheduleStatus = 7
  ScheduleStatus_PARTITIONED ScheduleStatus = 18
)

func (p ScheduleStatus) String() string {
  switch p {
  case ScheduleStatus_INIT: return "INIT"
  case ScheduleStatus_THROTTLED: return "THROTTLED"
  case ScheduleStatus_PENDING: return "PENDING"
  case ScheduleStatus_ASSIGNED: return "ASSIGNED"
  case ScheduleStatus_STARTING: return "STARTING"
  case ScheduleStatus_RUNNING: return "RUNNING"
  case ScheduleStatus_FINISHED: return "FINISHED"
  case ScheduleStatus_PREEMPTING: return "PREEMPTING"
  case ScheduleStatus_RESTARTING: return "RESTARTING"
  case ScheduleStatus_DRAINING: return "DRAINING"
  case ScheduleStatus_FAILED: return "FAILED"
  case ScheduleStatus_KILLED: return "KILLED"
  case ScheduleStatus_KILLING: return "KILLING"
  case ScheduleStatus_LOST: return "LOST"
  case ScheduleStatus_PARTITIONED: return "PARTITIONED"
  }
  return "<UNSET>"
}

func ScheduleStatusFromString(s string) (ScheduleStatus, error) {
  switch s {
  case "INIT": return ScheduleStatus_INIT, nil 
  case "THROTTLED": return ScheduleStatus_THROTTLED, nil 
  case "PENDING": return ScheduleStatus_PENDING, nil 
  case "ASSIGNED": return ScheduleStatus_ASSIGNED, nil 
  case "STARTING": return ScheduleStatus_STARTING, nil 
  case "RUNNING": return ScheduleStatus_RUNNING, nil 
  case "FINISHED": return ScheduleStatus_FINISHED, nil 
  case "PREEMPTING": return ScheduleStatus_PREEMPTING, nil 
  case "RESTARTING": return ScheduleStatus_RESTARTING, nil 
  case "DRAINING": return ScheduleStatus_DRAINING, nil 
  case "FAILED": return ScheduleStatus_FAILED, nil 
  case "KILLED": return ScheduleStatus_KILLED, nil 
  case "KILLING": return ScheduleStatus_KILLING, nil 
  case "LOST": return ScheduleStatus_LOST, nil 
  case "PARTITIONED": return ScheduleStatus_PARTITIONED, nil 
  }
  return ScheduleStatus(0), fmt.Errorf("not a valid ScheduleStatus string")
}


func ScheduleStatusPtr(v ScheduleStatus) *ScheduleStatus { return &v }

func (p ScheduleStatus) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ScheduleStatus) UnmarshalText(text []byte) error {
q, err := ScheduleStatusFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ScheduleStatus) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ScheduleStatus(v)
return nil
}

func (p * ScheduleStatus) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//States that a job update may be in.
type JobUpdateStatus int64
const (
  JobUpdateStatus_ROLLING_FORWARD JobUpdateStatus = 0
  JobUpdateStatus_ROLLING_BACK JobUpdateStatus = 1
  JobUpdateStatus_ROLL_FORWARD_PAUSED JobUpdateStatus = 2
  JobUpdateStatus_ROLL_BACK_PAUSED JobUpdateStatus = 3
  JobUpdateStatus_ROLLED_FORWARD JobUpdateStatus = 4
  JobUpdateStatus_ROLLED_BACK JobUpdateStatus = 5
  JobUpdateStatus_ABORTED JobUpdateStatus = 6
  JobUpdateStatus_ERROR JobUpdateStatus = 7
  JobUpdateStatus_FAILED JobUpdateStatus = 8
  JobUpdateStatus_ROLL_FORWARD_AWAITING_PULSE JobUpdateStatus = 9
  JobUpdateStatus_ROLL_BACK_AWAITING_PULSE JobUpdateStatus = 10
)

func (p JobUpdateStatus) String() string {
  switch p {
  case JobUpdateStatus_ROLLING_FORWARD: return "ROLLING_FORWARD"
  case JobUpdateStatus_ROLLING_BACK: return "ROLLING_BACK"
  case JobUpdateStatus_ROLL_FORWARD_PAUSED: return "ROLL_FORWARD_PAUSED"
  case JobUpdateStatus_ROLL_BACK_PAUSED: return "ROLL_BACK_PAUSED"
  case JobUpdateStatus_ROLLED_FORWARD: return "ROLLED_FORWARD"
  case JobUpdateStatus_ROLLED_BACK: return "ROLLED_BACK"
  case JobUpdateStatus_ABORTED: return "ABORTED"
  case JobUpdateStatus_ERROR: return "ERROR"
  case JobUpdateStatus_FAILED: return "FAILED"
  case JobUpdateStatus_ROLL_FORWARD_AWAITING_PULSE: return "ROLL_FORWARD_AWAITING_PULSE"
  case JobUpdateStatus_ROLL_BACK_AWAITING_PULSE: return "ROLL_BACK_AWAITING_PULSE"
  }
  return "<UNSET>"
}

func JobUpdateStatusFromString(s string) (JobUpdateStatus, error) {
  switch s {
  case "ROLLING_FORWARD": return JobUpdateStatus_ROLLING_FORWARD, nil 
  case "ROLLING_BACK": return JobUpdateStatus_ROLLING_BACK, nil 
  case "ROLL_FORWARD_PAUSED": return JobUpdateStatus_ROLL_FORWARD_PAUSED, nil 
  case "ROLL_BACK_PAUSED": return JobUpdateStatus_ROLL_BACK_PAUSED, nil 
  case "ROLLED_FORWARD": return JobUpdateStatus_ROLLED_FORWARD, nil 
  case "ROLLED_BACK": return JobUpdateStatus_ROLLED_BACK, nil 
  case "ABORTED": return JobUpdateStatus_ABORTED, nil 
  case "ERROR": return JobUpdateStatus_ERROR, nil 
  case "FAILED": return JobUpdateStatus_FAILED, nil 
  case "ROLL_FORWARD_AWAITING_PULSE": return JobUpdateStatus_ROLL_FORWARD_AWAITING_PULSE, nil 
  case "ROLL_BACK_AWAITING_PULSE": return JobUpdateStatus_ROLL_BACK_AWAITING_PULSE, nil 
  }
  return JobUpdateStatus(0), fmt.Errorf("not a valid JobUpdateStatus string")
}


func JobUpdateStatusPtr(v JobUpdateStatus) *JobUpdateStatus { return &v }

func (p JobUpdateStatus) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *JobUpdateStatus) UnmarshalText(text []byte) error {
q, err := JobUpdateStatusFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *JobUpdateStatus) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = JobUpdateStatus(v)
return nil
}

func (p * JobUpdateStatus) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Job update actions that can be applied to job instances.
type JobUpdateAction int64
const (
  JobUpdateAction_INSTANCE_UPDATED JobUpdateAction = 1
  JobUpdateAction_INSTANCE_ROLLED_BACK JobUpdateAction = 2
  JobUpdateAction_INSTANCE_UPDATING JobUpdateAction = 3
  JobUpdateAction_INSTANCE_ROLLING_BACK JobUpdateAction = 4
  JobUpdateAction_INSTANCE_UPDATE_FAILED JobUpdateAction = 5
  JobUpdateAction_INSTANCE_ROLLBACK_FAILED JobUpdateAction = 6
)

func (p JobUpdateAction) String() string {
  switch p {
  case JobUpdateAction_INSTANCE_UPDATED: return "INSTANCE_UPDATED"
  case JobUpdateAction_INSTANCE_ROLLED_BACK: return "INSTANCE_ROLLED_BACK"
  case JobUpdateAction_INSTANCE_UPDATING: return "INSTANCE_UPDATING"
  case JobUpdateAction_INSTANCE_ROLLING_BACK: return "INSTANCE_ROLLING_BACK"
  case JobUpdateAction_INSTANCE_UPDATE_FAILED: return "INSTANCE_UPDATE_FAILED"
  case JobUpdateAction_INSTANCE_ROLLBACK_FAILED: return "INSTANCE_ROLLBACK_FAILED"
  }
  return "<UNSET>"
}

func JobUpdateActionFromString(s string) (JobUpdateAction, error) {
  switch s {
  case "INSTANCE_UPDATED": return JobUpdateAction_INSTANCE_UPDATED, nil 
  case "INSTANCE_ROLLED_BACK": return JobUpdateAction_INSTANCE_ROLLED_BACK, nil 
  case "INSTANCE_UPDATING": return JobUpdateAction_INSTANCE_UPDATING, nil 
  case "INSTANCE_ROLLING_BACK": return JobUpdateAction_INSTANCE_ROLLING_BACK, nil 
  case "INSTANCE_UPDATE_FAILED": return JobUpdateAction_INSTANCE_UPDATE_FAILED, nil 
  case "INSTANCE_ROLLBACK_FAILED": return JobUpdateAction_INSTANCE_ROLLBACK_FAILED, nil 
  }
  return JobUpdateAction(0), fmt.Errorf("not a valid JobUpdateAction string")
}


func JobUpdateActionPtr(v JobUpdateAction) *JobUpdateAction { return &v }

func (p JobUpdateAction) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *JobUpdateAction) UnmarshalText(text []byte) error {
q, err := JobUpdateActionFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *JobUpdateAction) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = JobUpdateAction(v)
return nil
}

func (p * JobUpdateAction) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Status of the coordinated update. Intended as a response to pulseJobUpdate RPC.
type JobUpdatePulseStatus int64
const (
  JobUpdatePulseStatus_OK JobUpdatePulseStatus = 1
  JobUpdatePulseStatus_FINISHED JobUpdatePulseStatus = 2
)

func (p JobUpdatePulseStatus) String() string {
  switch p {
  case JobUpdatePulseStatus_OK: return "OK"
  case JobUpdatePulseStatus_FINISHED: return "FINISHED"
  }
  return "<UNSET>"
}

func JobUpdatePulseStatusFromString(s string) (JobUpdatePulseStatus, error) {
  switch s {
  case "OK": return JobUpdatePulseStatus_OK, nil 
  case "FINISHED": return JobUpdatePulseStatus_FINISHED, nil 
  }
  return JobUpdatePulseStatus(0), fmt.Errorf("not a valid JobUpdatePulseStatus string")
}


func JobUpdatePulseStatusPtr(v JobUpdatePulseStatus) *JobUpdatePulseStatus { return &v }

func (p JobUpdatePulseStatus) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *JobUpdatePulseStatus) UnmarshalText(text []byte) error {
q, err := JobUpdatePulseStatusFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *JobUpdatePulseStatus) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = JobUpdatePulseStatus(v)
return nil
}

func (p * JobUpdatePulseStatus) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// Attributes:
//  - User
type Identity struct {
  // unused field # 1
  User string `thrift:"user,2" db:"user" json:"user"`
}

func NewIdentity() *Identity {
  return &Identity{}
}


func (p *Identity) GetUser() string {
  return p.User
}
func (p *Identity) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Identity)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.User = v
}
  return nil
}

func (p *Identity) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Identity"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Identity) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "user", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:user: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.User)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.user (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:user: ", p), err) }
  return err
}

func (p *Identity) Equals(other *Identity) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.User != other.User { return false }
  return true
}

func (p *Identity) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Identity(%+v)", *p)
}

// A single host attribute.
// 
// Attributes:
//  - Name
//  - Values
type Attribute struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Values []string `thrift:"values,2" db:"values" json:"values"`
}

func NewAttribute() *Attribute {
  return &Attribute{}
}


func (p *Attribute) GetName() string {
  return p.Name
}

func (p *Attribute) GetValues() []string {
  return p.Values
}
func (p *Attribute) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Attribute)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Attribute)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.Values =  tSet
  for i := 0; i < size; i ++ {
var _elem0 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem0 = v
}
    p.Values = append(p.Values, _elem0)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *Attribute) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Attribute"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Attribute) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Attribute) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.Values)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Values); i++ {
    for j := i+1; j<len(p.Values); j++ {
      if func(tgt, src string) bool {
        if tgt != src { return false }
        return true
      }(p.Values[i], p.Values[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Values))
      }
    }
  }
  for _, v := range p.Values {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err) }
  return err
}

func (p *Attribute) Equals(other *Attribute) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src1 := other.Values[i]
    if _tgt != _src1 { return false }
  }
  return true
}

func (p *Attribute) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Attribute(%+v)", *p)
}

// The attributes assigned to a host.
// 
// Attributes:
//  - Host
//  - Attributes
//  - Mode
//  - SlaveId
type HostAttributes struct {
  Host string `thrift:"host,1" db:"host" json:"host"`
  Attributes []*Attribute `thrift:"attributes,2" db:"attributes" json:"attributes"`
  Mode *MaintenanceMode `thrift:"mode,3" db:"mode" json:"mode,omitempty"`
  SlaveId *string `thrift:"slaveId,4" db:"slaveId" json:"slaveId,omitempty"`
}

func NewHostAttributes() *HostAttributes {
  return &HostAttributes{}
}


func (p *HostAttributes) GetHost() string {
  return p.Host
}

func (p *HostAttributes) GetAttributes() []*Attribute {
  return p.Attributes
}
var HostAttributes_Mode_DEFAULT MaintenanceMode
func (p *HostAttributes) GetMode() MaintenanceMode {
  if !p.IsSetMode() {
    return HostAttributes_Mode_DEFAULT
  }
return *p.Mode
}
var HostAttributes_SlaveId_DEFAULT string
func (p *HostAttributes) GetSlaveId() string {
  if !p.IsSetSlaveId() {
    return HostAttributes_SlaveId_DEFAULT
  }
return *p.SlaveId
}
func (p *HostAttributes) IsSetMode() bool {
  return p.Mode != nil
}

func (p *HostAttributes) IsSetSlaveId() bool {
  return p.SlaveId != nil
}

func (p *HostAttributes) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HostAttributes)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Host = v
}
  return nil
}

func (p *HostAttributes)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Attribute, 0, size)
  p.Attributes =  tSet
  for i := 0; i < size; i ++ {
    _elem2 := &Attribute{}
    if err := _elem2.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
    }
    p.Attributes = append(p.Attributes, _elem2)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *HostAttributes)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := MaintenanceMode(v)
  p.Mode = &temp
}
  return nil
}

func (p *HostAttributes)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.SlaveId = &v
}
  return nil
}

func (p *HostAttributes) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HostAttributes"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HostAttributes) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "host", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:host: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Host)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.host (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:host: ", p), err) }
  return err
}

func (p *HostAttributes) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "attributes", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:attributes: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Attributes)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Attributes); i++ {
    for j := i+1; j<len(p.Attributes); j++ {
      if func(tgt, src *Attribute) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Attributes[i], p.Attributes[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Attributes))
      }
    }
  }
  for _, v := range p.Attributes {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:attributes: ", p), err) }
  return err
}

func (p *HostAttributes) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMode() {
    if err := oprot.WriteFieldBegin(ctx, "mode", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:mode: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Mode)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.mode (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:mode: ", p), err) }
  }
  return err
}

func (p *HostAttributes) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSlaveId() {
    if err := oprot.WriteFieldBegin(ctx, "slaveId", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:slaveId: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.SlaveId)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.slaveId (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:slaveId: ", p), err) }
  }
  return err
}

func (p *HostAttributes) Equals(other *HostAttributes) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Host != other.Host { return false }
  if len(p.Attributes) != len(other.Attributes) { return false }
  for i, _tgt := range p.Attributes {
    _src3 := other.Attributes[i]
    if !_tgt.Equals(_src3) { return false }
  }
  if p.Mode != other.Mode {
    if p.Mode == nil || other.Mode == nil {
      return false
    }
    if (*p.Mode) != (*other.Mode) { return false }
  }
  if p.SlaveId != other.SlaveId {
    if p.SlaveId == nil || other.SlaveId == nil {
      return false
    }
    if (*p.SlaveId) != (*other.SlaveId) { return false }
  }
  return true
}

func (p *HostAttributes) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HostAttributes(%+v)", *p)
}

// A constraint that specifies an explicit set of values, at least one of which must be present
// on a host for a task to be scheduled there.
// 
// Attributes:
//  - Negated: If true, treat this as a 'not' - to avoid specific values.
//  - Values
type ValueConstraint struct {
  Negated bool `thrift:"negated,1" db:"negated" json:"negated"`
  Values []string `thrift:"values,2" db:"values" json:"values"`
}

func NewValueConstraint() *ValueConstraint {
  return &ValueConstraint{}
}


func (p *ValueConstraint) GetNegated() bool {
  return p.Negated
}

func (p *ValueConstraint) GetValues() []string {
  return p.Values
}
func (p *ValueConstraint) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ValueConstraint)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Negated = v
}
  return nil
}

func (p *ValueConstraint)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.Values =  tSet
  for i := 0; i < size; i ++ {
var _elem4 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem4 = v
}
    p.Values = append(p.Values, _elem4)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *ValueConstraint) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ValueConstraint"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ValueConstraint) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "negated", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:negated: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Negated)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.negated (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:negated: ", p), err) }
  return err
}

func (p *ValueConstraint) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.Values)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Values); i++ {
    for j := i+1; j<len(p.Values); j++ {
      if func(tgt, src string) bool {
        if tgt != src { return false }
        return true
      }(p.Values[i], p.Values[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Values))
      }
    }
  }
  for _, v := range p.Values {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err) }
  return err
}

func (p *ValueConstraint) Equals(other *ValueConstraint) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Negated != other.Negated { return false }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src5 := other.Values[i]
    if _tgt != _src5 { return false }
  }
  return true
}

func (p *ValueConstraint) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ValueConstraint(%+v)", *p)
}

// A constraint the specifies the maximum number of active tasks on a host with a matching
// attribute that may be scheduled simultaneously.
// 
// Attributes:
//  - Limit
type LimitConstraint struct {
  Limit int32 `thrift:"limit,1" db:"limit" json:"limit"`
}

func NewLimitConstraint() *LimitConstraint {
  return &LimitConstraint{}
}


func (p *LimitConstraint) GetLimit() int32 {
  return p.Limit
}
func (p *LimitConstraint) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LimitConstraint)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Limit = v
}
  return nil
}

func (p *LimitConstraint) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "LimitConstraint"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LimitConstraint) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:limit: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Limit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.limit (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:limit: ", p), err) }
  return err
}

func (p *LimitConstraint) Equals(other *LimitConstraint) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Limit != other.Limit { return false }
  return true
}

func (p *LimitConstraint) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LimitConstraint(%+v)", *p)
}

// Types of constraints that may be applied to a task.
// 
// Attributes:
//  - Value
//  - Limit
type TaskConstraint struct {
  Value *ValueConstraint `thrift:"value,1" db:"value" json:"value,omitempty"`
  Limit *LimitConstraint `thrift:"limit,2" db:"limit" json:"limit,omitempty"`
}

func NewTaskConstraint() *TaskConstraint {
  return &TaskConstraint{}
}

var TaskConstraint_Value_DEFAULT *ValueConstraint
func (p *TaskConstraint) GetValue() *ValueConstraint {
  if !p.IsSetValue() {
    return TaskConstraint_Value_DEFAULT
  }
return p.Value
}
var TaskConstraint_Limit_DEFAULT *LimitConstraint
func (p *TaskConstraint) GetLimit() *LimitConstraint {
  if !p.IsSetLimit() {
    return TaskConstraint_Limit_DEFAULT
  }
return p.Limit
}
func (p *TaskConstraint) CountSetFieldsTaskConstraint() int {
  count := 0
  if (p.IsSetValue()) {
    count++
  }
  if (p.IsSetLimit()) {
    count++
  }
  return count

}

func (p *TaskConstraint) IsSetValue() bool {
  return p.Value != nil
}

func (p *TaskConstraint) IsSetLimit() bool {
  return p.Limit != nil
}

func (p *TaskConstraint) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TaskConstraint)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Value = &ValueConstraint{}
  if err := p.Value.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Value), err)
  }
  return nil
}

func (p *TaskConstraint)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Limit = &LimitConstraint{}
  if err := p.Limit.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Limit), err)
  }
  return nil
}

func (p *TaskConstraint) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsTaskConstraint(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "TaskConstraint"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TaskConstraint) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetValue() {
    if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
    if err := p.Value.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Value), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  }
  return err
}

func (p *TaskConstraint) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLimit() {
    if err := oprot.WriteFieldBegin(ctx, "limit", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:limit: ", p), err) }
    if err := p.Limit.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Limit), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:limit: ", p), err) }
  }
  return err
}

func (p *TaskConstraint) Equals(other *TaskConstraint) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Value.Equals(other.Value) { return false }
  if !p.Limit.Equals(other.Limit) { return false }
  return true
}

func (p *TaskConstraint) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TaskConstraint(%+v)", *p)
}

// A constraint that defines whether a task may be scheduled on a host.
// 
// Attributes:
//  - Name: Mesos slave attribute that the constraint is matched against.
//  - Constraint
type Constraint struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Constraint *TaskConstraint `thrift:"constraint,2" db:"constraint" json:"constraint"`
}

func NewConstraint() *Constraint {
  return &Constraint{}
}


func (p *Constraint) GetName() string {
  return p.Name
}
var Constraint_Constraint_DEFAULT *TaskConstraint
func (p *Constraint) GetConstraint() *TaskConstraint {
  if !p.IsSetConstraint() {
    return Constraint_Constraint_DEFAULT
  }
return p.Constraint
}
func (p *Constraint) IsSetConstraint() bool {
  return p.Constraint != nil
}

func (p *Constraint) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Constraint)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Constraint)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Constraint = &TaskConstraint{}
  if err := p.Constraint.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Constraint), err)
  }
  return nil
}

func (p *Constraint) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Constraint"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Constraint) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *Constraint) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "constraint", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:constraint: ", p), err) }
  if err := p.Constraint.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Constraint), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:constraint: ", p), err) }
  return err
}

func (p *Constraint) Equals(other *Constraint) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if !p.Constraint.Equals(other.Constraint) { return false }
  return true
}

func (p *Constraint) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Constraint(%+v)", *p)
}

// Attributes:
//  - Role
//  - Name
//  - Version
type Package struct {
  Role string `thrift:"role,1" db:"role" json:"role"`
  Name string `thrift:"name,2" db:"name" json:"name"`
  Version int32 `thrift:"version,3" db:"version" json:"version"`
}

func NewPackage() *Package {
  return &Package{}
}


func (p *Package) GetRole() string {
  return p.Role
}

func (p *Package) GetName() string {
  return p.Name
}

func (p *Package) GetVersion() int32 {
  return p.Version
}
func (p *Package) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Package)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Role = v
}
  return nil
}

func (p *Package)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *Package)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Version = v
}
  return nil
}

func (p *Package) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Package"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Package) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "role", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:role: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Role)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.role (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:role: ", p), err) }
  return err
}

func (p *Package) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:name: ", p), err) }
  return err
}

func (p *Package) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "version", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:version: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Version)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.version (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:version: ", p), err) }
  return err
}

func (p *Package) Equals(other *Package) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Role != other.Role { return false }
  if p.Name != other.Name { return false }
  if p.Version != other.Version { return false }
  return true
}

func (p *Package) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Package(%+v)", *p)
}

// Arbitrary key-value metadata to be included into TaskConfig.
// 
// Attributes:
//  - Key
//  - Value
type Metadata struct {
  Key string `thrift:"key,1" db:"key" json:"key"`
  Value string `thrift:"value,2" db:"value" json:"value"`
}

func NewMetadata() *Metadata {
  return &Metadata{}
}


func (p *Metadata) GetKey() string {
  return p.Key
}

func (p *Metadata) GetValue() string {
  return p.Value
}
func (p *Metadata) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Metadata)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Key = v
}
  return nil
}

func (p *Metadata)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *Metadata) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Metadata"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Metadata) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Key)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *Metadata) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err) }
  return err
}

func (p *Metadata) Equals(other *Metadata) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Key != other.Key { return false }
  if p.Value != other.Value { return false }
  return true
}

func (p *Metadata) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Metadata(%+v)", *p)
}

// A unique identifier for a Job.
// 
// Attributes:
//  - Role: User role (Unix service account), for example "mesos"
//  - Environment: Environment, for example "devel"
//  - Name: Name, for example "labrat"
type JobKey struct {
  Role string `thrift:"role,1" db:"role" json:"role"`
  Environment string `thrift:"environment,2" db:"environment" json:"environment"`
  Name string `thrift:"name,3" db:"name" json:"name"`
}

func NewJobKey() *JobKey {
  return &JobKey{}
}


func (p *JobKey) GetRole() string {
  return p.Role
}

func (p *JobKey) GetEnvironment() string {
  return p.Environment
}

func (p *JobKey) GetName() string {
  return p.Name
}
func (p *JobKey) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobKey)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Role = v
}
  return nil
}

func (p *JobKey)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Environment = v
}
  return nil
}

func (p *JobKey)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *JobKey) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobKey"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobKey) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "role", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:role: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Role)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.role (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:role: ", p), err) }
  return err
}

func (p *JobKey) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "environment", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:environment: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Environment)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.environment (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:environment: ", p), err) }
  return err
}

func (p *JobKey) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:name: ", p), err) }
  return err
}

func (p *JobKey) Equals(other *JobKey) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Role != other.Role { return false }
  if p.Environment != other.Environment { return false }
  if p.Name != other.Name { return false }
  return true
}

func (p *JobKey) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobKey(%+v)", *p)
}

// A unique lock key.
// 
// Attributes:
//  - Job
type LockKey struct {
  Job *JobKey `thrift:"job,1" db:"job" json:"job,omitempty"`
}

func NewLockKey() *LockKey {
  return &LockKey{}
}

var LockKey_Job_DEFAULT *JobKey
func (p *LockKey) GetJob() *JobKey {
  if !p.IsSetJob() {
    return LockKey_Job_DEFAULT
  }
return p.Job
}
func (p *LockKey) CountSetFieldsLockKey() int {
  count := 0
  if (p.IsSetJob()) {
    count++
  }
  return count

}

func (p *LockKey) IsSetJob() bool {
  return p.Job != nil
}

func (p *LockKey) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *LockKey)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *LockKey) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsLockKey(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "LockKey"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *LockKey) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetJob() {
    if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:job: ", p), err) }
    if err := p.Job.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:job: ", p), err) }
  }
  return err
}

func (p *LockKey) Equals(other *LockKey) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Job.Equals(other.Job) { return false }
  return true
}

func (p *LockKey) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("LockKey(%+v)", *p)
}

// A generic lock struct to facilitate context specific resource/operation serialization.
// 
// Attributes:
//  - Key: ID of the lock - unique per storage
//  - Token: UUID - facilitating soft lock authorization
//  - User: Lock creator
//  - TimestampMs: Lock creation timestamp in milliseconds
//  - Message: Optional message to record with the lock
type Lock struct {
  Key *LockKey `thrift:"key,1" db:"key" json:"key"`
  Token string `thrift:"token,2" db:"token" json:"token"`
  User string `thrift:"user,3" db:"user" json:"user"`
  TimestampMs int64 `thrift:"timestampMs,4" db:"timestampMs" json:"timestampMs"`
  Message *string `thrift:"message,5" db:"message" json:"message,omitempty"`
}

func NewLock() *Lock {
  return &Lock{}
}

var Lock_Key_DEFAULT *LockKey
func (p *Lock) GetKey() *LockKey {
  if !p.IsSetKey() {
    return Lock_Key_DEFAULT
  }
return p.Key
}

func (p *Lock) GetToken() string {
  return p.Token
}

func (p *Lock) GetUser() string {
  return p.User
}

func (p *Lock) GetTimestampMs() int64 {
  return p.TimestampMs
}
var Lock_Message_DEFAULT string
func (p *Lock) GetMessage() string {
  if !p.IsSetMessage() {
    return Lock_Message_DEFAULT
  }
return *p.Message
}
func (p *Lock) IsSetKey() bool {
  return p.Key != nil
}

func (p *Lock) IsSetMessage() bool {
  return p.Message != nil
}

func (p *Lock) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Lock)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &LockKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *Lock)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Token = v
}
  return nil
}

func (p *Lock)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.User = v
}
  return nil
}

func (p *Lock)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TimestampMs = v
}
  return nil
}

func (p *Lock)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *Lock) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Lock"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Lock) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *Lock) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "token", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:token: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Token)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.token (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:token: ", p), err) }
  return err
}

func (p *Lock) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "user", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:user: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.User)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.user (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:user: ", p), err) }
  return err
}

func (p *Lock) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timestampMs", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timestampMs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TimestampMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timestampMs (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timestampMs: ", p), err) }
  return err
}

func (p *Lock) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:message: ", p), err) }
  }
  return err
}

func (p *Lock) Equals(other *Lock) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Key.Equals(other.Key) { return false }
  if p.Token != other.Token { return false }
  if p.User != other.User { return false }
  if p.TimestampMs != other.TimestampMs { return false }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  return true
}

func (p *Lock) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Lock(%+v)", *p)
}

// A unique identifier for the active task within a job.
// 
// Attributes:
//  - JobKey: Key identifying the job.
//  - InstanceId: Unique instance ID for the active task in a job.
type InstanceKey struct {
  JobKey *JobKey `thrift:"jobKey,1" db:"jobKey" json:"jobKey"`
  InstanceId int32 `thrift:"instanceId,2" db:"instanceId" json:"instanceId"`
}

func NewInstanceKey() *InstanceKey {
  return &InstanceKey{}
}

var InstanceKey_JobKey_DEFAULT *JobKey
func (p *InstanceKey) GetJobKey() *JobKey {
  if !p.IsSetJobKey() {
    return InstanceKey_JobKey_DEFAULT
  }
return p.JobKey
}

func (p *InstanceKey) GetInstanceId() int32 {
  return p.InstanceId
}
func (p *InstanceKey) IsSetJobKey() bool {
  return p.JobKey != nil
}

func (p *InstanceKey) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *InstanceKey)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.JobKey = &JobKey{}
  if err := p.JobKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.JobKey), err)
  }
  return nil
}

func (p *InstanceKey)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.InstanceId = v
}
  return nil
}

func (p *InstanceKey) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "InstanceKey"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *InstanceKey) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "jobKey", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:jobKey: ", p), err) }
  if err := p.JobKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.JobKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:jobKey: ", p), err) }
  return err
}

func (p *InstanceKey) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instanceId", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:instanceId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.InstanceId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.instanceId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:instanceId: ", p), err) }
  return err
}

func (p *InstanceKey) Equals(other *InstanceKey) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.JobKey.Equals(other.JobKey) { return false }
  if p.InstanceId != other.InstanceId { return false }
  return true
}

func (p *InstanceKey) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("InstanceKey(%+v)", *p)
}

// URI which mirrors CommandInfo.URI in the Mesos Protobuf
// 
// Attributes:
//  - Value: Where to get the resource from
//  - Extract: Extract compressed archive after downloading
//  - Cache: Cache value using Mesos Fetcher caching mechanism *
type MesosFetcherURI struct {
  Value string `thrift:"value,1" db:"value" json:"value"`
  Extract *bool `thrift:"extract,2" db:"extract" json:"extract,omitempty"`
  Cache *bool `thrift:"cache,3" db:"cache" json:"cache,omitempty"`
}

func NewMesosFetcherURI() *MesosFetcherURI {
  return &MesosFetcherURI{}
}


func (p *MesosFetcherURI) GetValue() string {
  return p.Value
}
var MesosFetcherURI_Extract_DEFAULT bool
func (p *MesosFetcherURI) GetExtract() bool {
  if !p.IsSetExtract() {
    return MesosFetcherURI_Extract_DEFAULT
  }
return *p.Extract
}
var MesosFetcherURI_Cache_DEFAULT bool
func (p *MesosFetcherURI) GetCache() bool {
  if !p.IsSetCache() {
    return MesosFetcherURI_Cache_DEFAULT
  }
return *p.Cache
}
func (p *MesosFetcherURI) IsSetExtract() bool {
  return p.Extract != nil
}

func (p *MesosFetcherURI) IsSetCache() bool {
  return p.Cache != nil
}

func (p *MesosFetcherURI) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *MesosFetcherURI)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *MesosFetcherURI)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Extract = &v
}
  return nil
}

func (p *MesosFetcherURI)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Cache = &v
}
  return nil
}

func (p *MesosFetcherURI) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "MesosFetcherURI"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *MesosFetcherURI) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:value: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:value: ", p), err) }
  return err
}

func (p *MesosFetcherURI) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExtract() {
    if err := oprot.WriteFieldBegin(ctx, "extract", thrift.BOOL, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:extract: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Extract)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.extract (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:extract: ", p), err) }
  }
  return err
}

func (p *MesosFetcherURI) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCache() {
    if err := oprot.WriteFieldBegin(ctx, "cache", thrift.BOOL, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:cache: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Cache)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cache (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:cache: ", p), err) }
  }
  return err
}

func (p *MesosFetcherURI) Equals(other *MesosFetcherURI) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Value != other.Value { return false }
  if p.Extract != other.Extract {
    if p.Extract == nil || other.Extract == nil {
      return false
    }
    if (*p.Extract) != (*other.Extract) { return false }
  }
  if p.Cache != other.Cache {
    if p.Cache == nil || other.Cache == nil {
      return false
    }
    if (*p.Cache) != (*other.Cache) { return false }
  }
  return true
}

func (p *MesosFetcherURI) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("MesosFetcherURI(%+v)", *p)
}

// Attributes:
//  - Name: Name identifying the Executor.
//  - Data: Executor configuration data.
type ExecutorConfig struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Data string `thrift:"data,2" db:"data" json:"data"`
}

func NewExecutorConfig() *ExecutorConfig {
  return &ExecutorConfig{}
}


func (p *ExecutorConfig) GetName() string {
  return p.Name
}

func (p *ExecutorConfig) GetData() string {
  return p.Data
}
func (p *ExecutorConfig) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ExecutorConfig)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *ExecutorConfig)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Data = v
}
  return nil
}

func (p *ExecutorConfig) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ExecutorConfig"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ExecutorConfig) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *ExecutorConfig) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "data", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:data: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Data)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.data (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:data: ", p), err) }
  return err
}

func (p *ExecutorConfig) Equals(other *ExecutorConfig) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Data != other.Data { return false }
  return true
}

func (p *ExecutorConfig) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ExecutorConfig(%+v)", *p)
}

// A volume mount point within a container
// 
// Attributes:
//  - ContainerPath: The path inside the container where the mount will be created.
//  - HostPath: The path on the host that will serve as the source for the mount.
//  - Mode: The access mode
type Volume struct {
  ContainerPath string `thrift:"containerPath,1" db:"containerPath" json:"containerPath"`
  HostPath string `thrift:"hostPath,2" db:"hostPath" json:"hostPath"`
  Mode Mode `thrift:"mode,3" db:"mode" json:"mode"`
}

func NewVolume() *Volume {
  return &Volume{}
}


func (p *Volume) GetContainerPath() string {
  return p.ContainerPath
}

func (p *Volume) GetHostPath() string {
  return p.HostPath
}

func (p *Volume) GetMode() Mode {
  return p.Mode
}
func (p *Volume) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Volume)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ContainerPath = v
}
  return nil
}

func (p *Volume)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.HostPath = v
}
  return nil
}

func (p *Volume)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := Mode(v)
  p.Mode = temp
}
  return nil
}

func (p *Volume) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Volume"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Volume) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "containerPath", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:containerPath: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ContainerPath)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.containerPath (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:containerPath: ", p), err) }
  return err
}

func (p *Volume) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hostPath", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:hostPath: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.HostPath)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.hostPath (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:hostPath: ", p), err) }
  return err
}

func (p *Volume) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "mode", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:mode: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Mode)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.mode (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:mode: ", p), err) }
  return err
}

func (p *Volume) Equals(other *Volume) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ContainerPath != other.ContainerPath { return false }
  if p.HostPath != other.HostPath { return false }
  if p.Mode != other.Mode { return false }
  return true
}

func (p *Volume) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Volume(%+v)", *p)
}

// Describes an image for use with the Mesos unified containerizer in the Docker format
// 
// Attributes:
//  - Name: The name of the image to run
//  - Tag: The Docker tag identifying the image
type DockerImage struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Tag string `thrift:"tag,2" db:"tag" json:"tag"`
}

func NewDockerImage() *DockerImage {
  return &DockerImage{}
}


func (p *DockerImage) GetName() string {
  return p.Name
}

func (p *DockerImage) GetTag() string {
  return p.Tag
}
func (p *DockerImage) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DockerImage)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *DockerImage)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Tag = v
}
  return nil
}

func (p *DockerImage) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DockerImage"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DockerImage) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *DockerImage) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tag", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tag: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Tag)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.tag (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tag: ", p), err) }
  return err
}

func (p *DockerImage) Equals(other *DockerImage) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Tag != other.Tag { return false }
  return true
}

func (p *DockerImage) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DockerImage(%+v)", *p)
}

// Describes an image for use with the Mesos unified containerizer in the AppC format
// 
// Attributes:
//  - Name: The name of the image to run
//  - ImageId: The appc image id identifying the image
type AppcImage struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  ImageId string `thrift:"imageId,2" db:"imageId" json:"imageId"`
}

func NewAppcImage() *AppcImage {
  return &AppcImage{}
}


func (p *AppcImage) GetName() string {
  return p.Name
}

func (p *AppcImage) GetImageId() string {
  return p.ImageId
}
func (p *AppcImage) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AppcImage)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *AppcImage)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ImageId = v
}
  return nil
}

func (p *AppcImage) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AppcImage"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AppcImage) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *AppcImage) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "imageId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:imageId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ImageId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.imageId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:imageId: ", p), err) }
  return err
}

func (p *AppcImage) Equals(other *AppcImage) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.ImageId != other.ImageId { return false }
  return true
}

func (p *AppcImage) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AppcImage(%+v)", *p)
}

// Describes an image to be used with the Mesos unified containerizer
// 
// Attributes:
//  - Docker
//  - Appc
type Image struct {
  Docker *DockerImage `thrift:"docker,1" db:"docker" json:"docker,omitempty"`
  Appc *AppcImage `thrift:"appc,2" db:"appc" json:"appc,omitempty"`
}

func NewImage() *Image {
  return &Image{}
}

var Image_Docker_DEFAULT *DockerImage
func (p *Image) GetDocker() *DockerImage {
  if !p.IsSetDocker() {
    return Image_Docker_DEFAULT
  }
return p.Docker
}
var Image_Appc_DEFAULT *AppcImage
func (p *Image) GetAppc() *AppcImage {
  if !p.IsSetAppc() {
    return Image_Appc_DEFAULT
  }
return p.Appc
}
func (p *Image) CountSetFieldsImage() int {
  count := 0
  if (p.IsSetDocker()) {
    count++
  }
  if (p.IsSetAppc()) {
    count++
  }
  return count

}

func (p *Image) IsSetDocker() bool {
  return p.Docker != nil
}

func (p *Image) IsSetAppc() bool {
  return p.Appc != nil
}

func (p *Image) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Image)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Docker = &DockerImage{}
  if err := p.Docker.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Docker), err)
  }
  return nil
}

func (p *Image)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Appc = &AppcImage{}
  if err := p.Appc.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Appc), err)
  }
  return nil
}

func (p *Image) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsImage(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "Image"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Image) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDocker() {
    if err := oprot.WriteFieldBegin(ctx, "docker", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:docker: ", p), err) }
    if err := p.Docker.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Docker), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:docker: ", p), err) }
  }
  return err
}

func (p *Image) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetAppc() {
    if err := oprot.WriteFieldBegin(ctx, "appc", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:appc: ", p), err) }
    if err := p.Appc.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Appc), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:appc: ", p), err) }
  }
  return err
}

func (p *Image) Equals(other *Image) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Docker.Equals(other.Docker) { return false }
  if !p.Appc.Equals(other.Appc) { return false }
  return true
}

func (p *Image) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Image(%+v)", *p)
}

// Describes a mesos container, this is the default
// 
// Attributes:
//  - Image: the optional filesystem image to use when launching this task.
//  - Volumes: the optional list of volumes to mount into the task.
type MesosContainer struct {
  Image *Image `thrift:"image,1" db:"image" json:"image,omitempty"`
  Volumes []*Volume `thrift:"volumes,2" db:"volumes" json:"volumes,omitempty"`
}

func NewMesosContainer() *MesosContainer {
  return &MesosContainer{}
}

var MesosContainer_Image_DEFAULT *Image
func (p *MesosContainer) GetImage() *Image {
  if !p.IsSetImage() {
    return MesosContainer_Image_DEFAULT
  }
return p.Image
}
var MesosContainer_Volumes_DEFAULT []*Volume

func (p *MesosContainer) GetVolumes() []*Volume {
  return p.Volumes
}
func (p *MesosContainer) IsSetImage() bool {
  return p.Image != nil
}

func (p *MesosContainer) IsSetVolumes() bool {
  return p.Volumes != nil
}

func (p *MesosContainer) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *MesosContainer)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Image = &Image{}
  if err := p.Image.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Image), err)
  }
  return nil
}

func (p *MesosContainer)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Volume, 0, size)
  p.Volumes =  tSlice
  for i := 0; i < size; i ++ {
    _elem6 := &Volume{}
    if err := _elem6.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem6), err)
    }
    p.Volumes = append(p.Volumes, _elem6)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *MesosContainer) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "MesosContainer"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *MesosContainer) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetImage() {
    if err := oprot.WriteFieldBegin(ctx, "image", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:image: ", p), err) }
    if err := p.Image.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Image), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:image: ", p), err) }
  }
  return err
}

func (p *MesosContainer) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVolumes() {
    if err := oprot.WriteFieldBegin(ctx, "volumes", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:volumes: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Volumes)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Volumes {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:volumes: ", p), err) }
  }
  return err
}

func (p *MesosContainer) Equals(other *MesosContainer) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Image.Equals(other.Image) { return false }
  if len(p.Volumes) != len(other.Volumes) { return false }
  for i, _tgt := range p.Volumes {
    _src7 := other.Volumes[i]
    if !_tgt.Equals(_src7) { return false }
  }
  return true
}

func (p *MesosContainer) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("MesosContainer(%+v)", *p)
}

// Describes a parameter passed to docker cli
// 
// Attributes:
//  - Name: a parameter to pass to docker. (e.g. volume)
//  - Value: the value to pass to a parameter (e.g. /src/webapp:/opt/webapp)
type DockerParameter struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Value string `thrift:"value,2" db:"value" json:"value"`
}

func NewDockerParameter() *DockerParameter {
  return &DockerParameter{}
}


func (p *DockerParameter) GetName() string {
  return p.Name
}

func (p *DockerParameter) GetValue() string {
  return p.Value
}
func (p *DockerParameter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DockerParameter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *DockerParameter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *DockerParameter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DockerParameter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DockerParameter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *DockerParameter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err) }
  return err
}

func (p *DockerParameter) Equals(other *DockerParameter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if p.Value != other.Value { return false }
  return true
}

func (p *DockerParameter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DockerParameter(%+v)", *p)
}

// Describes a docker container
// 
// Attributes:
//  - Image: The container image to be run
//  - Parameters: The arbitrary parameters to pass to container
type DockerContainer struct {
  Image string `thrift:"image,1" db:"image" json:"image"`
  Parameters []*DockerParameter `thrift:"parameters,2" db:"parameters" json:"parameters,omitempty"`
}

func NewDockerContainer() *DockerContainer {
  return &DockerContainer{}
}


func (p *DockerContainer) GetImage() string {
  return p.Image
}
var DockerContainer_Parameters_DEFAULT []*DockerParameter

func (p *DockerContainer) GetParameters() []*DockerParameter {
  return p.Parameters
}
func (p *DockerContainer) IsSetParameters() bool {
  return p.Parameters != nil
}

func (p *DockerContainer) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DockerContainer)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Image = v
}
  return nil
}

func (p *DockerContainer)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*DockerParameter, 0, size)
  p.Parameters =  tSlice
  for i := 0; i < size; i ++ {
    _elem8 := &DockerParameter{}
    if err := _elem8.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem8), err)
    }
    p.Parameters = append(p.Parameters, _elem8)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *DockerContainer) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DockerContainer"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DockerContainer) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "image", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:image: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Image)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.image (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:image: ", p), err) }
  return err
}

func (p *DockerContainer) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetParameters() {
    if err := oprot.WriteFieldBegin(ctx, "parameters", thrift.LIST, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:parameters: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Parameters)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Parameters {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:parameters: ", p), err) }
  }
  return err
}

func (p *DockerContainer) Equals(other *DockerContainer) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Image != other.Image { return false }
  if len(p.Parameters) != len(other.Parameters) { return false }
  for i, _tgt := range p.Parameters {
    _src9 := other.Parameters[i]
    if !_tgt.Equals(_src9) { return false }
  }
  return true
}

func (p *DockerContainer) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DockerContainer(%+v)", *p)
}

// Describes a container to be used in a task
// 
// Attributes:
//  - Mesos
//  - Docker
type Container struct {
  Mesos *MesosContainer `thrift:"mesos,1" db:"mesos" json:"mesos,omitempty"`
  Docker *DockerContainer `thrift:"docker,2" db:"docker" json:"docker,omitempty"`
}

func NewContainer() *Container {
  return &Container{}
}

var Container_Mesos_DEFAULT *MesosContainer
func (p *Container) GetMesos() *MesosContainer {
  if !p.IsSetMesos() {
    return Container_Mesos_DEFAULT
  }
return p.Mesos
}
var Container_Docker_DEFAULT *DockerContainer
func (p *Container) GetDocker() *DockerContainer {
  if !p.IsSetDocker() {
    return Container_Docker_DEFAULT
  }
return p.Docker
}
func (p *Container) CountSetFieldsContainer() int {
  count := 0
  if (p.IsSetMesos()) {
    count++
  }
  if (p.IsSetDocker()) {
    count++
  }
  return count

}

func (p *Container) IsSetMesos() bool {
  return p.Mesos != nil
}

func (p *Container) IsSetDocker() bool {
  return p.Docker != nil
}

func (p *Container) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Container)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Mesos = &MesosContainer{}
  if err := p.Mesos.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Mesos), err)
  }
  return nil
}

func (p *Container)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Docker = &DockerContainer{}
  if err := p.Docker.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Docker), err)
  }
  return nil
}

func (p *Container) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsContainer(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "Container"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Container) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMesos() {
    if err := oprot.WriteFieldBegin(ctx, "mesos", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:mesos: ", p), err) }
    if err := p.Mesos.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Mesos), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:mesos: ", p), err) }
  }
  return err
}

func (p *Container) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDocker() {
    if err := oprot.WriteFieldBegin(ctx, "docker", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:docker: ", p), err) }
    if err := p.Docker.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Docker), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:docker: ", p), err) }
  }
  return err
}

func (p *Container) Equals(other *Container) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Mesos.Equals(other.Mesos) { return false }
  if !p.Docker.Equals(other.Docker) { return false }
  return true
}

func (p *Container) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Container(%+v)", *p)
}

// Describes resource value required to run a task.
// 
// Attributes:
//  - NumCpus
//  - RamMb
//  - DiskMb
//  - NamedPort
//  - NumGpus
type Resource struct {
  NumCpus *float64 `thrift:"numCpus,1" db:"numCpus" json:"numCpus,omitempty"`
  RamMb *int64 `thrift:"ramMb,2" db:"ramMb" json:"ramMb,omitempty"`
  DiskMb *int64 `thrift:"diskMb,3" db:"diskMb" json:"diskMb,omitempty"`
  NamedPort *string `thrift:"namedPort,4" db:"namedPort" json:"namedPort,omitempty"`
  NumGpus *int64 `thrift:"numGpus,5" db:"numGpus" json:"numGpus,omitempty"`
}

func NewResource() *Resource {
  return &Resource{}
}

var Resource_NumCpus_DEFAULT float64
func (p *Resource) GetNumCpus() float64 {
  if !p.IsSetNumCpus() {
    return Resource_NumCpus_DEFAULT
  }
return *p.NumCpus
}
var Resource_RamMb_DEFAULT int64
func (p *Resource) GetRamMb() int64 {
  if !p.IsSetRamMb() {
    return Resource_RamMb_DEFAULT
  }
return *p.RamMb
}
var Resource_DiskMb_DEFAULT int64
func (p *Resource) GetDiskMb() int64 {
  if !p.IsSetDiskMb() {
    return Resource_DiskMb_DEFAULT
  }
return *p.DiskMb
}
var Resource_NamedPort_DEFAULT string
func (p *Resource) GetNamedPort() string {
  if !p.IsSetNamedPort() {
    return Resource_NamedPort_DEFAULT
  }
return *p.NamedPort
}
var Resource_NumGpus_DEFAULT int64
func (p *Resource) GetNumGpus() int64 {
  if !p.IsSetNumGpus() {
    return Resource_NumGpus_DEFAULT
  }
return *p.NumGpus
}
func (p *Resource) CountSetFieldsResource() int {
  count := 0
  if (p.IsSetNumCpus()) {
    count++
  }
  if (p.IsSetRamMb()) {
    count++
  }
  if (p.IsSetDiskMb()) {
    count++
  }
  if (p.IsSetNamedPort()) {
    count++
  }
  if (p.IsSetNumGpus()) {
    count++
  }
  return count

}

func (p *Resource) IsSetNumCpus() bool {
  return p.NumCpus != nil
}

func (p *Resource) IsSetRamMb() bool {
  return p.RamMb != nil
}

func (p *Resource) IsSetDiskMb() bool {
  return p.DiskMb != nil
}

func (p *Resource) IsSetNamedPort() bool {
  return p.NamedPort != nil
}

func (p *Resource) IsSetNumGpus() bool {
  return p.NumGpus != nil
}

func (p *Resource) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Resource)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.NumCpus = &v
}
  return nil
}

func (p *Resource)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.RamMb = &v
}
  return nil
}

func (p *Resource)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.DiskMb = &v
}
  return nil
}

func (p *Resource)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.NamedPort = &v
}
  return nil
}

func (p *Resource)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.NumGpus = &v
}
  return nil
}

func (p *Resource) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsResource(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "Resource"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Resource) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNumCpus() {
    if err := oprot.WriteFieldBegin(ctx, "numCpus", thrift.DOUBLE, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:numCpus: ", p), err) }
    if err := oprot.WriteDouble(ctx, float64(*p.NumCpus)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.numCpus (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:numCpus: ", p), err) }
  }
  return err
}

func (p *Resource) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRamMb() {
    if err := oprot.WriteFieldBegin(ctx, "ramMb", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ramMb: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.RamMb)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ramMb (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ramMb: ", p), err) }
  }
  return err
}

func (p *Resource) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDiskMb() {
    if err := oprot.WriteFieldBegin(ctx, "diskMb", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:diskMb: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.DiskMb)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.diskMb (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:diskMb: ", p), err) }
  }
  return err
}

func (p *Resource) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNamedPort() {
    if err := oprot.WriteFieldBegin(ctx, "namedPort", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:namedPort: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.NamedPort)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.namedPort (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:namedPort: ", p), err) }
  }
  return err
}

func (p *Resource) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNumGpus() {
    if err := oprot.WriteFieldBegin(ctx, "numGpus", thrift.I64, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:numGpus: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.NumGpus)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.numGpus (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:numGpus: ", p), err) }
  }
  return err
}

func (p *Resource) Equals(other *Resource) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.NumCpus != other.NumCpus {
    if p.NumCpus == nil || other.NumCpus == nil {
      return false
    }
    if (*p.NumCpus) != (*other.NumCpus) { return false }
  }
  if p.RamMb != other.RamMb {
    if p.RamMb == nil || other.RamMb == nil {
      return false
    }
    if (*p.RamMb) != (*other.RamMb) { return false }
  }
  if p.DiskMb != other.DiskMb {
    if p.DiskMb == nil || other.DiskMb == nil {
      return false
    }
    if (*p.DiskMb) != (*other.DiskMb) { return false }
  }
  if p.NamedPort != other.NamedPort {
    if p.NamedPort == nil || other.NamedPort == nil {
      return false
    }
    if (*p.NamedPort) != (*other.NamedPort) { return false }
  }
  if p.NumGpus != other.NumGpus {
    if p.NumGpus == nil || other.NumGpus == nil {
      return false
    }
    if (*p.NumGpus) != (*other.NumGpus) { return false }
  }
  return true
}

func (p *Resource) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Resource(%+v)", *p)
}

// Attributes:
//  - Reschedule
//  - DelaySecs
type PartitionPolicy struct {
  Reschedule bool `thrift:"reschedule,1" db:"reschedule" json:"reschedule"`
  DelaySecs *int64 `thrift:"delaySecs,2" db:"delaySecs" json:"delaySecs,omitempty"`
}

func NewPartitionPolicy() *PartitionPolicy {
  return &PartitionPolicy{}
}


func (p *PartitionPolicy) GetReschedule() bool {
  return p.Reschedule
}
var PartitionPolicy_DelaySecs_DEFAULT int64
func (p *PartitionPolicy) GetDelaySecs() int64 {
  if !p.IsSetDelaySecs() {
    return PartitionPolicy_DelaySecs_DEFAULT
  }
return *p.DelaySecs
}
func (p *PartitionPolicy) IsSetDelaySecs() bool {
  return p.DelaySecs != nil
}

func (p *PartitionPolicy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PartitionPolicy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Reschedule = v
}
  return nil
}

func (p *PartitionPolicy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.DelaySecs = &v
}
  return nil
}

func (p *PartitionPolicy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PartitionPolicy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PartitionPolicy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "reschedule", thrift.BOOL, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:reschedule: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.Reschedule)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reschedule (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:reschedule: ", p), err) }
  return err
}

func (p *PartitionPolicy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDelaySecs() {
    if err := oprot.WriteFieldBegin(ctx, "delaySecs", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:delaySecs: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.DelaySecs)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.delaySecs (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:delaySecs: ", p), err) }
  }
  return err
}

func (p *PartitionPolicy) Equals(other *PartitionPolicy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Reschedule != other.Reschedule { return false }
  if p.DelaySecs != other.DelaySecs {
    if p.DelaySecs == nil || other.DelaySecs == nil {
      return false
    }
    if (*p.DelaySecs) != (*other.DelaySecs) { return false }
  }
  return true
}

func (p *PartitionPolicy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PartitionPolicy(%+v)", *p)
}

// SLA requirements expressed as the percentage of instances to be RUNNING every durationSecs
// 
// Attributes:
//  - Percentage
//  - DurationSecs: Minimum time duration a task needs to be `RUNNING` to be treated as active
type PercentageSlaPolicy struct {
  Percentage float64 `thrift:"percentage,1" db:"percentage" json:"percentage"`
  DurationSecs int64 `thrift:"durationSecs,2" db:"durationSecs" json:"durationSecs"`
}

func NewPercentageSlaPolicy() *PercentageSlaPolicy {
  return &PercentageSlaPolicy{}
}


func (p *PercentageSlaPolicy) GetPercentage() float64 {
  return p.Percentage
}

func (p *PercentageSlaPolicy) GetDurationSecs() int64 {
  return p.DurationSecs
}
func (p *PercentageSlaPolicy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PercentageSlaPolicy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Percentage = v
}
  return nil
}

func (p *PercentageSlaPolicy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.DurationSecs = v
}
  return nil
}

func (p *PercentageSlaPolicy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PercentageSlaPolicy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PercentageSlaPolicy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "percentage", thrift.DOUBLE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:percentage: ", p), err) }
  if err := oprot.WriteDouble(ctx, float64(p.Percentage)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.percentage (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:percentage: ", p), err) }
  return err
}

func (p *PercentageSlaPolicy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "durationSecs", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:durationSecs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.DurationSecs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.durationSecs (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:durationSecs: ", p), err) }
  return err
}

func (p *PercentageSlaPolicy) Equals(other *PercentageSlaPolicy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Percentage != other.Percentage { return false }
  if p.DurationSecs != other.DurationSecs { return false }
  return true
}

func (p *PercentageSlaPolicy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PercentageSlaPolicy(%+v)", *p)
}

// SLA requirements expressed as the number of instances to be RUNNING every durationSecs
// 
// Attributes:
//  - Count: The number of active instances required every `durationSecs`
//  - DurationSecs: Minimum time duration a task needs to be `RUNNING` to be treated as active
type CountSlaPolicy struct {
  Count int64 `thrift:"count,1" db:"count" json:"count"`
  DurationSecs int64 `thrift:"durationSecs,2" db:"durationSecs" json:"durationSecs"`
}

func NewCountSlaPolicy() *CountSlaPolicy {
  return &CountSlaPolicy{}
}


func (p *CountSlaPolicy) GetCount() int64 {
  return p.Count
}

func (p *CountSlaPolicy) GetDurationSecs() int64 {
  return p.DurationSecs
}
func (p *CountSlaPolicy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CountSlaPolicy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *CountSlaPolicy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.DurationSecs = v
}
  return nil
}

func (p *CountSlaPolicy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CountSlaPolicy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CountSlaPolicy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "count", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:count: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:count: ", p), err) }
  return err
}

func (p *CountSlaPolicy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "durationSecs", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:durationSecs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.DurationSecs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.durationSecs (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:durationSecs: ", p), err) }
  return err
}

func (p *CountSlaPolicy) Equals(other *CountSlaPolicy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Count != other.Count { return false }
  if p.DurationSecs != other.DurationSecs { return false }
  return true
}

func (p *CountSlaPolicy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CountSlaPolicy(%+v)", *p)
}

// SLA requirements to be delegated to an external coordinator
// 
// Attributes:
//  - CoordinatorUrl: URL for the coordinator service that needs to be contacted for SLA checks
//  - StatusKey: Field in the Coordinator response json indicating if the action is allowed or not
type CoordinatorSlaPolicy struct {
  CoordinatorUrl string `thrift:"coordinatorUrl,1" db:"coordinatorUrl" json:"coordinatorUrl"`
  StatusKey string `thrift:"statusKey,2" db:"statusKey" json:"statusKey"`
}

func NewCoordinatorSlaPolicy() *CoordinatorSlaPolicy {
  return &CoordinatorSlaPolicy{}
}


func (p *CoordinatorSlaPolicy) GetCoordinatorUrl() string {
  return p.CoordinatorUrl
}

func (p *CoordinatorSlaPolicy) GetStatusKey() string {
  return p.StatusKey
}
func (p *CoordinatorSlaPolicy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CoordinatorSlaPolicy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.CoordinatorUrl = v
}
  return nil
}

func (p *CoordinatorSlaPolicy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.StatusKey = v
}
  return nil
}

func (p *CoordinatorSlaPolicy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CoordinatorSlaPolicy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CoordinatorSlaPolicy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "coordinatorUrl", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:coordinatorUrl: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.CoordinatorUrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.coordinatorUrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:coordinatorUrl: ", p), err) }
  return err
}

func (p *CoordinatorSlaPolicy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "statusKey", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:statusKey: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.StatusKey)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.statusKey (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:statusKey: ", p), err) }
  return err
}

func (p *CoordinatorSlaPolicy) Equals(other *CoordinatorSlaPolicy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.CoordinatorUrl != other.CoordinatorUrl { return false }
  if p.StatusKey != other.StatusKey { return false }
  return true
}

func (p *CoordinatorSlaPolicy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CoordinatorSlaPolicy(%+v)", *p)
}

// SLA requirements expressed in one of the many types
// 
// Attributes:
//  - PercentageSlaPolicy
//  - CountSlaPolicy
//  - CoordinatorSlaPolicy
type SlaPolicy struct {
  PercentageSlaPolicy *PercentageSlaPolicy `thrift:"percentageSlaPolicy,1" db:"percentageSlaPolicy" json:"percentageSlaPolicy,omitempty"`
  CountSlaPolicy *CountSlaPolicy `thrift:"countSlaPolicy,2" db:"countSlaPolicy" json:"countSlaPolicy,omitempty"`
  CoordinatorSlaPolicy *CoordinatorSlaPolicy `thrift:"coordinatorSlaPolicy,3" db:"coordinatorSlaPolicy" json:"coordinatorSlaPolicy,omitempty"`
}

func NewSlaPolicy() *SlaPolicy {
  return &SlaPolicy{}
}

var SlaPolicy_PercentageSlaPolicy_DEFAULT *PercentageSlaPolicy
func (p *SlaPolicy) GetPercentageSlaPolicy() *PercentageSlaPolicy {
  if !p.IsSetPercentageSlaPolicy() {
    return SlaPolicy_PercentageSlaPolicy_DEFAULT
  }
return p.PercentageSlaPolicy
}
var SlaPolicy_CountSlaPolicy_DEFAULT *CountSlaPolicy
func (p *SlaPolicy) GetCountSlaPolicy() *CountSlaPolicy {
  if !p.IsSetCountSlaPolicy() {
    return SlaPolicy_CountSlaPolicy_DEFAULT
  }
return p.CountSlaPolicy
}
var SlaPolicy_CoordinatorSlaPolicy_DEFAULT *CoordinatorSlaPolicy
func (p *SlaPolicy) GetCoordinatorSlaPolicy() *CoordinatorSlaPolicy {
  if !p.IsSetCoordinatorSlaPolicy() {
    return SlaPolicy_CoordinatorSlaPolicy_DEFAULT
  }
return p.CoordinatorSlaPolicy
}
func (p *SlaPolicy) CountSetFieldsSlaPolicy() int {
  count := 0
  if (p.IsSetPercentageSlaPolicy()) {
    count++
  }
  if (p.IsSetCountSlaPolicy()) {
    count++
  }
  if (p.IsSetCoordinatorSlaPolicy()) {
    count++
  }
  return count

}

func (p *SlaPolicy) IsSetPercentageSlaPolicy() bool {
  return p.PercentageSlaPolicy != nil
}

func (p *SlaPolicy) IsSetCountSlaPolicy() bool {
  return p.CountSlaPolicy != nil
}

func (p *SlaPolicy) IsSetCoordinatorSlaPolicy() bool {
  return p.CoordinatorSlaPolicy != nil
}

func (p *SlaPolicy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SlaPolicy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PercentageSlaPolicy = &PercentageSlaPolicy{}
  if err := p.PercentageSlaPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PercentageSlaPolicy), err)
  }
  return nil
}

func (p *SlaPolicy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.CountSlaPolicy = &CountSlaPolicy{}
  if err := p.CountSlaPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CountSlaPolicy), err)
  }
  return nil
}

func (p *SlaPolicy)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.CoordinatorSlaPolicy = &CoordinatorSlaPolicy{}
  if err := p.CoordinatorSlaPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CoordinatorSlaPolicy), err)
  }
  return nil
}

func (p *SlaPolicy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsSlaPolicy(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "SlaPolicy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SlaPolicy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPercentageSlaPolicy() {
    if err := oprot.WriteFieldBegin(ctx, "percentageSlaPolicy", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:percentageSlaPolicy: ", p), err) }
    if err := p.PercentageSlaPolicy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PercentageSlaPolicy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:percentageSlaPolicy: ", p), err) }
  }
  return err
}

func (p *SlaPolicy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCountSlaPolicy() {
    if err := oprot.WriteFieldBegin(ctx, "countSlaPolicy", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:countSlaPolicy: ", p), err) }
    if err := p.CountSlaPolicy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CountSlaPolicy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:countSlaPolicy: ", p), err) }
  }
  return err
}

func (p *SlaPolicy) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCoordinatorSlaPolicy() {
    if err := oprot.WriteFieldBegin(ctx, "coordinatorSlaPolicy", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:coordinatorSlaPolicy: ", p), err) }
    if err := p.CoordinatorSlaPolicy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CoordinatorSlaPolicy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:coordinatorSlaPolicy: ", p), err) }
  }
  return err
}

func (p *SlaPolicy) Equals(other *SlaPolicy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.PercentageSlaPolicy.Equals(other.PercentageSlaPolicy) { return false }
  if !p.CountSlaPolicy.Equals(other.CountSlaPolicy) { return false }
  if !p.CoordinatorSlaPolicy.Equals(other.CoordinatorSlaPolicy) { return false }
  return true
}

func (p *SlaPolicy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SlaPolicy(%+v)", *p)
}

// Description of the tasks contained within a job.
// 
// Attributes:
//  - Job: Job task belongs to.
//  - Owner: contains the role component of JobKey
//  - IsService
//  - Priority
//  - MaxTaskFailures
//  - Production: Whether this is a production task, which can preempt.
//  - Tier: Task tier type.
//  - Resources: All resources required to run a task.
//  - Constraints
//  - MesosFetcherUris: Resources to retrieve with Mesos Fetcher
//  - TaskLinks: Custom links to include when displaying this task on the scheduler dashboard. Keys are anchor
// text, values are URLs. Wildcards are supported for dynamic link crafting based on host, ports,
// instance, etc.
//  - ContactEmail
//  - ExecutorConfig: Executor configuration
//  - Metadata: Used to display additional details in the UI.
//  - PartitionPolicy: Policy for how to deal with task partitions
//  - SlaPolicy: SLA requirements to be met during maintenance
//  - Container: the container the task should use to execute
type TaskConfig struct {
  // unused fields # 1 to 6
  IsService bool `thrift:"isService,7" db:"isService" json:"isService"`
  // unused fields # 8 to 10
  Priority int32 `thrift:"priority,11" db:"priority" json:"priority"`
  // unused field # 12
  MaxTaskFailures int32 `thrift:"maxTaskFailures,13" db:"maxTaskFailures" json:"maxTaskFailures"`
  // unused fields # 14 to 16
  Owner *Identity `thrift:"owner,17" db:"owner" json:"owner"`
  Production *bool `thrift:"production,18" db:"production" json:"production,omitempty"`
  // unused field # 19
  Constraints []*Constraint `thrift:"constraints,20" db:"constraints" json:"constraints"`
  // unused field # 21
  TaskLinks map[string]string `thrift:"taskLinks,22" db:"taskLinks" json:"taskLinks,omitempty"`
  ContactEmail *string `thrift:"contactEmail,23" db:"contactEmail" json:"contactEmail,omitempty"`
  // unused field # 24
  ExecutorConfig *ExecutorConfig `thrift:"executorConfig,25" db:"executorConfig" json:"executorConfig,omitempty"`
  // unused field # 26
  Metadata []*Metadata `thrift:"metadata,27" db:"metadata" json:"metadata,omitempty"`
  Job *JobKey `thrift:"job,28" db:"job" json:"job"`
  Container *Container `thrift:"container,29" db:"container" json:"container"`
  Tier *string `thrift:"tier,30" db:"tier" json:"tier,omitempty"`
  // unused field # 31
  Resources []*Resource `thrift:"resources,32" db:"resources" json:"resources"`
  MesosFetcherUris []*MesosFetcherURI `thrift:"mesosFetcherUris,33" db:"mesosFetcherUris" json:"mesosFetcherUris,omitempty"`
  PartitionPolicy *PartitionPolicy `thrift:"partitionPolicy,34" db:"partitionPolicy" json:"partitionPolicy,omitempty"`
  SlaPolicy *SlaPolicy `thrift:"slaPolicy,35" db:"slaPolicy" json:"slaPolicy,omitempty"`
}

func NewTaskConfig() *TaskConfig {
  return &TaskConfig{}
}

var TaskConfig_Job_DEFAULT *JobKey
func (p *TaskConfig) GetJob() *JobKey {
  if !p.IsSetJob() {
    return TaskConfig_Job_DEFAULT
  }
return p.Job
}
var TaskConfig_Owner_DEFAULT *Identity
func (p *TaskConfig) GetOwner() *Identity {
  if !p.IsSetOwner() {
    return TaskConfig_Owner_DEFAULT
  }
return p.Owner
}

func (p *TaskConfig) GetIsService() bool {
  return p.IsService
}

func (p *TaskConfig) GetPriority() int32 {
  return p.Priority
}

func (p *TaskConfig) GetMaxTaskFailures() int32 {
  return p.MaxTaskFailures
}
var TaskConfig_Production_DEFAULT bool
func (p *TaskConfig) GetProduction() bool {
  if !p.IsSetProduction() {
    return TaskConfig_Production_DEFAULT
  }
return *p.Production
}
var TaskConfig_Tier_DEFAULT string
func (p *TaskConfig) GetTier() string {
  if !p.IsSetTier() {
    return TaskConfig_Tier_DEFAULT
  }
return *p.Tier
}

func (p *TaskConfig) GetResources() []*Resource {
  return p.Resources
}

func (p *TaskConfig) GetConstraints() []*Constraint {
  return p.Constraints
}
var TaskConfig_MesosFetcherUris_DEFAULT []*MesosFetcherURI

func (p *TaskConfig) GetMesosFetcherUris() []*MesosFetcherURI {
  return p.MesosFetcherUris
}
var TaskConfig_TaskLinks_DEFAULT map[string]string

func (p *TaskConfig) GetTaskLinks() map[string]string {
  return p.TaskLinks
}
var TaskConfig_ContactEmail_DEFAULT string
func (p *TaskConfig) GetContactEmail() string {
  if !p.IsSetContactEmail() {
    return TaskConfig_ContactEmail_DEFAULT
  }
return *p.ContactEmail
}
var TaskConfig_ExecutorConfig_DEFAULT *ExecutorConfig
func (p *TaskConfig) GetExecutorConfig() *ExecutorConfig {
  if !p.IsSetExecutorConfig() {
    return TaskConfig_ExecutorConfig_DEFAULT
  }
return p.ExecutorConfig
}
var TaskConfig_Metadata_DEFAULT []*Metadata

func (p *TaskConfig) GetMetadata() []*Metadata {
  return p.Metadata
}
var TaskConfig_PartitionPolicy_DEFAULT *PartitionPolicy
func (p *TaskConfig) GetPartitionPolicy() *PartitionPolicy {
  if !p.IsSetPartitionPolicy() {
    return TaskConfig_PartitionPolicy_DEFAULT
  }
return p.PartitionPolicy
}
var TaskConfig_SlaPolicy_DEFAULT *SlaPolicy
func (p *TaskConfig) GetSlaPolicy() *SlaPolicy {
  if !p.IsSetSlaPolicy() {
    return TaskConfig_SlaPolicy_DEFAULT
  }
return p.SlaPolicy
}
var TaskConfig_Container_DEFAULT *Container = &Container{
  Mesos: &MesosContainer{},
}
func (p *TaskConfig) GetContainer() *Container {
  if !p.IsSetContainer() {
    return TaskConfig_Container_DEFAULT
  }
return p.Container
}
func (p *TaskConfig) IsSetJob() bool {
  return p.Job != nil
}

func (p *TaskConfig) IsSetOwner() bool {
  return p.Owner != nil
}

func (p *TaskConfig) IsSetProduction() bool {
  return p.Production != nil
}

func (p *TaskConfig) IsSetTier() bool {
  return p.Tier != nil
}

func (p *TaskConfig) IsSetMesosFetcherUris() bool {
  return p.MesosFetcherUris != nil
}

func (p *TaskConfig) IsSetTaskLinks() bool {
  return p.TaskLinks != nil
}

func (p *TaskConfig) IsSetContactEmail() bool {
  return p.ContactEmail != nil
}

func (p *TaskConfig) IsSetExecutorConfig() bool {
  return p.ExecutorConfig != nil
}

func (p *TaskConfig) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *TaskConfig) IsSetPartitionPolicy() bool {
  return p.PartitionPolicy != nil
}

func (p *TaskConfig) IsSetSlaPolicy() bool {
  return p.SlaPolicy != nil
}

func (p *TaskConfig) IsSetContainer() bool {
  return p.Container != nil
}

func (p *TaskConfig) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 28:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField28(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 18:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField18(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 30:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField30(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 32:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField32(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 20:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField20(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 33:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField33(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 22:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField22(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 23:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField23(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 25:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField25(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 27:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField27(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 34:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField34(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 35:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField35(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 29:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField29(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TaskConfig)  ReadField28(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *TaskConfig)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  p.Owner = &Identity{}
  if err := p.Owner.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Owner), err)
  }
  return nil
}

func (p *TaskConfig)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.IsService = v
}
  return nil
}

func (p *TaskConfig)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  p.Priority = v
}
  return nil
}

func (p *TaskConfig)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.MaxTaskFailures = v
}
  return nil
}

func (p *TaskConfig)  ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 18: ", err)
} else {
  p.Production = &v
}
  return nil
}

func (p *TaskConfig)  ReadField30(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 30: ", err)
} else {
  p.Tier = &v
}
  return nil
}

func (p *TaskConfig)  ReadField32(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Resource, 0, size)
  p.Resources =  tSet
  for i := 0; i < size; i ++ {
    _elem10 := &Resource{}
    if err := _elem10.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem10), err)
    }
    p.Resources = append(p.Resources, _elem10)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskConfig)  ReadField20(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Constraint, 0, size)
  p.Constraints =  tSet
  for i := 0; i < size; i ++ {
    _elem11 := &Constraint{}
    if err := _elem11.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem11), err)
    }
    p.Constraints = append(p.Constraints, _elem11)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskConfig)  ReadField33(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*MesosFetcherURI, 0, size)
  p.MesosFetcherUris =  tSet
  for i := 0; i < size; i ++ {
    _elem12 := &MesosFetcherURI{}
    if err := _elem12.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem12), err)
    }
    p.MesosFetcherUris = append(p.MesosFetcherUris, _elem12)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskConfig)  ReadField22(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.TaskLinks =  tMap
  for i := 0; i < size; i ++ {
var _key13 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key13 = v
}
var _val14 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val14 = v
}
    p.TaskLinks[_key13] = _val14
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TaskConfig)  ReadField23(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 23: ", err)
} else {
  p.ContactEmail = &v
}
  return nil
}

func (p *TaskConfig)  ReadField25(ctx context.Context, iprot thrift.TProtocol) error {
  p.ExecutorConfig = &ExecutorConfig{}
  if err := p.ExecutorConfig.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ExecutorConfig), err)
  }
  return nil
}

func (p *TaskConfig)  ReadField27(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Metadata, 0, size)
  p.Metadata =  tSet
  for i := 0; i < size; i ++ {
    _elem15 := &Metadata{}
    if err := _elem15.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem15), err)
    }
    p.Metadata = append(p.Metadata, _elem15)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskConfig)  ReadField34(ctx context.Context, iprot thrift.TProtocol) error {
  p.PartitionPolicy = &PartitionPolicy{}
  if err := p.PartitionPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PartitionPolicy), err)
  }
  return nil
}

func (p *TaskConfig)  ReadField35(ctx context.Context, iprot thrift.TProtocol) error {
  p.SlaPolicy = &SlaPolicy{}
  if err := p.SlaPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SlaPolicy), err)
  }
  return nil
}

func (p *TaskConfig)  ReadField29(ctx context.Context, iprot thrift.TProtocol) error {
  p.Container = &Container{}
  if err := p.Container.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Container), err)
  }
  return nil
}

func (p *TaskConfig) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TaskConfig"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
    if err := p.writeField18(ctx, oprot); err != nil { return err }
    if err := p.writeField20(ctx, oprot); err != nil { return err }
    if err := p.writeField22(ctx, oprot); err != nil { return err }
    if err := p.writeField23(ctx, oprot); err != nil { return err }
    if err := p.writeField25(ctx, oprot); err != nil { return err }
    if err := p.writeField27(ctx, oprot); err != nil { return err }
    if err := p.writeField28(ctx, oprot); err != nil { return err }
    if err := p.writeField29(ctx, oprot); err != nil { return err }
    if err := p.writeField30(ctx, oprot); err != nil { return err }
    if err := p.writeField32(ctx, oprot); err != nil { return err }
    if err := p.writeField33(ctx, oprot); err != nil { return err }
    if err := p.writeField34(ctx, oprot); err != nil { return err }
    if err := p.writeField35(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TaskConfig) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "isService", thrift.BOOL, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:isService: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.IsService)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.isService (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:isService: ", p), err) }
  return err
}

func (p *TaskConfig) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "priority", thrift.I32, 11); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:priority: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Priority)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.priority (11) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 11:priority: ", p), err) }
  return err
}

func (p *TaskConfig) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxTaskFailures", thrift.I32, 13); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:maxTaskFailures: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxTaskFailures)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxTaskFailures (13) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 13:maxTaskFailures: ", p), err) }
  return err
}

func (p *TaskConfig) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "owner", thrift.STRUCT, 17); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:owner: ", p), err) }
  if err := p.Owner.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Owner), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 17:owner: ", p), err) }
  return err
}

func (p *TaskConfig) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetProduction() {
    if err := oprot.WriteFieldBegin(ctx, "production", thrift.BOOL, 18); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:production: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.Production)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.production (18) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 18:production: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField20(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "constraints", thrift.SET, 20); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:constraints: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Constraints)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Constraints); i++ {
    for j := i+1; j<len(p.Constraints); j++ {
      if func(tgt, src *Constraint) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Constraints[i], p.Constraints[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Constraints))
      }
    }
  }
  for _, v := range p.Constraints {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 20:constraints: ", p), err) }
  return err
}

func (p *TaskConfig) writeField22(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTaskLinks() {
    if err := oprot.WriteFieldBegin(ctx, "taskLinks", thrift.MAP, 22); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 22:taskLinks: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.TaskLinks)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.TaskLinks {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 22:taskLinks: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField23(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetContactEmail() {
    if err := oprot.WriteFieldBegin(ctx, "contactEmail", thrift.STRING, 23); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 23:contactEmail: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.ContactEmail)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.contactEmail (23) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 23:contactEmail: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField25(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetExecutorConfig() {
    if err := oprot.WriteFieldBegin(ctx, "executorConfig", thrift.STRUCT, 25); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 25:executorConfig: ", p), err) }
    if err := p.ExecutorConfig.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ExecutorConfig), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 25:executorConfig: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField27(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMetadata() {
    if err := oprot.WriteFieldBegin(ctx, "metadata", thrift.SET, 27); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 27:metadata: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Metadata)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.Metadata); i++ {
      for j := i+1; j<len(p.Metadata); j++ {
        if func(tgt, src *Metadata) bool {
          if !tgt.Equals(src) { return false }
          return true
        }(p.Metadata[i], p.Metadata[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Metadata))
        }
      }
    }
    for _, v := range p.Metadata {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 27:metadata: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField28(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 28); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 28:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 28:job: ", p), err) }
  return err
}

func (p *TaskConfig) writeField29(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "container", thrift.STRUCT, 29); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 29:container: ", p), err) }
  if err := p.Container.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Container), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 29:container: ", p), err) }
  return err
}

func (p *TaskConfig) writeField30(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTier() {
    if err := oprot.WriteFieldBegin(ctx, "tier", thrift.STRING, 30); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 30:tier: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Tier)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.tier (30) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 30:tier: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField32(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resources", thrift.SET, 32); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 32:resources: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Resources)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Resources); i++ {
    for j := i+1; j<len(p.Resources); j++ {
      if func(tgt, src *Resource) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Resources[i], p.Resources[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Resources))
      }
    }
  }
  for _, v := range p.Resources {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 32:resources: ", p), err) }
  return err
}

func (p *TaskConfig) writeField33(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMesosFetcherUris() {
    if err := oprot.WriteFieldBegin(ctx, "mesosFetcherUris", thrift.SET, 33); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 33:mesosFetcherUris: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.MesosFetcherUris)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.MesosFetcherUris); i++ {
      for j := i+1; j<len(p.MesosFetcherUris); j++ {
        if func(tgt, src *MesosFetcherURI) bool {
          if !tgt.Equals(src) { return false }
          return true
        }(p.MesosFetcherUris[i], p.MesosFetcherUris[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.MesosFetcherUris))
        }
      }
    }
    for _, v := range p.MesosFetcherUris {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 33:mesosFetcherUris: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField34(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPartitionPolicy() {
    if err := oprot.WriteFieldBegin(ctx, "partitionPolicy", thrift.STRUCT, 34); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 34:partitionPolicy: ", p), err) }
    if err := p.PartitionPolicy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PartitionPolicy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 34:partitionPolicy: ", p), err) }
  }
  return err
}

func (p *TaskConfig) writeField35(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSlaPolicy() {
    if err := oprot.WriteFieldBegin(ctx, "slaPolicy", thrift.STRUCT, 35); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 35:slaPolicy: ", p), err) }
    if err := p.SlaPolicy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SlaPolicy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 35:slaPolicy: ", p), err) }
  }
  return err
}

func (p *TaskConfig) Equals(other *TaskConfig) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.IsService != other.IsService { return false }
  if p.Priority != other.Priority { return false }
  if p.MaxTaskFailures != other.MaxTaskFailures { return false }
  if !p.Owner.Equals(other.Owner) { return false }
  if p.Production != other.Production {
    if p.Production == nil || other.Production == nil {
      return false
    }
    if (*p.Production) != (*other.Production) { return false }
  }
  if len(p.Constraints) != len(other.Constraints) { return false }
  for i, _tgt := range p.Constraints {
    _src16 := other.Constraints[i]
    if !_tgt.Equals(_src16) { return false }
  }
  if len(p.TaskLinks) != len(other.TaskLinks) { return false }
  for k, _tgt := range p.TaskLinks {
    _src17 := other.TaskLinks[k]
    if _tgt != _src17 { return false }
  }
  if p.ContactEmail != other.ContactEmail {
    if p.ContactEmail == nil || other.ContactEmail == nil {
      return false
    }
    if (*p.ContactEmail) != (*other.ContactEmail) { return false }
  }
  if !p.ExecutorConfig.Equals(other.ExecutorConfig) { return false }
  if len(p.Metadata) != len(other.Metadata) { return false }
  for i, _tgt := range p.Metadata {
    _src18 := other.Metadata[i]
    if !_tgt.Equals(_src18) { return false }
  }
  if !p.Job.Equals(other.Job) { return false }
  if !p.Container.Equals(other.Container) { return false }
  if p.Tier != other.Tier {
    if p.Tier == nil || other.Tier == nil {
      return false
    }
    if (*p.Tier) != (*other.Tier) { return false }
  }
  if len(p.Resources) != len(other.Resources) { return false }
  for i, _tgt := range p.Resources {
    _src19 := other.Resources[i]
    if !_tgt.Equals(_src19) { return false }
  }
  if len(p.MesosFetcherUris) != len(other.MesosFetcherUris) { return false }
  for i, _tgt := range p.MesosFetcherUris {
    _src20 := other.MesosFetcherUris[i]
    if !_tgt.Equals(_src20) { return false }
  }
  if !p.PartitionPolicy.Equals(other.PartitionPolicy) { return false }
  if !p.SlaPolicy.Equals(other.SlaPolicy) { return false }
  return true
}

func (p *TaskConfig) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TaskConfig(%+v)", *p)
}

// Attributes:
//  - Resources: Aggregated resource values.
type ResourceAggregate struct {
  // unused fields # 1 to 3
  Resources []*Resource `thrift:"resources,4" db:"resources" json:"resources"`
}

func NewResourceAggregate() *ResourceAggregate {
  return &ResourceAggregate{}
}


func (p *ResourceAggregate) GetResources() []*Resource {
  return p.Resources
}
func (p *ResourceAggregate) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 4:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ResourceAggregate)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Resource, 0, size)
  p.Resources =  tSet
  for i := 0; i < size; i ++ {
    _elem21 := &Resource{}
    if err := _elem21.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem21), err)
    }
    p.Resources = append(p.Resources, _elem21)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *ResourceAggregate) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ResourceAggregate"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ResourceAggregate) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "resources", thrift.SET, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:resources: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Resources)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Resources); i++ {
    for j := i+1; j<len(p.Resources); j++ {
      if func(tgt, src *Resource) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Resources[i], p.Resources[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Resources))
      }
    }
  }
  for _, v := range p.Resources {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:resources: ", p), err) }
  return err
}

func (p *ResourceAggregate) Equals(other *ResourceAggregate) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Resources) != len(other.Resources) { return false }
  for i, _tgt := range p.Resources {
    _src22 := other.Resources[i]
    if !_tgt.Equals(_src22) { return false }
  }
  return true
}

func (p *ResourceAggregate) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ResourceAggregate(%+v)", *p)
}

// Description of an Aurora job. One task will be scheduled for each instance within the job.
// 
// Attributes:
//  - Key: Key for this job. If not specified name, owner.role, and a reasonable default environment are
// used to construct it server-side.
//  - Owner: Owner of this job.
//  - CronSchedule: If present, the job will be handled as a cron job with this crontab-syntax schedule.
//  - CronCollisionPolicy: Collision policy to use when handling overlapping cron runs.  Default is KILL_EXISTING.
//  - TaskConfig: Task configuration for this job.
//  - InstanceCount: The number of instances in the job. Generated instance IDs for tasks will be in the range
// [0, instances).
type JobConfiguration struct {
  // unused fields # 1 to 3
  CronSchedule *string `thrift:"cronSchedule,4" db:"cronSchedule" json:"cronSchedule,omitempty"`
  CronCollisionPolicy CronCollisionPolicy `thrift:"cronCollisionPolicy,5" db:"cronCollisionPolicy" json:"cronCollisionPolicy"`
  TaskConfig *TaskConfig `thrift:"taskConfig,6" db:"taskConfig" json:"taskConfig"`
  Owner *Identity `thrift:"owner,7" db:"owner" json:"owner"`
  InstanceCount int32 `thrift:"instanceCount,8" db:"instanceCount" json:"instanceCount"`
  Key *JobKey `thrift:"key,9" db:"key" json:"key"`
}

func NewJobConfiguration() *JobConfiguration {
  return &JobConfiguration{}
}

var JobConfiguration_Key_DEFAULT *JobKey
func (p *JobConfiguration) GetKey() *JobKey {
  if !p.IsSetKey() {
    return JobConfiguration_Key_DEFAULT
  }
return p.Key
}
var JobConfiguration_Owner_DEFAULT *Identity
func (p *JobConfiguration) GetOwner() *Identity {
  if !p.IsSetOwner() {
    return JobConfiguration_Owner_DEFAULT
  }
return p.Owner
}
var JobConfiguration_CronSchedule_DEFAULT string
func (p *JobConfiguration) GetCronSchedule() string {
  if !p.IsSetCronSchedule() {
    return JobConfiguration_CronSchedule_DEFAULT
  }
return *p.CronSchedule
}

func (p *JobConfiguration) GetCronCollisionPolicy() CronCollisionPolicy {
  return p.CronCollisionPolicy
}
var JobConfiguration_TaskConfig_DEFAULT *TaskConfig
func (p *JobConfiguration) GetTaskConfig() *TaskConfig {
  if !p.IsSetTaskConfig() {
    return JobConfiguration_TaskConfig_DEFAULT
  }
return p.TaskConfig
}

func (p *JobConfiguration) GetInstanceCount() int32 {
  return p.InstanceCount
}
func (p *JobConfiguration) IsSetKey() bool {
  return p.Key != nil
}

func (p *JobConfiguration) IsSetOwner() bool {
  return p.Owner != nil
}

func (p *JobConfiguration) IsSetCronSchedule() bool {
  return p.CronSchedule != nil
}

func (p *JobConfiguration) IsSetTaskConfig() bool {
  return p.TaskConfig != nil
}

func (p *JobConfiguration) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 9:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobConfiguration)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *JobConfiguration)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.Owner = &Identity{}
  if err := p.Owner.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Owner), err)
  }
  return nil
}

func (p *JobConfiguration)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.CronSchedule = &v
}
  return nil
}

func (p *JobConfiguration)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := CronCollisionPolicy(v)
  p.CronCollisionPolicy = temp
}
  return nil
}

func (p *JobConfiguration)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.TaskConfig = &TaskConfig{}
  if err := p.TaskConfig.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TaskConfig), err)
  }
  return nil
}

func (p *JobConfiguration)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.InstanceCount = v
}
  return nil
}

func (p *JobConfiguration) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobConfiguration"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobConfiguration) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCronSchedule() {
    if err := oprot.WriteFieldBegin(ctx, "cronSchedule", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:cronSchedule: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.CronSchedule)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cronSchedule (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:cronSchedule: ", p), err) }
  }
  return err
}

func (p *JobConfiguration) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cronCollisionPolicy", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:cronCollisionPolicy: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.CronCollisionPolicy)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cronCollisionPolicy (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:cronCollisionPolicy: ", p), err) }
  return err
}

func (p *JobConfiguration) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskConfig", thrift.STRUCT, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:taskConfig: ", p), err) }
  if err := p.TaskConfig.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TaskConfig), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:taskConfig: ", p), err) }
  return err
}

func (p *JobConfiguration) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "owner", thrift.STRUCT, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:owner: ", p), err) }
  if err := p.Owner.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Owner), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:owner: ", p), err) }
  return err
}

func (p *JobConfiguration) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instanceCount", thrift.I32, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:instanceCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.InstanceCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.instanceCount (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:instanceCount: ", p), err) }
  return err
}

func (p *JobConfiguration) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 9); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 9:key: ", p), err) }
  return err
}

func (p *JobConfiguration) Equals(other *JobConfiguration) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.CronSchedule != other.CronSchedule {
    if p.CronSchedule == nil || other.CronSchedule == nil {
      return false
    }
    if (*p.CronSchedule) != (*other.CronSchedule) { return false }
  }
  if p.CronCollisionPolicy != other.CronCollisionPolicy { return false }
  if !p.TaskConfig.Equals(other.TaskConfig) { return false }
  if !p.Owner.Equals(other.Owner) { return false }
  if p.InstanceCount != other.InstanceCount { return false }
  if !p.Key.Equals(other.Key) { return false }
  return true
}

func (p *JobConfiguration) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobConfiguration(%+v)", *p)
}

// Attributes:
//  - ActiveTaskCount: Number of tasks in active state for this job.
//  - FinishedTaskCount: Number of tasks in finished state for this job.
//  - FailedTaskCount: Number of failed tasks for this job.
//  - PendingTaskCount: Number of tasks in pending state for this job.
type JobStats struct {
  ActiveTaskCount int32 `thrift:"activeTaskCount,1" db:"activeTaskCount" json:"activeTaskCount"`
  FinishedTaskCount int32 `thrift:"finishedTaskCount,2" db:"finishedTaskCount" json:"finishedTaskCount"`
  FailedTaskCount int32 `thrift:"failedTaskCount,3" db:"failedTaskCount" json:"failedTaskCount"`
  PendingTaskCount int32 `thrift:"pendingTaskCount,4" db:"pendingTaskCount" json:"pendingTaskCount"`
}

func NewJobStats() *JobStats {
  return &JobStats{}
}


func (p *JobStats) GetActiveTaskCount() int32 {
  return p.ActiveTaskCount
}

func (p *JobStats) GetFinishedTaskCount() int32 {
  return p.FinishedTaskCount
}

func (p *JobStats) GetFailedTaskCount() int32 {
  return p.FailedTaskCount
}

func (p *JobStats) GetPendingTaskCount() int32 {
  return p.PendingTaskCount
}
func (p *JobStats) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobStats)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ActiveTaskCount = v
}
  return nil
}

func (p *JobStats)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.FinishedTaskCount = v
}
  return nil
}

func (p *JobStats)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.FailedTaskCount = v
}
  return nil
}

func (p *JobStats)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.PendingTaskCount = v
}
  return nil
}

func (p *JobStats) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobStats"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobStats) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "activeTaskCount", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:activeTaskCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ActiveTaskCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.activeTaskCount (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:activeTaskCount: ", p), err) }
  return err
}

func (p *JobStats) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "finishedTaskCount", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:finishedTaskCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.FinishedTaskCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.finishedTaskCount (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:finishedTaskCount: ", p), err) }
  return err
}

func (p *JobStats) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "failedTaskCount", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:failedTaskCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.FailedTaskCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.failedTaskCount (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:failedTaskCount: ", p), err) }
  return err
}

func (p *JobStats) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "pendingTaskCount", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:pendingTaskCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.PendingTaskCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.pendingTaskCount (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:pendingTaskCount: ", p), err) }
  return err
}

func (p *JobStats) Equals(other *JobStats) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ActiveTaskCount != other.ActiveTaskCount { return false }
  if p.FinishedTaskCount != other.FinishedTaskCount { return false }
  if p.FailedTaskCount != other.FailedTaskCount { return false }
  if p.PendingTaskCount != other.PendingTaskCount { return false }
  return true
}

func (p *JobStats) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobStats(%+v)", *p)
}

// Attributes:
//  - Job
//  - Stats
//  - NextCronRunMs: Timestamp of next cron run in ms since epoch, for a cron job
type JobSummary struct {
  Job *JobConfiguration `thrift:"job,1" db:"job" json:"job"`
  Stats *JobStats `thrift:"stats,2" db:"stats" json:"stats"`
  NextCronRunMs *int64 `thrift:"nextCronRunMs,3" db:"nextCronRunMs" json:"nextCronRunMs,omitempty"`
}

func NewJobSummary() *JobSummary {
  return &JobSummary{}
}

var JobSummary_Job_DEFAULT *JobConfiguration
func (p *JobSummary) GetJob() *JobConfiguration {
  if !p.IsSetJob() {
    return JobSummary_Job_DEFAULT
  }
return p.Job
}
var JobSummary_Stats_DEFAULT *JobStats
func (p *JobSummary) GetStats() *JobStats {
  if !p.IsSetStats() {
    return JobSummary_Stats_DEFAULT
  }
return p.Stats
}
var JobSummary_NextCronRunMs_DEFAULT int64
func (p *JobSummary) GetNextCronRunMs() int64 {
  if !p.IsSetNextCronRunMs() {
    return JobSummary_NextCronRunMs_DEFAULT
  }
return *p.NextCronRunMs
}
func (p *JobSummary) IsSetJob() bool {
  return p.Job != nil
}

func (p *JobSummary) IsSetStats() bool {
  return p.Stats != nil
}

func (p *JobSummary) IsSetNextCronRunMs() bool {
  return p.NextCronRunMs != nil
}

func (p *JobSummary) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobSummary)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobConfiguration{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *JobSummary)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Stats = &JobStats{}
  if err := p.Stats.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Stats), err)
  }
  return nil
}

func (p *JobSummary)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.NextCronRunMs = &v
}
  return nil
}

func (p *JobSummary) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobSummary"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobSummary) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:job: ", p), err) }
  return err
}

func (p *JobSummary) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "stats", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:stats: ", p), err) }
  if err := p.Stats.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Stats), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:stats: ", p), err) }
  return err
}

func (p *JobSummary) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNextCronRunMs() {
    if err := oprot.WriteFieldBegin(ctx, "nextCronRunMs", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nextCronRunMs: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.NextCronRunMs)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.nextCronRunMs (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nextCronRunMs: ", p), err) }
  }
  return err
}

func (p *JobSummary) Equals(other *JobSummary) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Job.Equals(other.Job) { return false }
  if !p.Stats.Equals(other.Stats) { return false }
  if p.NextCronRunMs != other.NextCronRunMs {
    if p.NextCronRunMs == nil || other.NextCronRunMs == nil {
      return false
    }
    if (*p.NextCronRunMs) != (*other.NextCronRunMs) { return false }
  }
  return true
}

func (p *JobSummary) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobSummary(%+v)", *p)
}

// Closed range of integers.
// 
// Attributes:
//  - First
//  - Last
type Range struct {
  First int32 `thrift:"first,1" db:"first" json:"first"`
  Last int32 `thrift:"last,2" db:"last" json:"last"`
}

func NewRange() *Range {
  return &Range{}
}


func (p *Range) GetFirst() int32 {
  return p.First
}

func (p *Range) GetLast() int32 {
  return p.Last
}
func (p *Range) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Range)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.First = v
}
  return nil
}

func (p *Range)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Last = v
}
  return nil
}

func (p *Range) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Range"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Range) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "first", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:first: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.First)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.first (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:first: ", p), err) }
  return err
}

func (p *Range) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "last", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:last: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Last)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.last (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:last: ", p), err) }
  return err
}

func (p *Range) Equals(other *Range) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.First != other.First { return false }
  if p.Last != other.Last { return false }
  return true
}

func (p *Range) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Range(%+v)", *p)
}

// Attributes:
//  - Config
//  - Instances
type ConfigGroup struct {
  Config *TaskConfig `thrift:"config,1" db:"config" json:"config"`
  // unused field # 2
  Instances []*Range `thrift:"instances,3" db:"instances" json:"instances"`
}

func NewConfigGroup() *ConfigGroup {
  return &ConfigGroup{}
}

var ConfigGroup_Config_DEFAULT *TaskConfig
func (p *ConfigGroup) GetConfig() *TaskConfig {
  if !p.IsSetConfig() {
    return ConfigGroup_Config_DEFAULT
  }
return p.Config
}

func (p *ConfigGroup) GetInstances() []*Range {
  return p.Instances
}
func (p *ConfigGroup) IsSetConfig() bool {
  return p.Config != nil
}

func (p *ConfigGroup) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ConfigGroup)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Config = &TaskConfig{}
  if err := p.Config.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Config), err)
  }
  return nil
}

func (p *ConfigGroup)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Range, 0, size)
  p.Instances =  tSet
  for i := 0; i < size; i ++ {
    _elem23 := &Range{}
    if err := _elem23.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem23), err)
    }
    p.Instances = append(p.Instances, _elem23)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *ConfigGroup) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ConfigGroup"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ConfigGroup) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "config", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:config: ", p), err) }
  if err := p.Config.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Config), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:config: ", p), err) }
  return err
}

func (p *ConfigGroup) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instances", thrift.SET, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:instances: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Instances)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Instances); i++ {
    for j := i+1; j<len(p.Instances); j++ {
      if func(tgt, src *Range) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Instances[i], p.Instances[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Instances))
      }
    }
  }
  for _, v := range p.Instances {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:instances: ", p), err) }
  return err
}

func (p *ConfigGroup) Equals(other *ConfigGroup) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Config.Equals(other.Config) { return false }
  if len(p.Instances) != len(other.Instances) { return false }
  for i, _tgt := range p.Instances {
    _src24 := other.Instances[i]
    if !_tgt.Equals(_src24) { return false }
  }
  return true
}

func (p *ConfigGroup) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ConfigGroup(%+v)", *p)
}

// Attributes:
//  - Key
//  - Groups
type ConfigSummary struct {
  Key *JobKey `thrift:"key,1" db:"key" json:"key"`
  Groups []*ConfigGroup `thrift:"groups,2" db:"groups" json:"groups"`
}

func NewConfigSummary() *ConfigSummary {
  return &ConfigSummary{}
}

var ConfigSummary_Key_DEFAULT *JobKey
func (p *ConfigSummary) GetKey() *JobKey {
  if !p.IsSetKey() {
    return ConfigSummary_Key_DEFAULT
  }
return p.Key
}

func (p *ConfigSummary) GetGroups() []*ConfigGroup {
  return p.Groups
}
func (p *ConfigSummary) IsSetKey() bool {
  return p.Key != nil
}

func (p *ConfigSummary) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ConfigSummary)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *ConfigSummary)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*ConfigGroup, 0, size)
  p.Groups =  tSet
  for i := 0; i < size; i ++ {
    _elem25 := &ConfigGroup{}
    if err := _elem25.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem25), err)
    }
    p.Groups = append(p.Groups, _elem25)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *ConfigSummary) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ConfigSummary"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ConfigSummary) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *ConfigSummary) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "groups", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:groups: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Groups)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Groups); i++ {
    for j := i+1; j<len(p.Groups); j++ {
      if func(tgt, src *ConfigGroup) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Groups[i], p.Groups[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Groups))
      }
    }
  }
  for _, v := range p.Groups {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:groups: ", p), err) }
  return err
}

func (p *ConfigSummary) Equals(other *ConfigSummary) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Key.Equals(other.Key) { return false }
  if len(p.Groups) != len(other.Groups) { return false }
  for i, _tgt := range p.Groups {
    _src26 := other.Groups[i]
    if !_tgt.Equals(_src26) { return false }
  }
  return true
}

func (p *ConfigSummary) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ConfigSummary(%+v)", *p)
}

// Attributes:
//  - TaskConfig
type PopulateJobResult_ struct {
  // unused field # 1
  TaskConfig *TaskConfig `thrift:"taskConfig,2" db:"taskConfig" json:"taskConfig"`
}

func NewPopulateJobResult_() *PopulateJobResult_ {
  return &PopulateJobResult_{}
}

var PopulateJobResult__TaskConfig_DEFAULT *TaskConfig
func (p *PopulateJobResult_) GetTaskConfig() *TaskConfig {
  if !p.IsSetTaskConfig() {
    return PopulateJobResult__TaskConfig_DEFAULT
  }
return p.TaskConfig
}
func (p *PopulateJobResult_) IsSetTaskConfig() bool {
  return p.TaskConfig != nil
}

func (p *PopulateJobResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PopulateJobResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.TaskConfig = &TaskConfig{}
  if err := p.TaskConfig.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TaskConfig), err)
  }
  return nil
}

func (p *PopulateJobResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PopulateJobResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PopulateJobResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskConfig", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:taskConfig: ", p), err) }
  if err := p.TaskConfig.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TaskConfig), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:taskConfig: ", p), err) }
  return err
}

func (p *PopulateJobResult_) Equals(other *PopulateJobResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.TaskConfig.Equals(other.TaskConfig) { return false }
  return true
}

func (p *PopulateJobResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PopulateJobResult_(%+v)", *p)
}

// Attributes:
//  - Quota: Total allocated resource quota.
//  - ProdSharedConsumption: Resources consumed by production jobs from a shared resource pool.
//  - NonProdSharedConsumption: Resources consumed by non-production jobs from a shared resource pool.
//  - ProdDedicatedConsumption: Resources consumed by production jobs from a dedicated resource pool.
//  - NonProdDedicatedConsumption: Resources consumed by non-production jobs from a dedicated resource pool.
type GetQuotaResult_ struct {
  Quota *ResourceAggregate `thrift:"quota,1" db:"quota" json:"quota"`
  ProdSharedConsumption *ResourceAggregate `thrift:"prodSharedConsumption,2" db:"prodSharedConsumption" json:"prodSharedConsumption,omitempty"`
  NonProdSharedConsumption *ResourceAggregate `thrift:"nonProdSharedConsumption,3" db:"nonProdSharedConsumption" json:"nonProdSharedConsumption,omitempty"`
  ProdDedicatedConsumption *ResourceAggregate `thrift:"prodDedicatedConsumption,4" db:"prodDedicatedConsumption" json:"prodDedicatedConsumption,omitempty"`
  NonProdDedicatedConsumption *ResourceAggregate `thrift:"nonProdDedicatedConsumption,5" db:"nonProdDedicatedConsumption" json:"nonProdDedicatedConsumption,omitempty"`
}

func NewGetQuotaResult_() *GetQuotaResult_ {
  return &GetQuotaResult_{}
}

var GetQuotaResult__Quota_DEFAULT *ResourceAggregate
func (p *GetQuotaResult_) GetQuota() *ResourceAggregate {
  if !p.IsSetQuota() {
    return GetQuotaResult__Quota_DEFAULT
  }
return p.Quota
}
var GetQuotaResult__ProdSharedConsumption_DEFAULT *ResourceAggregate
func (p *GetQuotaResult_) GetProdSharedConsumption() *ResourceAggregate {
  if !p.IsSetProdSharedConsumption() {
    return GetQuotaResult__ProdSharedConsumption_DEFAULT
  }
return p.ProdSharedConsumption
}
var GetQuotaResult__NonProdSharedConsumption_DEFAULT *ResourceAggregate
func (p *GetQuotaResult_) GetNonProdSharedConsumption() *ResourceAggregate {
  if !p.IsSetNonProdSharedConsumption() {
    return GetQuotaResult__NonProdSharedConsumption_DEFAULT
  }
return p.NonProdSharedConsumption
}
var GetQuotaResult__ProdDedicatedConsumption_DEFAULT *ResourceAggregate
func (p *GetQuotaResult_) GetProdDedicatedConsumption() *ResourceAggregate {
  if !p.IsSetProdDedicatedConsumption() {
    return GetQuotaResult__ProdDedicatedConsumption_DEFAULT
  }
return p.ProdDedicatedConsumption
}
var GetQuotaResult__NonProdDedicatedConsumption_DEFAULT *ResourceAggregate
func (p *GetQuotaResult_) GetNonProdDedicatedConsumption() *ResourceAggregate {
  if !p.IsSetNonProdDedicatedConsumption() {
    return GetQuotaResult__NonProdDedicatedConsumption_DEFAULT
  }
return p.NonProdDedicatedConsumption
}
func (p *GetQuotaResult_) IsSetQuota() bool {
  return p.Quota != nil
}

func (p *GetQuotaResult_) IsSetProdSharedConsumption() bool {
  return p.ProdSharedConsumption != nil
}

func (p *GetQuotaResult_) IsSetNonProdSharedConsumption() bool {
  return p.NonProdSharedConsumption != nil
}

func (p *GetQuotaResult_) IsSetProdDedicatedConsumption() bool {
  return p.ProdDedicatedConsumption != nil
}

func (p *GetQuotaResult_) IsSetNonProdDedicatedConsumption() bool {
  return p.NonProdDedicatedConsumption != nil
}

func (p *GetQuotaResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetQuotaResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Quota = &ResourceAggregate{}
  if err := p.Quota.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Quota), err)
  }
  return nil
}

func (p *GetQuotaResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.ProdSharedConsumption = &ResourceAggregate{}
  if err := p.ProdSharedConsumption.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ProdSharedConsumption), err)
  }
  return nil
}

func (p *GetQuotaResult_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.NonProdSharedConsumption = &ResourceAggregate{}
  if err := p.NonProdSharedConsumption.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NonProdSharedConsumption), err)
  }
  return nil
}

func (p *GetQuotaResult_)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.ProdDedicatedConsumption = &ResourceAggregate{}
  if err := p.ProdDedicatedConsumption.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ProdDedicatedConsumption), err)
  }
  return nil
}

func (p *GetQuotaResult_)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.NonProdDedicatedConsumption = &ResourceAggregate{}
  if err := p.NonProdDedicatedConsumption.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NonProdDedicatedConsumption), err)
  }
  return nil
}

func (p *GetQuotaResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetQuotaResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetQuotaResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "quota", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:quota: ", p), err) }
  if err := p.Quota.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Quota), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:quota: ", p), err) }
  return err
}

func (p *GetQuotaResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetProdSharedConsumption() {
    if err := oprot.WriteFieldBegin(ctx, "prodSharedConsumption", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:prodSharedConsumption: ", p), err) }
    if err := p.ProdSharedConsumption.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ProdSharedConsumption), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:prodSharedConsumption: ", p), err) }
  }
  return err
}

func (p *GetQuotaResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNonProdSharedConsumption() {
    if err := oprot.WriteFieldBegin(ctx, "nonProdSharedConsumption", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nonProdSharedConsumption: ", p), err) }
    if err := p.NonProdSharedConsumption.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NonProdSharedConsumption), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nonProdSharedConsumption: ", p), err) }
  }
  return err
}

func (p *GetQuotaResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetProdDedicatedConsumption() {
    if err := oprot.WriteFieldBegin(ctx, "prodDedicatedConsumption", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:prodDedicatedConsumption: ", p), err) }
    if err := p.ProdDedicatedConsumption.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ProdDedicatedConsumption), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:prodDedicatedConsumption: ", p), err) }
  }
  return err
}

func (p *GetQuotaResult_) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetNonProdDedicatedConsumption() {
    if err := oprot.WriteFieldBegin(ctx, "nonProdDedicatedConsumption", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:nonProdDedicatedConsumption: ", p), err) }
    if err := p.NonProdDedicatedConsumption.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NonProdDedicatedConsumption), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:nonProdDedicatedConsumption: ", p), err) }
  }
  return err
}

func (p *GetQuotaResult_) Equals(other *GetQuotaResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Quota.Equals(other.Quota) { return false }
  if !p.ProdSharedConsumption.Equals(other.ProdSharedConsumption) { return false }
  if !p.NonProdSharedConsumption.Equals(other.NonProdSharedConsumption) { return false }
  if !p.ProdDedicatedConsumption.Equals(other.ProdDedicatedConsumption) { return false }
  if !p.NonProdDedicatedConsumption.Equals(other.NonProdDedicatedConsumption) { return false }
  return true
}

func (p *GetQuotaResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetQuotaResult_(%+v)", *p)
}

// Event marking a state transition within a task's lifecycle.
// 
// Attributes:
//  - Timestamp: Epoch timestamp in milliseconds.
//  - Status: New status of the task.
//  - Message: Audit message that explains why a transition occurred.
//  - Scheduler: Hostname of the scheduler machine that performed the event.
type TaskEvent struct {
  Timestamp int64 `thrift:"timestamp,1" db:"timestamp" json:"timestamp"`
  Status ScheduleStatus `thrift:"status,2" db:"status" json:"status"`
  Message *string `thrift:"message,3" db:"message" json:"message,omitempty"`
  Scheduler *string `thrift:"scheduler,4" db:"scheduler" json:"scheduler,omitempty"`
}

func NewTaskEvent() *TaskEvent {
  return &TaskEvent{}
}


func (p *TaskEvent) GetTimestamp() int64 {
  return p.Timestamp
}

func (p *TaskEvent) GetStatus() ScheduleStatus {
  return p.Status
}
var TaskEvent_Message_DEFAULT string
func (p *TaskEvent) GetMessage() string {
  if !p.IsSetMessage() {
    return TaskEvent_Message_DEFAULT
  }
return *p.Message
}
var TaskEvent_Scheduler_DEFAULT string
func (p *TaskEvent) GetScheduler() string {
  if !p.IsSetScheduler() {
    return TaskEvent_Scheduler_DEFAULT
  }
return *p.Scheduler
}
func (p *TaskEvent) IsSetMessage() bool {
  return p.Message != nil
}

func (p *TaskEvent) IsSetScheduler() bool {
  return p.Scheduler != nil
}

func (p *TaskEvent) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TaskEvent)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Timestamp = v
}
  return nil
}

func (p *TaskEvent)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := ScheduleStatus(v)
  p.Status = temp
}
  return nil
}

func (p *TaskEvent)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *TaskEvent)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Scheduler = &v
}
  return nil
}

func (p *TaskEvent) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TaskEvent"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TaskEvent) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:timestamp: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Timestamp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timestamp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:timestamp: ", p), err) }
  return err
}

func (p *TaskEvent) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.status (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:status: ", p), err) }
  return err
}

func (p *TaskEvent) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err) }
  }
  return err
}

func (p *TaskEvent) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetScheduler() {
    if err := oprot.WriteFieldBegin(ctx, "scheduler", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:scheduler: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Scheduler)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.scheduler (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:scheduler: ", p), err) }
  }
  return err
}

func (p *TaskEvent) Equals(other *TaskEvent) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Timestamp != other.Timestamp { return false }
  if p.Status != other.Status { return false }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  if p.Scheduler != other.Scheduler {
    if p.Scheduler == nil || other.Scheduler == nil {
      return false
    }
    if (*p.Scheduler) != (*other.Scheduler) { return false }
  }
  return true
}

func (p *TaskEvent) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TaskEvent(%+v)", *p)
}

// A task assignment that is provided to an executor.
// 
// Attributes:
//  - TaskId: The mesos task ID for this task.  Guaranteed to be globally unique
//  - SlaveId: The mesos slave ID that this task has been assigned to.
// This will not be populated for a PENDING task.
//  - SlaveHost: The name of the machine that this task has been assigned to.
// This will not be populated for a PENDING task.
//  - Task: Information about how to run this task.
//  - AssignedPorts: Ports reserved on the machine while this task is running.
//  - InstanceId: The instance ID assigned to this task. Instance IDs must be unique and contiguous within a
// job, and will be in the range [0, N-1] (inclusive) for a job that has N instances.
type AssignedTask struct {
  TaskId string `thrift:"taskId,1" db:"taskId" json:"taskId"`
  SlaveId string `thrift:"slaveId,2" db:"slaveId" json:"slaveId"`
  SlaveHost string `thrift:"slaveHost,3" db:"slaveHost" json:"slaveHost"`
  Task *TaskConfig `thrift:"task,4" db:"task" json:"task"`
  AssignedPorts map[string]int32 `thrift:"assignedPorts,5" db:"assignedPorts" json:"assignedPorts"`
  InstanceId int32 `thrift:"instanceId,6" db:"instanceId" json:"instanceId"`
}

func NewAssignedTask() *AssignedTask {
  return &AssignedTask{}
}


func (p *AssignedTask) GetTaskId() string {
  return p.TaskId
}

func (p *AssignedTask) GetSlaveId() string {
  return p.SlaveId
}

func (p *AssignedTask) GetSlaveHost() string {
  return p.SlaveHost
}
var AssignedTask_Task_DEFAULT *TaskConfig
func (p *AssignedTask) GetTask() *TaskConfig {
  if !p.IsSetTask() {
    return AssignedTask_Task_DEFAULT
  }
return p.Task
}

func (p *AssignedTask) GetAssignedPorts() map[string]int32 {
  return p.AssignedPorts
}

func (p *AssignedTask) GetInstanceId() int32 {
  return p.InstanceId
}
func (p *AssignedTask) IsSetTask() bool {
  return p.Task != nil
}

func (p *AssignedTask) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AssignedTask)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TaskId = v
}
  return nil
}

func (p *AssignedTask)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.SlaveId = v
}
  return nil
}

func (p *AssignedTask)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.SlaveHost = v
}
  return nil
}

func (p *AssignedTask)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Task = &TaskConfig{}
  if err := p.Task.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Task), err)
  }
  return nil
}

func (p *AssignedTask)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]int32, size)
  p.AssignedPorts =  tMap
  for i := 0; i < size; i ++ {
var _key27 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key27 = v
}
var _val28 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val28 = v
}
    p.AssignedPorts[_key27] = _val28
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *AssignedTask)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.InstanceId = v
}
  return nil
}

func (p *AssignedTask) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "AssignedTask"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AssignedTask) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:taskId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.TaskId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.taskId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:taskId: ", p), err) }
  return err
}

func (p *AssignedTask) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "slaveId", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:slaveId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.SlaveId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.slaveId (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:slaveId: ", p), err) }
  return err
}

func (p *AssignedTask) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "slaveHost", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:slaveHost: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.SlaveHost)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.slaveHost (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:slaveHost: ", p), err) }
  return err
}

func (p *AssignedTask) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "task", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:task: ", p), err) }
  if err := p.Task.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Task), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:task: ", p), err) }
  return err
}

func (p *AssignedTask) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "assignedPorts", thrift.MAP, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:assignedPorts: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.I32, len(p.AssignedPorts)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.AssignedPorts {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:assignedPorts: ", p), err) }
  return err
}

func (p *AssignedTask) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instanceId", thrift.I32, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:instanceId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.InstanceId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.instanceId (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:instanceId: ", p), err) }
  return err
}

func (p *AssignedTask) Equals(other *AssignedTask) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.TaskId != other.TaskId { return false }
  if p.SlaveId != other.SlaveId { return false }
  if p.SlaveHost != other.SlaveHost { return false }
  if !p.Task.Equals(other.Task) { return false }
  if len(p.AssignedPorts) != len(other.AssignedPorts) { return false }
  for k, _tgt := range p.AssignedPorts {
    _src29 := other.AssignedPorts[k]
    if _tgt != _src29 { return false }
  }
  if p.InstanceId != other.InstanceId { return false }
  return true
}

func (p *AssignedTask) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AssignedTask(%+v)", *p)
}

// A task that has been scheduled.
// 
// Attributes:
//  - AssignedTask: The task that was scheduled.
//  - Status: The current status of this task.
//  - FailureCount: The number of failures that this task has accumulated over the multi-generational history of
// this task.
//  - TimesPartitioned: The number of partitions this task has accumulated over its lifetime.
//  - TaskEvents: State change history for this task.
//  - AncestorId: The task ID of the previous generation of this task.  When a task is automatically rescheduled,
// a copy of the task is created and ancestor ID of the previous task's task ID.
type ScheduledTask struct {
  AssignedTask *AssignedTask `thrift:"assignedTask,1" db:"assignedTask" json:"assignedTask"`
  Status ScheduleStatus `thrift:"status,2" db:"status" json:"status"`
  FailureCount int32 `thrift:"failureCount,3" db:"failureCount" json:"failureCount"`
  TaskEvents []*TaskEvent `thrift:"taskEvents,4" db:"taskEvents" json:"taskEvents"`
  AncestorId string `thrift:"ancestorId,5" db:"ancestorId" json:"ancestorId"`
  TimesPartitioned int32 `thrift:"timesPartitioned,6" db:"timesPartitioned" json:"timesPartitioned"`
}

func NewScheduledTask() *ScheduledTask {
  return &ScheduledTask{}
}

var ScheduledTask_AssignedTask_DEFAULT *AssignedTask
func (p *ScheduledTask) GetAssignedTask() *AssignedTask {
  if !p.IsSetAssignedTask() {
    return ScheduledTask_AssignedTask_DEFAULT
  }
return p.AssignedTask
}

func (p *ScheduledTask) GetStatus() ScheduleStatus {
  return p.Status
}

func (p *ScheduledTask) GetFailureCount() int32 {
  return p.FailureCount
}

func (p *ScheduledTask) GetTimesPartitioned() int32 {
  return p.TimesPartitioned
}

func (p *ScheduledTask) GetTaskEvents() []*TaskEvent {
  return p.TaskEvents
}

func (p *ScheduledTask) GetAncestorId() string {
  return p.AncestorId
}
func (p *ScheduledTask) IsSetAssignedTask() bool {
  return p.AssignedTask != nil
}

func (p *ScheduledTask) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ScheduledTask)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.AssignedTask = &AssignedTask{}
  if err := p.AssignedTask.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AssignedTask), err)
  }
  return nil
}

func (p *ScheduledTask)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := ScheduleStatus(v)
  p.Status = temp
}
  return nil
}

func (p *ScheduledTask)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.FailureCount = v
}
  return nil
}

func (p *ScheduledTask)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.TimesPartitioned = v
}
  return nil
}

func (p *ScheduledTask)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*TaskEvent, 0, size)
  p.TaskEvents =  tSlice
  for i := 0; i < size; i ++ {
    _elem30 := &TaskEvent{}
    if err := _elem30.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
    }
    p.TaskEvents = append(p.TaskEvents, _elem30)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ScheduledTask)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.AncestorId = v
}
  return nil
}

func (p *ScheduledTask) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ScheduledTask"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ScheduledTask) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "assignedTask", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:assignedTask: ", p), err) }
  if err := p.AssignedTask.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AssignedTask), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:assignedTask: ", p), err) }
  return err
}

func (p *ScheduledTask) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.status (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:status: ", p), err) }
  return err
}

func (p *ScheduledTask) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "failureCount", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:failureCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.FailureCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.failureCount (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:failureCount: ", p), err) }
  return err
}

func (p *ScheduledTask) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskEvents", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:taskEvents: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.TaskEvents)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.TaskEvents {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:taskEvents: ", p), err) }
  return err
}

func (p *ScheduledTask) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ancestorId", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:ancestorId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.AncestorId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ancestorId (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:ancestorId: ", p), err) }
  return err
}

func (p *ScheduledTask) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timesPartitioned", thrift.I32, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:timesPartitioned: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.TimesPartitioned)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timesPartitioned (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:timesPartitioned: ", p), err) }
  return err
}

func (p *ScheduledTask) Equals(other *ScheduledTask) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.AssignedTask.Equals(other.AssignedTask) { return false }
  if p.Status != other.Status { return false }
  if p.FailureCount != other.FailureCount { return false }
  if len(p.TaskEvents) != len(other.TaskEvents) { return false }
  for i, _tgt := range p.TaskEvents {
    _src31 := other.TaskEvents[i]
    if !_tgt.Equals(_src31) { return false }
  }
  if p.AncestorId != other.AncestorId { return false }
  if p.TimesPartitioned != other.TimesPartitioned { return false }
  return true
}

func (p *ScheduledTask) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ScheduledTask(%+v)", *p)
}

// Attributes:
//  - Tasks
type ScheduleStatusResult_ struct {
  Tasks []*ScheduledTask `thrift:"tasks,1" db:"tasks" json:"tasks"`
}

func NewScheduleStatusResult_() *ScheduleStatusResult_ {
  return &ScheduleStatusResult_{}
}


func (p *ScheduleStatusResult_) GetTasks() []*ScheduledTask {
  return p.Tasks
}
func (p *ScheduleStatusResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ScheduleStatusResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ScheduledTask, 0, size)
  p.Tasks =  tSlice
  for i := 0; i < size; i ++ {
    _elem32 := &ScheduledTask{}
    if err := _elem32.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem32), err)
    }
    p.Tasks = append(p.Tasks, _elem32)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ScheduleStatusResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ScheduleStatusResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ScheduleStatusResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tasks", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tasks: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tasks)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Tasks {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tasks: ", p), err) }
  return err
}

func (p *ScheduleStatusResult_) Equals(other *ScheduleStatusResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Tasks) != len(other.Tasks) { return false }
  for i, _tgt := range p.Tasks {
    _src33 := other.Tasks[i]
    if !_tgt.Equals(_src33) { return false }
  }
  return true
}

func (p *ScheduleStatusResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ScheduleStatusResult_(%+v)", *p)
}

// Attributes:
//  - Configs
type GetJobsResult_ struct {
  Configs []*JobConfiguration `thrift:"configs,1" db:"configs" json:"configs"`
}

func NewGetJobsResult_() *GetJobsResult_ {
  return &GetJobsResult_{}
}


func (p *GetJobsResult_) GetConfigs() []*JobConfiguration {
  return p.Configs
}
func (p *GetJobsResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetJobsResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*JobConfiguration, 0, size)
  p.Configs =  tSet
  for i := 0; i < size; i ++ {
    _elem34 := &JobConfiguration{}
    if err := _elem34.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem34), err)
    }
    p.Configs = append(p.Configs, _elem34)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetJobsResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetJobsResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetJobsResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "configs", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:configs: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Configs)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Configs); i++ {
    for j := i+1; j<len(p.Configs); j++ {
      if func(tgt, src *JobConfiguration) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Configs[i], p.Configs[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Configs))
      }
    }
  }
  for _, v := range p.Configs {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:configs: ", p), err) }
  return err
}

func (p *GetJobsResult_) Equals(other *GetJobsResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Configs) != len(other.Configs) { return false }
  for i, _tgt := range p.Configs {
    _src35 := other.Configs[i]
    if !_tgt.Equals(_src35) { return false }
  }
  return true
}

func (p *GetJobsResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetJobsResult_(%+v)", *p)
}

// Contains a set of restrictions on matching tasks where all restrictions must be met
// (terms are AND'ed together).
// 
// Attributes:
//  - Role
//  - Environment
//  - JobName
//  - TaskIds
//  - Statuses
//  - InstanceIds
//  - SlaveHosts
//  - JobKeys
//  - Offset
//  - Limit
type TaskQuery struct {
  // unused field # 1
  JobName *string `thrift:"jobName,2" db:"jobName" json:"jobName,omitempty"`
  // unused field # 3
  TaskIds []string `thrift:"taskIds,4" db:"taskIds" json:"taskIds,omitempty"`
  Statuses []ScheduleStatus `thrift:"statuses,5" db:"statuses" json:"statuses,omitempty"`
  // unused field # 6
  InstanceIds []int32 `thrift:"instanceIds,7" db:"instanceIds" json:"instanceIds,omitempty"`
  // unused field # 8
  Environment *string `thrift:"environment,9" db:"environment" json:"environment,omitempty"`
  SlaveHosts []string `thrift:"slaveHosts,10" db:"slaveHosts" json:"slaveHosts,omitempty"`
  JobKeys []*JobKey `thrift:"jobKeys,11" db:"jobKeys" json:"jobKeys,omitempty"`
  Offset *int32 `thrift:"offset,12" db:"offset" json:"offset,omitempty"`
  Limit *int32 `thrift:"limit,13" db:"limit" json:"limit,omitempty"`
  Role *string `thrift:"role,14" db:"role" json:"role,omitempty"`
}

func NewTaskQuery() *TaskQuery {
  return &TaskQuery{}
}

var TaskQuery_Role_DEFAULT string
func (p *TaskQuery) GetRole() string {
  if !p.IsSetRole() {
    return TaskQuery_Role_DEFAULT
  }
return *p.Role
}
var TaskQuery_Environment_DEFAULT string
func (p *TaskQuery) GetEnvironment() string {
  if !p.IsSetEnvironment() {
    return TaskQuery_Environment_DEFAULT
  }
return *p.Environment
}
var TaskQuery_JobName_DEFAULT string
func (p *TaskQuery) GetJobName() string {
  if !p.IsSetJobName() {
    return TaskQuery_JobName_DEFAULT
  }
return *p.JobName
}
var TaskQuery_TaskIds_DEFAULT []string

func (p *TaskQuery) GetTaskIds() []string {
  return p.TaskIds
}
var TaskQuery_Statuses_DEFAULT []ScheduleStatus

func (p *TaskQuery) GetStatuses() []ScheduleStatus {
  return p.Statuses
}
var TaskQuery_InstanceIds_DEFAULT []int32

func (p *TaskQuery) GetInstanceIds() []int32 {
  return p.InstanceIds
}
var TaskQuery_SlaveHosts_DEFAULT []string

func (p *TaskQuery) GetSlaveHosts() []string {
  return p.SlaveHosts
}
var TaskQuery_JobKeys_DEFAULT []*JobKey

func (p *TaskQuery) GetJobKeys() []*JobKey {
  return p.JobKeys
}
var TaskQuery_Offset_DEFAULT int32
func (p *TaskQuery) GetOffset() int32 {
  if !p.IsSetOffset() {
    return TaskQuery_Offset_DEFAULT
  }
return *p.Offset
}
var TaskQuery_Limit_DEFAULT int32
func (p *TaskQuery) GetLimit() int32 {
  if !p.IsSetLimit() {
    return TaskQuery_Limit_DEFAULT
  }
return *p.Limit
}
func (p *TaskQuery) IsSetRole() bool {
  return p.Role != nil
}

func (p *TaskQuery) IsSetEnvironment() bool {
  return p.Environment != nil
}

func (p *TaskQuery) IsSetJobName() bool {
  return p.JobName != nil
}

func (p *TaskQuery) IsSetTaskIds() bool {
  return p.TaskIds != nil
}

func (p *TaskQuery) IsSetStatuses() bool {
  return p.Statuses != nil
}

func (p *TaskQuery) IsSetInstanceIds() bool {
  return p.InstanceIds != nil
}

func (p *TaskQuery) IsSetSlaveHosts() bool {
  return p.SlaveHosts != nil
}

func (p *TaskQuery) IsSetJobKeys() bool {
  return p.JobKeys != nil
}

func (p *TaskQuery) IsSetOffset() bool {
  return p.Offset != nil
}

func (p *TaskQuery) IsSetLimit() bool {
  return p.Limit != nil
}

func (p *TaskQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 14:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TaskQuery)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  p.Role = &v
}
  return nil
}

func (p *TaskQuery)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.Environment = &v
}
  return nil
}

func (p *TaskQuery)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.JobName = &v
}
  return nil
}

func (p *TaskQuery)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.TaskIds =  tSet
  for i := 0; i < size; i ++ {
var _elem36 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem36 = v
}
    p.TaskIds = append(p.TaskIds, _elem36)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskQuery)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]ScheduleStatus, 0, size)
  p.Statuses =  tSet
  for i := 0; i < size; i ++ {
var _elem37 ScheduleStatus
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := ScheduleStatus(v)
    _elem37 = temp
}
    p.Statuses = append(p.Statuses, _elem37)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskQuery)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]int32, 0, size)
  p.InstanceIds =  tSet
  for i := 0; i < size; i ++ {
var _elem38 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem38 = v
}
    p.InstanceIds = append(p.InstanceIds, _elem38)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskQuery)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.SlaveHosts =  tSet
  for i := 0; i < size; i ++ {
var _elem39 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem39 = v
}
    p.SlaveHosts = append(p.SlaveHosts, _elem39)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskQuery)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*JobKey, 0, size)
  p.JobKeys =  tSet
  for i := 0; i < size; i ++ {
    _elem40 := &JobKey{}
    if err := _elem40.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem40), err)
    }
    p.JobKeys = append(p.JobKeys, _elem40)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *TaskQuery)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.Offset = &v
}
  return nil
}

func (p *TaskQuery)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  p.Limit = &v
}
  return nil
}

func (p *TaskQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TaskQuery"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TaskQuery) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetJobName() {
    if err := oprot.WriteFieldBegin(ctx, "jobName", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:jobName: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.JobName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.jobName (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:jobName: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTaskIds() {
    if err := oprot.WriteFieldBegin(ctx, "taskIds", thrift.SET, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:taskIds: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.TaskIds)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.TaskIds); i++ {
      for j := i+1; j<len(p.TaskIds); j++ {
        if func(tgt, src string) bool {
          if tgt != src { return false }
          return true
        }(p.TaskIds[i], p.TaskIds[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.TaskIds))
        }
      }
    }
    for _, v := range p.TaskIds {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:taskIds: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStatuses() {
    if err := oprot.WriteFieldBegin(ctx, "statuses", thrift.SET, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:statuses: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.Statuses)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.Statuses); i++ {
      for j := i+1; j<len(p.Statuses); j++ {
        if func(tgt, src ScheduleStatus) bool {
          if tgt != src { return false }
          return true
        }(p.Statuses[i], p.Statuses[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Statuses))
        }
      }
    }
    for _, v := range p.Statuses {
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:statuses: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetInstanceIds() {
    if err := oprot.WriteFieldBegin(ctx, "instanceIds", thrift.SET, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:instanceIds: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.InstanceIds)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.InstanceIds); i++ {
      for j := i+1; j<len(p.InstanceIds); j++ {
        if func(tgt, src int32) bool {
          if tgt != src { return false }
          return true
        }(p.InstanceIds[i], p.InstanceIds[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.InstanceIds))
        }
      }
    }
    for _, v := range p.InstanceIds {
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:instanceIds: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEnvironment() {
    if err := oprot.WriteFieldBegin(ctx, "environment", thrift.STRING, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:environment: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Environment)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.environment (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:environment: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSlaveHosts() {
    if err := oprot.WriteFieldBegin(ctx, "slaveHosts", thrift.SET, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:slaveHosts: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.SlaveHosts)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.SlaveHosts); i++ {
      for j := i+1; j<len(p.SlaveHosts); j++ {
        if func(tgt, src string) bool {
          if tgt != src { return false }
          return true
        }(p.SlaveHosts[i], p.SlaveHosts[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.SlaveHosts))
        }
      }
    }
    for _, v := range p.SlaveHosts {
      if err := oprot.WriteString(ctx, string(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:slaveHosts: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetJobKeys() {
    if err := oprot.WriteFieldBegin(ctx, "jobKeys", thrift.SET, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:jobKeys: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.JobKeys)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.JobKeys); i++ {
      for j := i+1; j<len(p.JobKeys); j++ {
        if func(tgt, src *JobKey) bool {
          if !tgt.Equals(src) { return false }
          return true
        }(p.JobKeys[i], p.JobKeys[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.JobKeys))
        }
      }
    }
    for _, v := range p.JobKeys {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:jobKeys: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOffset() {
    if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I32, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:offset: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Offset)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.offset (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:offset: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLimit() {
    if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I32, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:limit: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Limit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.limit (13) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:limit: ", p), err) }
  }
  return err
}

func (p *TaskQuery) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRole() {
    if err := oprot.WriteFieldBegin(ctx, "role", thrift.STRING, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:role: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Role)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.role (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:role: ", p), err) }
  }
  return err
}

func (p *TaskQuery) Equals(other *TaskQuery) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.JobName != other.JobName {
    if p.JobName == nil || other.JobName == nil {
      return false
    }
    if (*p.JobName) != (*other.JobName) { return false }
  }
  if len(p.TaskIds) != len(other.TaskIds) { return false }
  for i, _tgt := range p.TaskIds {
    _src41 := other.TaskIds[i]
    if _tgt != _src41 { return false }
  }
  if len(p.Statuses) != len(other.Statuses) { return false }
  for i, _tgt := range p.Statuses {
    _src42 := other.Statuses[i]
    if _tgt != _src42 { return false }
  }
  if len(p.InstanceIds) != len(other.InstanceIds) { return false }
  for i, _tgt := range p.InstanceIds {
    _src43 := other.InstanceIds[i]
    if _tgt != _src43 { return false }
  }
  if p.Environment != other.Environment {
    if p.Environment == nil || other.Environment == nil {
      return false
    }
    if (*p.Environment) != (*other.Environment) { return false }
  }
  if len(p.SlaveHosts) != len(other.SlaveHosts) { return false }
  for i, _tgt := range p.SlaveHosts {
    _src44 := other.SlaveHosts[i]
    if _tgt != _src44 { return false }
  }
  if len(p.JobKeys) != len(other.JobKeys) { return false }
  for i, _tgt := range p.JobKeys {
    _src45 := other.JobKeys[i]
    if !_tgt.Equals(_src45) { return false }
  }
  if p.Offset != other.Offset {
    if p.Offset == nil || other.Offset == nil {
      return false
    }
    if (*p.Offset) != (*other.Offset) { return false }
  }
  if p.Limit != other.Limit {
    if p.Limit == nil || other.Limit == nil {
      return false
    }
    if (*p.Limit) != (*other.Limit) { return false }
  }
  if p.Role != other.Role {
    if p.Role == nil || other.Role == nil {
      return false
    }
    if (*p.Role) != (*other.Role) { return false }
  }
  return true
}

func (p *TaskQuery) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TaskQuery(%+v)", *p)
}

// Attributes:
//  - Host
//  - Mode
type HostStatus struct {
  Host string `thrift:"host,1" db:"host" json:"host"`
  Mode MaintenanceMode `thrift:"mode,2" db:"mode" json:"mode"`
}

func NewHostStatus() *HostStatus {
  return &HostStatus{}
}


func (p *HostStatus) GetHost() string {
  return p.Host
}

func (p *HostStatus) GetMode() MaintenanceMode {
  return p.Mode
}
func (p *HostStatus) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HostStatus)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Host = v
}
  return nil
}

func (p *HostStatus)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := MaintenanceMode(v)
  p.Mode = temp
}
  return nil
}

func (p *HostStatus) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HostStatus"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HostStatus) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "host", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:host: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Host)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.host (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:host: ", p), err) }
  return err
}

func (p *HostStatus) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "mode", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:mode: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Mode)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.mode (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:mode: ", p), err) }
  return err
}

func (p *HostStatus) Equals(other *HostStatus) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Host != other.Host { return false }
  if p.Mode != other.Mode { return false }
  return true
}

func (p *HostStatus) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HostStatus(%+v)", *p)
}

// Attributes:
//  - Role
//  - JobCount
//  - CronJobCount
type RoleSummary struct {
  Role string `thrift:"role,1" db:"role" json:"role"`
  JobCount int32 `thrift:"jobCount,2" db:"jobCount" json:"jobCount"`
  CronJobCount int32 `thrift:"cronJobCount,3" db:"cronJobCount" json:"cronJobCount"`
}

func NewRoleSummary() *RoleSummary {
  return &RoleSummary{}
}


func (p *RoleSummary) GetRole() string {
  return p.Role
}

func (p *RoleSummary) GetJobCount() int32 {
  return p.JobCount
}

func (p *RoleSummary) GetCronJobCount() int32 {
  return p.CronJobCount
}
func (p *RoleSummary) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RoleSummary)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Role = v
}
  return nil
}

func (p *RoleSummary)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.JobCount = v
}
  return nil
}

func (p *RoleSummary)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.CronJobCount = v
}
  return nil
}

func (p *RoleSummary) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RoleSummary"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RoleSummary) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "role", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:role: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Role)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.role (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:role: ", p), err) }
  return err
}

func (p *RoleSummary) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "jobCount", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:jobCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.JobCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.jobCount (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:jobCount: ", p), err) }
  return err
}

func (p *RoleSummary) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cronJobCount", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:cronJobCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.CronJobCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cronJobCount (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:cronJobCount: ", p), err) }
  return err
}

func (p *RoleSummary) Equals(other *RoleSummary) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Role != other.Role { return false }
  if p.JobCount != other.JobCount { return false }
  if p.CronJobCount != other.CronJobCount { return false }
  return true
}

func (p *RoleSummary) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RoleSummary(%+v)", *p)
}

// Attributes:
//  - HostNames
type Hosts struct {
  HostNames []string `thrift:"hostNames,1" db:"hostNames" json:"hostNames"`
}

func NewHosts() *Hosts {
  return &Hosts{}
}


func (p *Hosts) GetHostNames() []string {
  return p.HostNames
}
func (p *Hosts) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Hosts)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.HostNames =  tSet
  for i := 0; i < size; i ++ {
var _elem46 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem46 = v
}
    p.HostNames = append(p.HostNames, _elem46)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *Hosts) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Hosts"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Hosts) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hostNames", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hostNames: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.HostNames)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.HostNames); i++ {
    for j := i+1; j<len(p.HostNames); j++ {
      if func(tgt, src string) bool {
        if tgt != src { return false }
        return true
      }(p.HostNames[i], p.HostNames[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.HostNames))
      }
    }
  }
  for _, v := range p.HostNames {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hostNames: ", p), err) }
  return err
}

func (p *Hosts) Equals(other *Hosts) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.HostNames) != len(other.HostNames) { return false }
  for i, _tgt := range p.HostNames {
    _src47 := other.HostNames[i]
    if _tgt != _src47 { return false }
  }
  return true
}

func (p *Hosts) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Hosts(%+v)", *p)
}

// Attributes:
//  - TaskId
//  - Reason
type PendingReason struct {
  TaskId string `thrift:"taskId,1" db:"taskId" json:"taskId"`
  Reason string `thrift:"reason,2" db:"reason" json:"reason"`
}

func NewPendingReason() *PendingReason {
  return &PendingReason{}
}


func (p *PendingReason) GetTaskId() string {
  return p.TaskId
}

func (p *PendingReason) GetReason() string {
  return p.Reason
}
func (p *PendingReason) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PendingReason)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TaskId = v
}
  return nil
}

func (p *PendingReason)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Reason = v
}
  return nil
}

func (p *PendingReason) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PendingReason"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PendingReason) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:taskId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.TaskId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.taskId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:taskId: ", p), err) }
  return err
}

func (p *PendingReason) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "reason", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:reason: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Reason)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.reason (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:reason: ", p), err) }
  return err
}

func (p *PendingReason) Equals(other *PendingReason) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.TaskId != other.TaskId { return false }
  if p.Reason != other.Reason { return false }
  return true
}

func (p *PendingReason) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PendingReason(%+v)", *p)
}

// Job update key.
// 
// Attributes:
//  - Job: Job being updated
//  - ID: Update ID.
type JobUpdateKey struct {
  Job *JobKey `thrift:"job,1" db:"job" json:"job"`
  ID string `thrift:"id,2" db:"id" json:"id"`
}

func NewJobUpdateKey() *JobUpdateKey {
  return &JobUpdateKey{}
}

var JobUpdateKey_Job_DEFAULT *JobKey
func (p *JobUpdateKey) GetJob() *JobKey {
  if !p.IsSetJob() {
    return JobUpdateKey_Job_DEFAULT
  }
return p.Job
}

func (p *JobUpdateKey) GetID() string {
  return p.ID
}
func (p *JobUpdateKey) IsSetJob() bool {
  return p.Job != nil
}

func (p *JobUpdateKey) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateKey)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *JobUpdateKey)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *JobUpdateKey) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateKey"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateKey) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:job: ", p), err) }
  return err
}

func (p *JobUpdateKey) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:id: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:id: ", p), err) }
  return err
}

func (p *JobUpdateKey) Equals(other *JobUpdateKey) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Job.Equals(other.Job) { return false }
  if p.ID != other.ID { return false }
  return true
}

func (p *JobUpdateKey) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateKey(%+v)", *p)
}

// Limits the amount of active changes being made to instances to groupSize.
// 
// Attributes:
//  - GroupSize
type QueueJobUpdateStrategy struct {
  GroupSize int32 `thrift:"groupSize,1" db:"groupSize" json:"groupSize"`
}

func NewQueueJobUpdateStrategy() *QueueJobUpdateStrategy {
  return &QueueJobUpdateStrategy{}
}


func (p *QueueJobUpdateStrategy) GetGroupSize() int32 {
  return p.GroupSize
}
func (p *QueueJobUpdateStrategy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *QueueJobUpdateStrategy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.GroupSize = v
}
  return nil
}

func (p *QueueJobUpdateStrategy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "QueueJobUpdateStrategy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *QueueJobUpdateStrategy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "groupSize", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:groupSize: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.GroupSize)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.groupSize (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:groupSize: ", p), err) }
  return err
}

func (p *QueueJobUpdateStrategy) Equals(other *QueueJobUpdateStrategy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.GroupSize != other.GroupSize { return false }
  return true
}

func (p *QueueJobUpdateStrategy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("QueueJobUpdateStrategy(%+v)", *p)
}

// Similar to Queue strategy but will not start a new group until all instances in an active
// group have finished updating.
// 
// Attributes:
//  - GroupSize
//  - AutopauseAfterBatch
type BatchJobUpdateStrategy struct {
  GroupSize int32 `thrift:"groupSize,1" db:"groupSize" json:"groupSize"`
  AutopauseAfterBatch bool `thrift:"autopauseAfterBatch,2" db:"autopauseAfterBatch" json:"autopauseAfterBatch"`
}

func NewBatchJobUpdateStrategy() *BatchJobUpdateStrategy {
  return &BatchJobUpdateStrategy{}
}


func (p *BatchJobUpdateStrategy) GetGroupSize() int32 {
  return p.GroupSize
}

func (p *BatchJobUpdateStrategy) GetAutopauseAfterBatch() bool {
  return p.AutopauseAfterBatch
}
func (p *BatchJobUpdateStrategy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *BatchJobUpdateStrategy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.GroupSize = v
}
  return nil
}

func (p *BatchJobUpdateStrategy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AutopauseAfterBatch = v
}
  return nil
}

func (p *BatchJobUpdateStrategy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "BatchJobUpdateStrategy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *BatchJobUpdateStrategy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "groupSize", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:groupSize: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.GroupSize)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.groupSize (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:groupSize: ", p), err) }
  return err
}

func (p *BatchJobUpdateStrategy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "autopauseAfterBatch", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:autopauseAfterBatch: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.AutopauseAfterBatch)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.autopauseAfterBatch (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:autopauseAfterBatch: ", p), err) }
  return err
}

func (p *BatchJobUpdateStrategy) Equals(other *BatchJobUpdateStrategy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.GroupSize != other.GroupSize { return false }
  if p.AutopauseAfterBatch != other.AutopauseAfterBatch { return false }
  return true
}

func (p *BatchJobUpdateStrategy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("BatchJobUpdateStrategy(%+v)", *p)
}

// Same as Batch strategy but each time an active group completes, the size of the next active
// group may change.
// 
// Attributes:
//  - GroupSizes
//  - AutopauseAfterBatch
type VariableBatchJobUpdateStrategy struct {
  GroupSizes []int32 `thrift:"groupSizes,1" db:"groupSizes" json:"groupSizes"`
  AutopauseAfterBatch bool `thrift:"autopauseAfterBatch,2" db:"autopauseAfterBatch" json:"autopauseAfterBatch"`
}

func NewVariableBatchJobUpdateStrategy() *VariableBatchJobUpdateStrategy {
  return &VariableBatchJobUpdateStrategy{}
}


func (p *VariableBatchJobUpdateStrategy) GetGroupSizes() []int32 {
  return p.GroupSizes
}

func (p *VariableBatchJobUpdateStrategy) GetAutopauseAfterBatch() bool {
  return p.AutopauseAfterBatch
}
func (p *VariableBatchJobUpdateStrategy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *VariableBatchJobUpdateStrategy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int32, 0, size)
  p.GroupSizes =  tSlice
  for i := 0; i < size; i ++ {
var _elem48 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem48 = v
}
    p.GroupSizes = append(p.GroupSizes, _elem48)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *VariableBatchJobUpdateStrategy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.AutopauseAfterBatch = v
}
  return nil
}

func (p *VariableBatchJobUpdateStrategy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "VariableBatchJobUpdateStrategy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *VariableBatchJobUpdateStrategy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "groupSizes", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:groupSizes: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.I32, len(p.GroupSizes)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.GroupSizes {
    if err := oprot.WriteI32(ctx, int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:groupSizes: ", p), err) }
  return err
}

func (p *VariableBatchJobUpdateStrategy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "autopauseAfterBatch", thrift.BOOL, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:autopauseAfterBatch: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.AutopauseAfterBatch)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.autopauseAfterBatch (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:autopauseAfterBatch: ", p), err) }
  return err
}

func (p *VariableBatchJobUpdateStrategy) Equals(other *VariableBatchJobUpdateStrategy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.GroupSizes) != len(other.GroupSizes) { return false }
  for i, _tgt := range p.GroupSizes {
    _src49 := other.GroupSizes[i]
    if _tgt != _src49 { return false }
  }
  if p.AutopauseAfterBatch != other.AutopauseAfterBatch { return false }
  return true
}

func (p *VariableBatchJobUpdateStrategy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("VariableBatchJobUpdateStrategy(%+v)", *p)
}

// Attributes:
//  - QueueStrategy
//  - BatchStrategy
//  - VarBatchStrategy
type JobUpdateStrategy struct {
  QueueStrategy *QueueJobUpdateStrategy `thrift:"queueStrategy,1" db:"queueStrategy" json:"queueStrategy,omitempty"`
  BatchStrategy *BatchJobUpdateStrategy `thrift:"batchStrategy,2" db:"batchStrategy" json:"batchStrategy,omitempty"`
  VarBatchStrategy *VariableBatchJobUpdateStrategy `thrift:"varBatchStrategy,3" db:"varBatchStrategy" json:"varBatchStrategy,omitempty"`
}

func NewJobUpdateStrategy() *JobUpdateStrategy {
  return &JobUpdateStrategy{}
}

var JobUpdateStrategy_QueueStrategy_DEFAULT *QueueJobUpdateStrategy
func (p *JobUpdateStrategy) GetQueueStrategy() *QueueJobUpdateStrategy {
  if !p.IsSetQueueStrategy() {
    return JobUpdateStrategy_QueueStrategy_DEFAULT
  }
return p.QueueStrategy
}
var JobUpdateStrategy_BatchStrategy_DEFAULT *BatchJobUpdateStrategy
func (p *JobUpdateStrategy) GetBatchStrategy() *BatchJobUpdateStrategy {
  if !p.IsSetBatchStrategy() {
    return JobUpdateStrategy_BatchStrategy_DEFAULT
  }
return p.BatchStrategy
}
var JobUpdateStrategy_VarBatchStrategy_DEFAULT *VariableBatchJobUpdateStrategy
func (p *JobUpdateStrategy) GetVarBatchStrategy() *VariableBatchJobUpdateStrategy {
  if !p.IsSetVarBatchStrategy() {
    return JobUpdateStrategy_VarBatchStrategy_DEFAULT
  }
return p.VarBatchStrategy
}
func (p *JobUpdateStrategy) CountSetFieldsJobUpdateStrategy() int {
  count := 0
  if (p.IsSetQueueStrategy()) {
    count++
  }
  if (p.IsSetBatchStrategy()) {
    count++
  }
  if (p.IsSetVarBatchStrategy()) {
    count++
  }
  return count

}

func (p *JobUpdateStrategy) IsSetQueueStrategy() bool {
  return p.QueueStrategy != nil
}

func (p *JobUpdateStrategy) IsSetBatchStrategy() bool {
  return p.BatchStrategy != nil
}

func (p *JobUpdateStrategy) IsSetVarBatchStrategy() bool {
  return p.VarBatchStrategy != nil
}

func (p *JobUpdateStrategy) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateStrategy)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.QueueStrategy = &QueueJobUpdateStrategy{}
  if err := p.QueueStrategy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.QueueStrategy), err)
  }
  return nil
}

func (p *JobUpdateStrategy)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.BatchStrategy = &BatchJobUpdateStrategy{}
  if err := p.BatchStrategy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.BatchStrategy), err)
  }
  return nil
}

func (p *JobUpdateStrategy)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.VarBatchStrategy = &VariableBatchJobUpdateStrategy{}
  if err := p.VarBatchStrategy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VarBatchStrategy), err)
  }
  return nil
}

func (p *JobUpdateStrategy) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsJobUpdateStrategy(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "JobUpdateStrategy"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateStrategy) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetQueueStrategy() {
    if err := oprot.WriteFieldBegin(ctx, "queueStrategy", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:queueStrategy: ", p), err) }
    if err := p.QueueStrategy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.QueueStrategy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:queueStrategy: ", p), err) }
  }
  return err
}

func (p *JobUpdateStrategy) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBatchStrategy() {
    if err := oprot.WriteFieldBegin(ctx, "batchStrategy", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:batchStrategy: ", p), err) }
    if err := p.BatchStrategy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.BatchStrategy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:batchStrategy: ", p), err) }
  }
  return err
}

func (p *JobUpdateStrategy) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVarBatchStrategy() {
    if err := oprot.WriteFieldBegin(ctx, "varBatchStrategy", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:varBatchStrategy: ", p), err) }
    if err := p.VarBatchStrategy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VarBatchStrategy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:varBatchStrategy: ", p), err) }
  }
  return err
}

func (p *JobUpdateStrategy) Equals(other *JobUpdateStrategy) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.QueueStrategy.Equals(other.QueueStrategy) { return false }
  if !p.BatchStrategy.Equals(other.BatchStrategy) { return false }
  if !p.VarBatchStrategy.Equals(other.VarBatchStrategy) { return false }
  return true
}

func (p *JobUpdateStrategy) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateStrategy(%+v)", *p)
}

// Job update thresholds and limits.
// 
// Attributes:
//  - UpdateGroupSize: Deprecated, please set value inside of desired update strategy instead.
// Max number of instances being updated at any given moment.
//  - MaxPerInstanceFailures: Max number of instance failures to tolerate before marking instance as FAILED.
//  - MaxFailedInstances: Max number of FAILED instances to tolerate before terminating the update.
//  - MinWaitInInstanceRunningMs: Min time to watch a RUNNING instance.
//  - RollbackOnFailure: If true, enables failed update rollback.
//  - UpdateOnlyTheseInstances: Instance IDs to act on. All instances will be affected if this is not set.
//  - WaitForBatchCompletion: Deprecated, please set updateStrategy to the Batch strategy instead.
// If true, use updateGroupSize as strict batching boundaries, and avoid proceeding to another
// batch until the preceding batch finishes updating.
//  - BlockIfNoPulsesAfterMs: If set, requires external calls to pulseJobUpdate RPC within the specified rate for the
// update to make progress. If no pulses received within specified interval the update will
// block. A blocked update is unable to continue but retains its current status. It may only get
// unblocked by a fresh pulseJobUpdate call.
//  - SlaAware: If true, updates will obey the SLA requirements of the tasks being updated. If the SLA policy
// differs between the old and new task configurations, updates will use the newest configuration.
//  - UpdateStrategy: Update strategy to be used for the update. See JobUpdateStrategy for choices.
type JobUpdateSettings struct {
  UpdateGroupSize int32 `thrift:"updateGroupSize,1" db:"updateGroupSize" json:"updateGroupSize"`
  MaxPerInstanceFailures int32 `thrift:"maxPerInstanceFailures,2" db:"maxPerInstanceFailures" json:"maxPerInstanceFailures"`
  MaxFailedInstances int32 `thrift:"maxFailedInstances,3" db:"maxFailedInstances" json:"maxFailedInstances"`
  // unused field # 4
  MinWaitInInstanceRunningMs int32 `thrift:"minWaitInInstanceRunningMs,5" db:"minWaitInInstanceRunningMs" json:"minWaitInInstanceRunningMs"`
  RollbackOnFailure bool `thrift:"rollbackOnFailure,6" db:"rollbackOnFailure" json:"rollbackOnFailure"`
  UpdateOnlyTheseInstances []*Range `thrift:"updateOnlyTheseInstances,7" db:"updateOnlyTheseInstances" json:"updateOnlyTheseInstances"`
  WaitForBatchCompletion bool `thrift:"waitForBatchCompletion,8" db:"waitForBatchCompletion" json:"waitForBatchCompletion"`
  BlockIfNoPulsesAfterMs *int32 `thrift:"blockIfNoPulsesAfterMs,9" db:"blockIfNoPulsesAfterMs" json:"blockIfNoPulsesAfterMs,omitempty"`
  SlaAware *bool `thrift:"slaAware,10" db:"slaAware" json:"slaAware,omitempty"`
  UpdateStrategy *JobUpdateStrategy `thrift:"updateStrategy,11" db:"updateStrategy" json:"updateStrategy,omitempty"`
}

func NewJobUpdateSettings() *JobUpdateSettings {
  return &JobUpdateSettings{}
}


func (p *JobUpdateSettings) GetUpdateGroupSize() int32 {
  return p.UpdateGroupSize
}

func (p *JobUpdateSettings) GetMaxPerInstanceFailures() int32 {
  return p.MaxPerInstanceFailures
}

func (p *JobUpdateSettings) GetMaxFailedInstances() int32 {
  return p.MaxFailedInstances
}

func (p *JobUpdateSettings) GetMinWaitInInstanceRunningMs() int32 {
  return p.MinWaitInInstanceRunningMs
}

func (p *JobUpdateSettings) GetRollbackOnFailure() bool {
  return p.RollbackOnFailure
}

func (p *JobUpdateSettings) GetUpdateOnlyTheseInstances() []*Range {
  return p.UpdateOnlyTheseInstances
}

func (p *JobUpdateSettings) GetWaitForBatchCompletion() bool {
  return p.WaitForBatchCompletion
}
var JobUpdateSettings_BlockIfNoPulsesAfterMs_DEFAULT int32
func (p *JobUpdateSettings) GetBlockIfNoPulsesAfterMs() int32 {
  if !p.IsSetBlockIfNoPulsesAfterMs() {
    return JobUpdateSettings_BlockIfNoPulsesAfterMs_DEFAULT
  }
return *p.BlockIfNoPulsesAfterMs
}
var JobUpdateSettings_SlaAware_DEFAULT bool
func (p *JobUpdateSettings) GetSlaAware() bool {
  if !p.IsSetSlaAware() {
    return JobUpdateSettings_SlaAware_DEFAULT
  }
return *p.SlaAware
}
var JobUpdateSettings_UpdateStrategy_DEFAULT *JobUpdateStrategy
func (p *JobUpdateSettings) GetUpdateStrategy() *JobUpdateStrategy {
  if !p.IsSetUpdateStrategy() {
    return JobUpdateSettings_UpdateStrategy_DEFAULT
  }
return p.UpdateStrategy
}
func (p *JobUpdateSettings) IsSetBlockIfNoPulsesAfterMs() bool {
  return p.BlockIfNoPulsesAfterMs != nil
}

func (p *JobUpdateSettings) IsSetSlaAware() bool {
  return p.SlaAware != nil
}

func (p *JobUpdateSettings) IsSetUpdateStrategy() bool {
  return p.UpdateStrategy != nil
}

func (p *JobUpdateSettings) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateSettings)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.UpdateGroupSize = v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.MaxPerInstanceFailures = v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.MaxFailedInstances = v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.MinWaitInInstanceRunningMs = v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.RollbackOnFailure = v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Range, 0, size)
  p.UpdateOnlyTheseInstances =  tSet
  for i := 0; i < size; i ++ {
    _elem50 := &Range{}
    if err := _elem50.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem50), err)
    }
    p.UpdateOnlyTheseInstances = append(p.UpdateOnlyTheseInstances, _elem50)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *JobUpdateSettings)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  p.WaitForBatchCompletion = v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.BlockIfNoPulsesAfterMs = &v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.SlaAware = &v
}
  return nil
}

func (p *JobUpdateSettings)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  p.UpdateStrategy = &JobUpdateStrategy{}
  if err := p.UpdateStrategy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UpdateStrategy), err)
  }
  return nil
}

func (p *JobUpdateSettings) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateSettings"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateSettings) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateGroupSize", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:updateGroupSize: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.UpdateGroupSize)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updateGroupSize (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:updateGroupSize: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxPerInstanceFailures", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:maxPerInstanceFailures: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxPerInstanceFailures)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxPerInstanceFailures (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:maxPerInstanceFailures: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "maxFailedInstances", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:maxFailedInstances: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MaxFailedInstances)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.maxFailedInstances (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:maxFailedInstances: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "minWaitInInstanceRunningMs", thrift.I32, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:minWaitInInstanceRunningMs: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.MinWaitInInstanceRunningMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.minWaitInInstanceRunningMs (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:minWaitInInstanceRunningMs: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rollbackOnFailure", thrift.BOOL, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:rollbackOnFailure: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.RollbackOnFailure)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rollbackOnFailure (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:rollbackOnFailure: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateOnlyTheseInstances", thrift.SET, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:updateOnlyTheseInstances: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.UpdateOnlyTheseInstances)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.UpdateOnlyTheseInstances); i++ {
    for j := i+1; j<len(p.UpdateOnlyTheseInstances); j++ {
      if func(tgt, src *Range) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.UpdateOnlyTheseInstances[i], p.UpdateOnlyTheseInstances[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.UpdateOnlyTheseInstances))
      }
    }
  }
  for _, v := range p.UpdateOnlyTheseInstances {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:updateOnlyTheseInstances: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "waitForBatchCompletion", thrift.BOOL, 8); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:waitForBatchCompletion: ", p), err) }
  if err := oprot.WriteBool(ctx, bool(p.WaitForBatchCompletion)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.waitForBatchCompletion (8) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 8:waitForBatchCompletion: ", p), err) }
  return err
}

func (p *JobUpdateSettings) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBlockIfNoPulsesAfterMs() {
    if err := oprot.WriteFieldBegin(ctx, "blockIfNoPulsesAfterMs", thrift.I32, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:blockIfNoPulsesAfterMs: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BlockIfNoPulsesAfterMs)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.blockIfNoPulsesAfterMs (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:blockIfNoPulsesAfterMs: ", p), err) }
  }
  return err
}

func (p *JobUpdateSettings) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSlaAware() {
    if err := oprot.WriteFieldBegin(ctx, "slaAware", thrift.BOOL, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:slaAware: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.SlaAware)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.slaAware (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:slaAware: ", p), err) }
  }
  return err
}

func (p *JobUpdateSettings) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateStrategy() {
    if err := oprot.WriteFieldBegin(ctx, "updateStrategy", thrift.STRUCT, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updateStrategy: ", p), err) }
    if err := p.UpdateStrategy.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UpdateStrategy), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updateStrategy: ", p), err) }
  }
  return err
}

func (p *JobUpdateSettings) Equals(other *JobUpdateSettings) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.UpdateGroupSize != other.UpdateGroupSize { return false }
  if p.MaxPerInstanceFailures != other.MaxPerInstanceFailures { return false }
  if p.MaxFailedInstances != other.MaxFailedInstances { return false }
  if p.MinWaitInInstanceRunningMs != other.MinWaitInInstanceRunningMs { return false }
  if p.RollbackOnFailure != other.RollbackOnFailure { return false }
  if len(p.UpdateOnlyTheseInstances) != len(other.UpdateOnlyTheseInstances) { return false }
  for i, _tgt := range p.UpdateOnlyTheseInstances {
    _src51 := other.UpdateOnlyTheseInstances[i]
    if !_tgt.Equals(_src51) { return false }
  }
  if p.WaitForBatchCompletion != other.WaitForBatchCompletion { return false }
  if p.BlockIfNoPulsesAfterMs != other.BlockIfNoPulsesAfterMs {
    if p.BlockIfNoPulsesAfterMs == nil || other.BlockIfNoPulsesAfterMs == nil {
      return false
    }
    if (*p.BlockIfNoPulsesAfterMs) != (*other.BlockIfNoPulsesAfterMs) { return false }
  }
  if p.SlaAware != other.SlaAware {
    if p.SlaAware == nil || other.SlaAware == nil {
      return false
    }
    if (*p.SlaAware) != (*other.SlaAware) { return false }
  }
  if !p.UpdateStrategy.Equals(other.UpdateStrategy) { return false }
  return true
}

func (p *JobUpdateSettings) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateSettings(%+v)", *p)
}

// Event marking a state transition in job update lifecycle.
// 
// Attributes:
//  - Status: Update status.
//  - TimestampMs: Epoch timestamp in milliseconds.
//  - User: User who performed this event (if user-initiated).
//  - Message: Message from the user (for user-initiated transitions) or the scheduler about why the state was
// changed.
type JobUpdateEvent struct {
  Status JobUpdateStatus `thrift:"status,1" db:"status" json:"status"`
  TimestampMs int64 `thrift:"timestampMs,2" db:"timestampMs" json:"timestampMs"`
  User *string `thrift:"user,3" db:"user" json:"user,omitempty"`
  Message *string `thrift:"message,4" db:"message" json:"message,omitempty"`
}

func NewJobUpdateEvent() *JobUpdateEvent {
  return &JobUpdateEvent{}
}


func (p *JobUpdateEvent) GetStatus() JobUpdateStatus {
  return p.Status
}

func (p *JobUpdateEvent) GetTimestampMs() int64 {
  return p.TimestampMs
}
var JobUpdateEvent_User_DEFAULT string
func (p *JobUpdateEvent) GetUser() string {
  if !p.IsSetUser() {
    return JobUpdateEvent_User_DEFAULT
  }
return *p.User
}
var JobUpdateEvent_Message_DEFAULT string
func (p *JobUpdateEvent) GetMessage() string {
  if !p.IsSetMessage() {
    return JobUpdateEvent_Message_DEFAULT
  }
return *p.Message
}
func (p *JobUpdateEvent) IsSetUser() bool {
  return p.User != nil
}

func (p *JobUpdateEvent) IsSetMessage() bool {
  return p.Message != nil
}

func (p *JobUpdateEvent) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateEvent)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := JobUpdateStatus(v)
  p.Status = temp
}
  return nil
}

func (p *JobUpdateEvent)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TimestampMs = v
}
  return nil
}

func (p *JobUpdateEvent)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.User = &v
}
  return nil
}

func (p *JobUpdateEvent)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *JobUpdateEvent) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateEvent"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateEvent) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.status (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:status: ", p), err) }
  return err
}

func (p *JobUpdateEvent) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timestampMs", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:timestampMs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TimestampMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timestampMs (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:timestampMs: ", p), err) }
  return err
}

func (p *JobUpdateEvent) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUser() {
    if err := oprot.WriteFieldBegin(ctx, "user", thrift.STRING, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:user: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.User)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.user (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:user: ", p), err) }
  }
  return err
}

func (p *JobUpdateEvent) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:message: ", p), err) }
  }
  return err
}

func (p *JobUpdateEvent) Equals(other *JobUpdateEvent) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Status != other.Status { return false }
  if p.TimestampMs != other.TimestampMs { return false }
  if p.User != other.User {
    if p.User == nil || other.User == nil {
      return false
    }
    if (*p.User) != (*other.User) { return false }
  }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  return true
}

func (p *JobUpdateEvent) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateEvent(%+v)", *p)
}

// Event marking a state transition in job instance update lifecycle.
// 
// Attributes:
//  - InstanceId: Job instance ID.
//  - TimestampMs: Epoch timestamp in milliseconds.
//  - Action: Job update action taken on the instance.
//  - Message: Optional message explaining the instance update event.
type JobInstanceUpdateEvent struct {
  InstanceId int32 `thrift:"instanceId,1" db:"instanceId" json:"instanceId"`
  TimestampMs int64 `thrift:"timestampMs,2" db:"timestampMs" json:"timestampMs"`
  Action JobUpdateAction `thrift:"action,3" db:"action" json:"action"`
  Message *string `thrift:"message,4" db:"message" json:"message,omitempty"`
}

func NewJobInstanceUpdateEvent() *JobInstanceUpdateEvent {
  return &JobInstanceUpdateEvent{}
}


func (p *JobInstanceUpdateEvent) GetInstanceId() int32 {
  return p.InstanceId
}

func (p *JobInstanceUpdateEvent) GetTimestampMs() int64 {
  return p.TimestampMs
}

func (p *JobInstanceUpdateEvent) GetAction() JobUpdateAction {
  return p.Action
}
var JobInstanceUpdateEvent_Message_DEFAULT string
func (p *JobInstanceUpdateEvent) GetMessage() string {
  if !p.IsSetMessage() {
    return JobInstanceUpdateEvent_Message_DEFAULT
  }
return *p.Message
}
func (p *JobInstanceUpdateEvent) IsSetMessage() bool {
  return p.Message != nil
}

func (p *JobInstanceUpdateEvent) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobInstanceUpdateEvent)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.InstanceId = v
}
  return nil
}

func (p *JobInstanceUpdateEvent)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.TimestampMs = v
}
  return nil
}

func (p *JobInstanceUpdateEvent)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := JobUpdateAction(v)
  p.Action = temp
}
  return nil
}

func (p *JobInstanceUpdateEvent)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *JobInstanceUpdateEvent) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobInstanceUpdateEvent"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobInstanceUpdateEvent) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instanceId", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:instanceId: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.InstanceId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.instanceId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:instanceId: ", p), err) }
  return err
}

func (p *JobInstanceUpdateEvent) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timestampMs", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:timestampMs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TimestampMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timestampMs (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:timestampMs: ", p), err) }
  return err
}

func (p *JobInstanceUpdateEvent) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "action", thrift.I32, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:action: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Action)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.action (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:action: ", p), err) }
  return err
}

func (p *JobInstanceUpdateEvent) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:message: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:message: ", p), err) }
  }
  return err
}

func (p *JobInstanceUpdateEvent) Equals(other *JobInstanceUpdateEvent) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.InstanceId != other.InstanceId { return false }
  if p.TimestampMs != other.TimestampMs { return false }
  if p.Action != other.Action { return false }
  if p.Message != other.Message {
    if p.Message == nil || other.Message == nil {
      return false
    }
    if (*p.Message) != (*other.Message) { return false }
  }
  return true
}

func (p *JobInstanceUpdateEvent) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobInstanceUpdateEvent(%+v)", *p)
}

// Maps instance IDs to TaskConfigs it.
// 
// Attributes:
//  - Task: A TaskConfig associated with instances.
//  - Instances: Instances associated with the TaskConfig.
type InstanceTaskConfig struct {
  Task *TaskConfig `thrift:"task,1" db:"task" json:"task"`
  Instances []*Range `thrift:"instances,2" db:"instances" json:"instances"`
}

func NewInstanceTaskConfig() *InstanceTaskConfig {
  return &InstanceTaskConfig{}
}

var InstanceTaskConfig_Task_DEFAULT *TaskConfig
func (p *InstanceTaskConfig) GetTask() *TaskConfig {
  if !p.IsSetTask() {
    return InstanceTaskConfig_Task_DEFAULT
  }
return p.Task
}

func (p *InstanceTaskConfig) GetInstances() []*Range {
  return p.Instances
}
func (p *InstanceTaskConfig) IsSetTask() bool {
  return p.Task != nil
}

func (p *InstanceTaskConfig) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *InstanceTaskConfig)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Task = &TaskConfig{}
  if err := p.Task.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Task), err)
  }
  return nil
}

func (p *InstanceTaskConfig)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Range, 0, size)
  p.Instances =  tSet
  for i := 0; i < size; i ++ {
    _elem52 := &Range{}
    if err := _elem52.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem52), err)
    }
    p.Instances = append(p.Instances, _elem52)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *InstanceTaskConfig) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "InstanceTaskConfig"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *InstanceTaskConfig) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "task", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:task: ", p), err) }
  if err := p.Task.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Task), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:task: ", p), err) }
  return err
}

func (p *InstanceTaskConfig) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instances", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:instances: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Instances)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Instances); i++ {
    for j := i+1; j<len(p.Instances); j++ {
      if func(tgt, src *Range) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Instances[i], p.Instances[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Instances))
      }
    }
  }
  for _, v := range p.Instances {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:instances: ", p), err) }
  return err
}

func (p *InstanceTaskConfig) Equals(other *InstanceTaskConfig) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Task.Equals(other.Task) { return false }
  if len(p.Instances) != len(other.Instances) { return false }
  for i, _tgt := range p.Instances {
    _src53 := other.Instances[i]
    if !_tgt.Equals(_src53) { return false }
  }
  return true
}

func (p *InstanceTaskConfig) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("InstanceTaskConfig(%+v)", *p)
}

// Current job update state including status and created/modified timestamps.
// 
// Attributes:
//  - Status: Current status of the update.
//  - CreatedTimestampMs: Created timestamp in milliseconds.
//  - LastModifiedTimestampMs: Last modified timestamp in milliseconds.
type JobUpdateState struct {
  Status JobUpdateStatus `thrift:"status,1" db:"status" json:"status"`
  CreatedTimestampMs int64 `thrift:"createdTimestampMs,2" db:"createdTimestampMs" json:"createdTimestampMs"`
  LastModifiedTimestampMs int64 `thrift:"lastModifiedTimestampMs,3" db:"lastModifiedTimestampMs" json:"lastModifiedTimestampMs"`
}

func NewJobUpdateState() *JobUpdateState {
  return &JobUpdateState{}
}


func (p *JobUpdateState) GetStatus() JobUpdateStatus {
  return p.Status
}

func (p *JobUpdateState) GetCreatedTimestampMs() int64 {
  return p.CreatedTimestampMs
}

func (p *JobUpdateState) GetLastModifiedTimestampMs() int64 {
  return p.LastModifiedTimestampMs
}
func (p *JobUpdateState) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateState)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := JobUpdateStatus(v)
  p.Status = temp
}
  return nil
}

func (p *JobUpdateState)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.CreatedTimestampMs = v
}
  return nil
}

func (p *JobUpdateState)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.LastModifiedTimestampMs = v
}
  return nil
}

func (p *JobUpdateState) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateState"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateState) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.status (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:status: ", p), err) }
  return err
}

func (p *JobUpdateState) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "createdTimestampMs", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:createdTimestampMs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CreatedTimestampMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.createdTimestampMs (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:createdTimestampMs: ", p), err) }
  return err
}

func (p *JobUpdateState) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "lastModifiedTimestampMs", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:lastModifiedTimestampMs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.LastModifiedTimestampMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.lastModifiedTimestampMs (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:lastModifiedTimestampMs: ", p), err) }
  return err
}

func (p *JobUpdateState) Equals(other *JobUpdateState) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Status != other.Status { return false }
  if p.CreatedTimestampMs != other.CreatedTimestampMs { return false }
  if p.LastModifiedTimestampMs != other.LastModifiedTimestampMs { return false }
  return true
}

func (p *JobUpdateState) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateState(%+v)", *p)
}

// Summary of the job update including job key, user and current state.
// 
// Attributes:
//  - Key: Unique identifier for the update.
//  - User: User initiated an update.
//  - State: Current job update state.
//  - Metadata: Update metadata supplied by the client.
type JobUpdateSummary struct {
  // unused fields # 1 to 2
  User string `thrift:"user,3" db:"user" json:"user"`
  State *JobUpdateState `thrift:"state,4" db:"state" json:"state"`
  Key *JobUpdateKey `thrift:"key,5" db:"key" json:"key"`
  Metadata []*Metadata `thrift:"metadata,6" db:"metadata" json:"metadata,omitempty"`
}

func NewJobUpdateSummary() *JobUpdateSummary {
  return &JobUpdateSummary{}
}

var JobUpdateSummary_Key_DEFAULT *JobUpdateKey
func (p *JobUpdateSummary) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return JobUpdateSummary_Key_DEFAULT
  }
return p.Key
}

func (p *JobUpdateSummary) GetUser() string {
  return p.User
}
var JobUpdateSummary_State_DEFAULT *JobUpdateState
func (p *JobUpdateSummary) GetState() *JobUpdateState {
  if !p.IsSetState() {
    return JobUpdateSummary_State_DEFAULT
  }
return p.State
}
var JobUpdateSummary_Metadata_DEFAULT []*Metadata

func (p *JobUpdateSummary) GetMetadata() []*Metadata {
  return p.Metadata
}
func (p *JobUpdateSummary) IsSetKey() bool {
  return p.Key != nil
}

func (p *JobUpdateSummary) IsSetState() bool {
  return p.State != nil
}

func (p *JobUpdateSummary) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *JobUpdateSummary) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateSummary)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *JobUpdateSummary)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.User = v
}
  return nil
}

func (p *JobUpdateSummary)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.State = &JobUpdateState{}
  if err := p.State.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.State), err)
  }
  return nil
}

func (p *JobUpdateSummary)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Metadata, 0, size)
  p.Metadata =  tSet
  for i := 0; i < size; i ++ {
    _elem54 := &Metadata{}
    if err := _elem54.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem54), err)
    }
    p.Metadata = append(p.Metadata, _elem54)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *JobUpdateSummary) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateSummary"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateSummary) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "user", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:user: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.User)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.user (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:user: ", p), err) }
  return err
}

func (p *JobUpdateSummary) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "state", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:state: ", p), err) }
  if err := p.State.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.State), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:state: ", p), err) }
  return err
}

func (p *JobUpdateSummary) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key: ", p), err) }
  return err
}

func (p *JobUpdateSummary) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMetadata() {
    if err := oprot.WriteFieldBegin(ctx, "metadata", thrift.SET, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:metadata: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Metadata)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.Metadata); i++ {
      for j := i+1; j<len(p.Metadata); j++ {
        if func(tgt, src *Metadata) bool {
          if !tgt.Equals(src) { return false }
          return true
        }(p.Metadata[i], p.Metadata[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Metadata))
        }
      }
    }
    for _, v := range p.Metadata {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:metadata: ", p), err) }
  }
  return err
}

func (p *JobUpdateSummary) Equals(other *JobUpdateSummary) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.User != other.User { return false }
  if !p.State.Equals(other.State) { return false }
  if !p.Key.Equals(other.Key) { return false }
  if len(p.Metadata) != len(other.Metadata) { return false }
  for i, _tgt := range p.Metadata {
    _src55 := other.Metadata[i]
    if !_tgt.Equals(_src55) { return false }
  }
  return true
}

func (p *JobUpdateSummary) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateSummary(%+v)", *p)
}

// Update configuration and setting details.
// 
// Attributes:
//  - InitialState: Actual InstanceId -> TaskConfig mapping when the update was requested.
//  - DesiredState: Desired configuration when the update completes.
//  - Settings: Update specific settings.
type JobUpdateInstructions struct {
  InitialState []*InstanceTaskConfig `thrift:"initialState,1" db:"initialState" json:"initialState"`
  DesiredState *InstanceTaskConfig `thrift:"desiredState,2" db:"desiredState" json:"desiredState"`
  Settings *JobUpdateSettings `thrift:"settings,3" db:"settings" json:"settings"`
}

func NewJobUpdateInstructions() *JobUpdateInstructions {
  return &JobUpdateInstructions{}
}


func (p *JobUpdateInstructions) GetInitialState() []*InstanceTaskConfig {
  return p.InitialState
}
var JobUpdateInstructions_DesiredState_DEFAULT *InstanceTaskConfig
func (p *JobUpdateInstructions) GetDesiredState() *InstanceTaskConfig {
  if !p.IsSetDesiredState() {
    return JobUpdateInstructions_DesiredState_DEFAULT
  }
return p.DesiredState
}
var JobUpdateInstructions_Settings_DEFAULT *JobUpdateSettings
func (p *JobUpdateInstructions) GetSettings() *JobUpdateSettings {
  if !p.IsSetSettings() {
    return JobUpdateInstructions_Settings_DEFAULT
  }
return p.Settings
}
func (p *JobUpdateInstructions) IsSetDesiredState() bool {
  return p.DesiredState != nil
}

func (p *JobUpdateInstructions) IsSetSettings() bool {
  return p.Settings != nil
}

func (p *JobUpdateInstructions) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateInstructions)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*InstanceTaskConfig, 0, size)
  p.InitialState =  tSet
  for i := 0; i < size; i ++ {
    _elem56 := &InstanceTaskConfig{}
    if err := _elem56.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem56), err)
    }
    p.InitialState = append(p.InitialState, _elem56)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *JobUpdateInstructions)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.DesiredState = &InstanceTaskConfig{}
  if err := p.DesiredState.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DesiredState), err)
  }
  return nil
}

func (p *JobUpdateInstructions)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Settings = &JobUpdateSettings{}
  if err := p.Settings.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Settings), err)
  }
  return nil
}

func (p *JobUpdateInstructions) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateInstructions"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateInstructions) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "initialState", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:initialState: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.InitialState)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.InitialState); i++ {
    for j := i+1; j<len(p.InitialState); j++ {
      if func(tgt, src *InstanceTaskConfig) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.InitialState[i], p.InitialState[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.InitialState))
      }
    }
  }
  for _, v := range p.InitialState {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:initialState: ", p), err) }
  return err
}

func (p *JobUpdateInstructions) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "desiredState", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:desiredState: ", p), err) }
  if err := p.DesiredState.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DesiredState), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:desiredState: ", p), err) }
  return err
}

func (p *JobUpdateInstructions) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "settings", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:settings: ", p), err) }
  if err := p.Settings.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Settings), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:settings: ", p), err) }
  return err
}

func (p *JobUpdateInstructions) Equals(other *JobUpdateInstructions) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.InitialState) != len(other.InitialState) { return false }
  for i, _tgt := range p.InitialState {
    _src57 := other.InitialState[i]
    if !_tgt.Equals(_src57) { return false }
  }
  if !p.DesiredState.Equals(other.DesiredState) { return false }
  if !p.Settings.Equals(other.Settings) { return false }
  return true
}

func (p *JobUpdateInstructions) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateInstructions(%+v)", *p)
}

// Full definition of the job update.
// 
// Attributes:
//  - Summary: Update summary.
//  - Instructions: Update configuration.
type JobUpdate struct {
  Summary *JobUpdateSummary `thrift:"summary,1" db:"summary" json:"summary"`
  Instructions *JobUpdateInstructions `thrift:"instructions,2" db:"instructions" json:"instructions"`
}

func NewJobUpdate() *JobUpdate {
  return &JobUpdate{}
}

var JobUpdate_Summary_DEFAULT *JobUpdateSummary
func (p *JobUpdate) GetSummary() *JobUpdateSummary {
  if !p.IsSetSummary() {
    return JobUpdate_Summary_DEFAULT
  }
return p.Summary
}
var JobUpdate_Instructions_DEFAULT *JobUpdateInstructions
func (p *JobUpdate) GetInstructions() *JobUpdateInstructions {
  if !p.IsSetInstructions() {
    return JobUpdate_Instructions_DEFAULT
  }
return p.Instructions
}
func (p *JobUpdate) IsSetSummary() bool {
  return p.Summary != nil
}

func (p *JobUpdate) IsSetInstructions() bool {
  return p.Instructions != nil
}

func (p *JobUpdate) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdate)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Summary = &JobUpdateSummary{}
  if err := p.Summary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Summary), err)
  }
  return nil
}

func (p *JobUpdate)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Instructions = &JobUpdateInstructions{}
  if err := p.Instructions.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Instructions), err)
  }
  return nil
}

func (p *JobUpdate) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdate"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdate) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "summary", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:summary: ", p), err) }
  if err := p.Summary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Summary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:summary: ", p), err) }
  return err
}

func (p *JobUpdate) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instructions", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:instructions: ", p), err) }
  if err := p.Instructions.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Instructions), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:instructions: ", p), err) }
  return err
}

func (p *JobUpdate) Equals(other *JobUpdate) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Summary.Equals(other.Summary) { return false }
  if !p.Instructions.Equals(other.Instructions) { return false }
  return true
}

func (p *JobUpdate) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdate(%+v)", *p)
}

// Attributes:
//  - Update: Update definition.
//  - UpdateEvents: History for this update.
//  - InstanceEvents: History for the individual instances updated.
type JobUpdateDetails struct {
  Update *JobUpdate `thrift:"update,1" db:"update" json:"update"`
  UpdateEvents []*JobUpdateEvent `thrift:"updateEvents,2" db:"updateEvents" json:"updateEvents"`
  InstanceEvents []*JobInstanceUpdateEvent `thrift:"instanceEvents,3" db:"instanceEvents" json:"instanceEvents"`
}

func NewJobUpdateDetails() *JobUpdateDetails {
  return &JobUpdateDetails{}
}

var JobUpdateDetails_Update_DEFAULT *JobUpdate
func (p *JobUpdateDetails) GetUpdate() *JobUpdate {
  if !p.IsSetUpdate() {
    return JobUpdateDetails_Update_DEFAULT
  }
return p.Update
}

func (p *JobUpdateDetails) GetUpdateEvents() []*JobUpdateEvent {
  return p.UpdateEvents
}

func (p *JobUpdateDetails) GetInstanceEvents() []*JobInstanceUpdateEvent {
  return p.InstanceEvents
}
func (p *JobUpdateDetails) IsSetUpdate() bool {
  return p.Update != nil
}

func (p *JobUpdateDetails) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateDetails)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Update = &JobUpdate{}
  if err := p.Update.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Update), err)
  }
  return nil
}

func (p *JobUpdateDetails)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*JobUpdateEvent, 0, size)
  p.UpdateEvents =  tSlice
  for i := 0; i < size; i ++ {
    _elem58 := &JobUpdateEvent{}
    if err := _elem58.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem58), err)
    }
    p.UpdateEvents = append(p.UpdateEvents, _elem58)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *JobUpdateDetails)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*JobInstanceUpdateEvent, 0, size)
  p.InstanceEvents =  tSlice
  for i := 0; i < size; i ++ {
    _elem59 := &JobInstanceUpdateEvent{}
    if err := _elem59.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem59), err)
    }
    p.InstanceEvents = append(p.InstanceEvents, _elem59)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *JobUpdateDetails) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateDetails"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateDetails) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "update", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:update: ", p), err) }
  if err := p.Update.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Update), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:update: ", p), err) }
  return err
}

func (p *JobUpdateDetails) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateEvents", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updateEvents: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.UpdateEvents)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.UpdateEvents {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updateEvents: ", p), err) }
  return err
}

func (p *JobUpdateDetails) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instanceEvents", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:instanceEvents: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.InstanceEvents)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.InstanceEvents {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:instanceEvents: ", p), err) }
  return err
}

func (p *JobUpdateDetails) Equals(other *JobUpdateDetails) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Update.Equals(other.Update) { return false }
  if len(p.UpdateEvents) != len(other.UpdateEvents) { return false }
  for i, _tgt := range p.UpdateEvents {
    _src60 := other.UpdateEvents[i]
    if !_tgt.Equals(_src60) { return false }
  }
  if len(p.InstanceEvents) != len(other.InstanceEvents) { return false }
  for i, _tgt := range p.InstanceEvents {
    _src61 := other.InstanceEvents[i]
    if !_tgt.Equals(_src61) { return false }
  }
  return true
}

func (p *JobUpdateDetails) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateDetails(%+v)", *p)
}

// A request to update the following instances of an existing job. Used by startUpdate.
// 
// Attributes:
//  - TaskConfig: Desired TaskConfig to apply.
//  - InstanceCount: Desired number of instances of the task config.
//  - Settings: Update settings and limits.
//  - Metadata: Update metadata supplied by the client issuing the JobUpdateRequest.
type JobUpdateRequest struct {
  TaskConfig *TaskConfig `thrift:"taskConfig,1" db:"taskConfig" json:"taskConfig"`
  InstanceCount int32 `thrift:"instanceCount,2" db:"instanceCount" json:"instanceCount"`
  Settings *JobUpdateSettings `thrift:"settings,3" db:"settings" json:"settings"`
  Metadata []*Metadata `thrift:"metadata,4" db:"metadata" json:"metadata,omitempty"`
}

func NewJobUpdateRequest() *JobUpdateRequest {
  return &JobUpdateRequest{}
}

var JobUpdateRequest_TaskConfig_DEFAULT *TaskConfig
func (p *JobUpdateRequest) GetTaskConfig() *TaskConfig {
  if !p.IsSetTaskConfig() {
    return JobUpdateRequest_TaskConfig_DEFAULT
  }
return p.TaskConfig
}

func (p *JobUpdateRequest) GetInstanceCount() int32 {
  return p.InstanceCount
}
var JobUpdateRequest_Settings_DEFAULT *JobUpdateSettings
func (p *JobUpdateRequest) GetSettings() *JobUpdateSettings {
  if !p.IsSetSettings() {
    return JobUpdateRequest_Settings_DEFAULT
  }
return p.Settings
}
var JobUpdateRequest_Metadata_DEFAULT []*Metadata

func (p *JobUpdateRequest) GetMetadata() []*Metadata {
  return p.Metadata
}
func (p *JobUpdateRequest) IsSetTaskConfig() bool {
  return p.TaskConfig != nil
}

func (p *JobUpdateRequest) IsSetSettings() bool {
  return p.Settings != nil
}

func (p *JobUpdateRequest) IsSetMetadata() bool {
  return p.Metadata != nil
}

func (p *JobUpdateRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateRequest)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.TaskConfig = &TaskConfig{}
  if err := p.TaskConfig.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TaskConfig), err)
  }
  return nil
}

func (p *JobUpdateRequest)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.InstanceCount = v
}
  return nil
}

func (p *JobUpdateRequest)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Settings = &JobUpdateSettings{}
  if err := p.Settings.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Settings), err)
  }
  return nil
}

func (p *JobUpdateRequest)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*Metadata, 0, size)
  p.Metadata =  tSet
  for i := 0; i < size; i ++ {
    _elem62 := &Metadata{}
    if err := _elem62.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem62), err)
    }
    p.Metadata = append(p.Metadata, _elem62)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *JobUpdateRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateRequest"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskConfig", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:taskConfig: ", p), err) }
  if err := p.TaskConfig.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TaskConfig), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:taskConfig: ", p), err) }
  return err
}

func (p *JobUpdateRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instanceCount", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:instanceCount: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.InstanceCount)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.instanceCount (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:instanceCount: ", p), err) }
  return err
}

func (p *JobUpdateRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "settings", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:settings: ", p), err) }
  if err := p.Settings.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Settings), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:settings: ", p), err) }
  return err
}

func (p *JobUpdateRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMetadata() {
    if err := oprot.WriteFieldBegin(ctx, "metadata", thrift.SET, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:metadata: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Metadata)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.Metadata); i++ {
      for j := i+1; j<len(p.Metadata); j++ {
        if func(tgt, src *Metadata) bool {
          if !tgt.Equals(src) { return false }
          return true
        }(p.Metadata[i], p.Metadata[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Metadata))
        }
      }
    }
    for _, v := range p.Metadata {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:metadata: ", p), err) }
  }
  return err
}

func (p *JobUpdateRequest) Equals(other *JobUpdateRequest) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.TaskConfig.Equals(other.TaskConfig) { return false }
  if p.InstanceCount != other.InstanceCount { return false }
  if !p.Settings.Equals(other.Settings) { return false }
  if len(p.Metadata) != len(other.Metadata) { return false }
  for i, _tgt := range p.Metadata {
    _src63 := other.Metadata[i]
    if !_tgt.Equals(_src63) { return false }
  }
  return true
}

func (p *JobUpdateRequest) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateRequest(%+v)", *p)
}

// Contains a set of restrictions on matching job updates where all restrictions must be met
// (terms are AND'ed together).
// 
// Attributes:
//  - Role: Job role.
//  - Key: Unique identifier for a job update.
//  - JobKey: Job key.
//  - User: User who created the update.
//  - UpdateStatuses: Set of update statuses.
//  - Offset: Offset to serve data from. Used by pagination.
//  - Limit: Number or records to serve. Used by pagination.
type JobUpdateQuery struct {
  // unused field # 1
  Role *string `thrift:"role,2" db:"role" json:"role,omitempty"`
  JobKey *JobKey `thrift:"jobKey,3" db:"jobKey" json:"jobKey,omitempty"`
  User *string `thrift:"user,4" db:"user" json:"user,omitempty"`
  UpdateStatuses []JobUpdateStatus `thrift:"updateStatuses,5" db:"updateStatuses" json:"updateStatuses,omitempty"`
  Offset int32 `thrift:"offset,6" db:"offset" json:"offset"`
  Limit int32 `thrift:"limit,7" db:"limit" json:"limit"`
  Key *JobUpdateKey `thrift:"key,8" db:"key" json:"key,omitempty"`
}

func NewJobUpdateQuery() *JobUpdateQuery {
  return &JobUpdateQuery{}
}

var JobUpdateQuery_Role_DEFAULT string
func (p *JobUpdateQuery) GetRole() string {
  if !p.IsSetRole() {
    return JobUpdateQuery_Role_DEFAULT
  }
return *p.Role
}
var JobUpdateQuery_Key_DEFAULT *JobUpdateKey
func (p *JobUpdateQuery) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return JobUpdateQuery_Key_DEFAULT
  }
return p.Key
}
var JobUpdateQuery_JobKey_DEFAULT *JobKey
func (p *JobUpdateQuery) GetJobKey() *JobKey {
  if !p.IsSetJobKey() {
    return JobUpdateQuery_JobKey_DEFAULT
  }
return p.JobKey
}
var JobUpdateQuery_User_DEFAULT string
func (p *JobUpdateQuery) GetUser() string {
  if !p.IsSetUser() {
    return JobUpdateQuery_User_DEFAULT
  }
return *p.User
}
var JobUpdateQuery_UpdateStatuses_DEFAULT []JobUpdateStatus

func (p *JobUpdateQuery) GetUpdateStatuses() []JobUpdateStatus {
  return p.UpdateStatuses
}

func (p *JobUpdateQuery) GetOffset() int32 {
  return p.Offset
}

func (p *JobUpdateQuery) GetLimit() int32 {
  return p.Limit
}
func (p *JobUpdateQuery) IsSetRole() bool {
  return p.Role != nil
}

func (p *JobUpdateQuery) IsSetKey() bool {
  return p.Key != nil
}

func (p *JobUpdateQuery) IsSetJobKey() bool {
  return p.JobKey != nil
}

func (p *JobUpdateQuery) IsSetUser() bool {
  return p.User != nil
}

func (p *JobUpdateQuery) IsSetUpdateStatuses() bool {
  return p.UpdateStatuses != nil
}

func (p *JobUpdateQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobUpdateQuery)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Role = &v
}
  return nil
}

func (p *JobUpdateQuery)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *JobUpdateQuery)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.JobKey = &JobKey{}
  if err := p.JobKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.JobKey), err)
  }
  return nil
}

func (p *JobUpdateQuery)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.User = &v
}
  return nil
}

func (p *JobUpdateQuery)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]JobUpdateStatus, 0, size)
  p.UpdateStatuses =  tSet
  for i := 0; i < size; i ++ {
var _elem64 JobUpdateStatus
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := JobUpdateStatus(v)
    _elem64 = temp
}
    p.UpdateStatuses = append(p.UpdateStatuses, _elem64)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *JobUpdateQuery)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Offset = v
}
  return nil
}

func (p *JobUpdateQuery)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.Limit = v
}
  return nil
}

func (p *JobUpdateQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobUpdateQuery"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobUpdateQuery) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRole() {
    if err := oprot.WriteFieldBegin(ctx, "role", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:role: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.Role)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.role (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:role: ", p), err) }
  }
  return err
}

func (p *JobUpdateQuery) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetJobKey() {
    if err := oprot.WriteFieldBegin(ctx, "jobKey", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:jobKey: ", p), err) }
    if err := p.JobKey.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.JobKey), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:jobKey: ", p), err) }
  }
  return err
}

func (p *JobUpdateQuery) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUser() {
    if err := oprot.WriteFieldBegin(ctx, "user", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:user: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.User)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.user (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:user: ", p), err) }
  }
  return err
}

func (p *JobUpdateQuery) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateStatuses() {
    if err := oprot.WriteFieldBegin(ctx, "updateStatuses", thrift.SET, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:updateStatuses: ", p), err) }
    if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.UpdateStatuses)); err != nil {
      return thrift.PrependError("error writing set begin: ", err)
    }
    for i := 0; i<len(p.UpdateStatuses); i++ {
      for j := i+1; j<len(p.UpdateStatuses); j++ {
        if func(tgt, src JobUpdateStatus) bool {
          if tgt != src { return false }
          return true
        }(p.UpdateStatuses[i], p.UpdateStatuses[j]) {
          return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.UpdateStatuses))
        }
      }
    }
    for _, v := range p.UpdateStatuses {
      if err := oprot.WriteI32(ctx, int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteSetEnd(ctx); err != nil {
      return thrift.PrependError("error writing set end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:updateStatuses: ", p), err) }
  }
  return err
}

func (p *JobUpdateQuery) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I32, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:offset: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Offset)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.offset (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:offset: ", p), err) }
  return err
}

func (p *JobUpdateQuery) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I32, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:limit: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Limit)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.limit (7) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:limit: ", p), err) }
  return err
}

func (p *JobUpdateQuery) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetKey() {
    if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:key: ", p), err) }
    if err := p.Key.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:key: ", p), err) }
  }
  return err
}

func (p *JobUpdateQuery) Equals(other *JobUpdateQuery) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Role != other.Role {
    if p.Role == nil || other.Role == nil {
      return false
    }
    if (*p.Role) != (*other.Role) { return false }
  }
  if !p.JobKey.Equals(other.JobKey) { return false }
  if p.User != other.User {
    if p.User == nil || other.User == nil {
      return false
    }
    if (*p.User) != (*other.User) { return false }
  }
  if len(p.UpdateStatuses) != len(other.UpdateStatuses) { return false }
  for i, _tgt := range p.UpdateStatuses {
    _src65 := other.UpdateStatuses[i]
    if _tgt != _src65 { return false }
  }
  if p.Offset != other.Offset { return false }
  if p.Limit != other.Limit { return false }
  if !p.Key.Equals(other.Key) { return false }
  return true
}

func (p *JobUpdateQuery) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobUpdateQuery(%+v)", *p)
}

// Attributes:
//  - Host
//  - DefaultSlaPolicy
//  - TimeoutSecs
//  - CreatedTimestampMs
type HostMaintenanceRequest struct {
  Host string `thrift:"host,1" db:"host" json:"host"`
  DefaultSlaPolicy *SlaPolicy `thrift:"defaultSlaPolicy,2" db:"defaultSlaPolicy" json:"defaultSlaPolicy"`
  TimeoutSecs int64 `thrift:"timeoutSecs,3" db:"timeoutSecs" json:"timeoutSecs"`
  CreatedTimestampMs int64 `thrift:"createdTimestampMs,4" db:"createdTimestampMs" json:"createdTimestampMs"`
}

func NewHostMaintenanceRequest() *HostMaintenanceRequest {
  return &HostMaintenanceRequest{}
}


func (p *HostMaintenanceRequest) GetHost() string {
  return p.Host
}
var HostMaintenanceRequest_DefaultSlaPolicy_DEFAULT *SlaPolicy
func (p *HostMaintenanceRequest) GetDefaultSlaPolicy() *SlaPolicy {
  if !p.IsSetDefaultSlaPolicy() {
    return HostMaintenanceRequest_DefaultSlaPolicy_DEFAULT
  }
return p.DefaultSlaPolicy
}

func (p *HostMaintenanceRequest) GetTimeoutSecs() int64 {
  return p.TimeoutSecs
}

func (p *HostMaintenanceRequest) GetCreatedTimestampMs() int64 {
  return p.CreatedTimestampMs
}
func (p *HostMaintenanceRequest) IsSetDefaultSlaPolicy() bool {
  return p.DefaultSlaPolicy != nil
}

func (p *HostMaintenanceRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *HostMaintenanceRequest)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Host = v
}
  return nil
}

func (p *HostMaintenanceRequest)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.DefaultSlaPolicy = &SlaPolicy{}
  if err := p.DefaultSlaPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DefaultSlaPolicy), err)
  }
  return nil
}

func (p *HostMaintenanceRequest)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.TimeoutSecs = v
}
  return nil
}

func (p *HostMaintenanceRequest)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.CreatedTimestampMs = v
}
  return nil
}

func (p *HostMaintenanceRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "HostMaintenanceRequest"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *HostMaintenanceRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "host", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:host: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Host)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.host (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:host: ", p), err) }
  return err
}

func (p *HostMaintenanceRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "defaultSlaPolicy", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:defaultSlaPolicy: ", p), err) }
  if err := p.DefaultSlaPolicy.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DefaultSlaPolicy), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:defaultSlaPolicy: ", p), err) }
  return err
}

func (p *HostMaintenanceRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timeoutSecs", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timeoutSecs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TimeoutSecs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timeoutSecs (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timeoutSecs: ", p), err) }
  return err
}

func (p *HostMaintenanceRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "createdTimestampMs", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:createdTimestampMs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.CreatedTimestampMs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.createdTimestampMs (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:createdTimestampMs: ", p), err) }
  return err
}

func (p *HostMaintenanceRequest) Equals(other *HostMaintenanceRequest) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Host != other.Host { return false }
  if !p.DefaultSlaPolicy.Equals(other.DefaultSlaPolicy) { return false }
  if p.TimeoutSecs != other.TimeoutSecs { return false }
  if p.CreatedTimestampMs != other.CreatedTimestampMs { return false }
  return true
}

func (p *HostMaintenanceRequest) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("HostMaintenanceRequest(%+v)", *p)
}

// Attributes:
//  - Backups
type ListBackupsResult_ struct {
  Backups []string `thrift:"backups,1" db:"backups" json:"backups"`
}

func NewListBackupsResult_() *ListBackupsResult_ {
  return &ListBackupsResult_{}
}


func (p *ListBackupsResult_) GetBackups() []string {
  return p.Backups
}
func (p *ListBackupsResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ListBackupsResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]string, 0, size)
  p.Backups =  tSet
  for i := 0; i < size; i ++ {
var _elem66 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem66 = v
}
    p.Backups = append(p.Backups, _elem66)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *ListBackupsResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ListBackupsResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ListBackupsResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "backups", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:backups: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRING, len(p.Backups)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Backups); i++ {
    for j := i+1; j<len(p.Backups); j++ {
      if func(tgt, src string) bool {
        if tgt != src { return false }
        return true
      }(p.Backups[i], p.Backups[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Backups))
      }
    }
  }
  for _, v := range p.Backups {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:backups: ", p), err) }
  return err
}

func (p *ListBackupsResult_) Equals(other *ListBackupsResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Backups) != len(other.Backups) { return false }
  for i, _tgt := range p.Backups {
    _src67 := other.Backups[i]
    if _tgt != _src67 { return false }
  }
  return true
}

func (p *ListBackupsResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ListBackupsResult_(%+v)", *p)
}

// Attributes:
//  - Statuses
type StartMaintenanceResult_ struct {
  Statuses []*HostStatus `thrift:"statuses,1" db:"statuses" json:"statuses"`
}

func NewStartMaintenanceResult_() *StartMaintenanceResult_ {
  return &StartMaintenanceResult_{}
}


func (p *StartMaintenanceResult_) GetStatuses() []*HostStatus {
  return p.Statuses
}
func (p *StartMaintenanceResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *StartMaintenanceResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*HostStatus, 0, size)
  p.Statuses =  tSet
  for i := 0; i < size; i ++ {
    _elem68 := &HostStatus{}
    if err := _elem68.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem68), err)
    }
    p.Statuses = append(p.Statuses, _elem68)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *StartMaintenanceResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "StartMaintenanceResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *StartMaintenanceResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "statuses", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:statuses: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Statuses)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Statuses); i++ {
    for j := i+1; j<len(p.Statuses); j++ {
      if func(tgt, src *HostStatus) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Statuses[i], p.Statuses[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Statuses))
      }
    }
  }
  for _, v := range p.Statuses {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:statuses: ", p), err) }
  return err
}

func (p *StartMaintenanceResult_) Equals(other *StartMaintenanceResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Statuses) != len(other.Statuses) { return false }
  for i, _tgt := range p.Statuses {
    _src69 := other.Statuses[i]
    if !_tgt.Equals(_src69) { return false }
  }
  return true
}

func (p *StartMaintenanceResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("StartMaintenanceResult_(%+v)", *p)
}

// Attributes:
//  - Statuses
type DrainHostsResult_ struct {
  Statuses []*HostStatus `thrift:"statuses,1" db:"statuses" json:"statuses"`
}

func NewDrainHostsResult_() *DrainHostsResult_ {
  return &DrainHostsResult_{}
}


func (p *DrainHostsResult_) GetStatuses() []*HostStatus {
  return p.Statuses
}
func (p *DrainHostsResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *DrainHostsResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*HostStatus, 0, size)
  p.Statuses =  tSet
  for i := 0; i < size; i ++ {
    _elem70 := &HostStatus{}
    if err := _elem70.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem70), err)
    }
    p.Statuses = append(p.Statuses, _elem70)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *DrainHostsResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "DrainHostsResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *DrainHostsResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "statuses", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:statuses: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Statuses)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Statuses); i++ {
    for j := i+1; j<len(p.Statuses); j++ {
      if func(tgt, src *HostStatus) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Statuses[i], p.Statuses[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Statuses))
      }
    }
  }
  for _, v := range p.Statuses {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:statuses: ", p), err) }
  return err
}

func (p *DrainHostsResult_) Equals(other *DrainHostsResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Statuses) != len(other.Statuses) { return false }
  for i, _tgt := range p.Statuses {
    _src71 := other.Statuses[i]
    if !_tgt.Equals(_src71) { return false }
  }
  return true
}

func (p *DrainHostsResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("DrainHostsResult_(%+v)", *p)
}

// Attributes:
//  - Tasks
type QueryRecoveryResult_ struct {
  Tasks []*ScheduledTask `thrift:"tasks,1" db:"tasks" json:"tasks"`
}

func NewQueryRecoveryResult_() *QueryRecoveryResult_ {
  return &QueryRecoveryResult_{}
}


func (p *QueryRecoveryResult_) GetTasks() []*ScheduledTask {
  return p.Tasks
}
func (p *QueryRecoveryResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *QueryRecoveryResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*ScheduledTask, 0, size)
  p.Tasks =  tSet
  for i := 0; i < size; i ++ {
    _elem72 := &ScheduledTask{}
    if err := _elem72.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem72), err)
    }
    p.Tasks = append(p.Tasks, _elem72)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *QueryRecoveryResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "QueryRecoveryResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *QueryRecoveryResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tasks", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tasks: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Tasks)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Tasks); i++ {
    for j := i+1; j<len(p.Tasks); j++ {
      if func(tgt, src *ScheduledTask) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Tasks[i], p.Tasks[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Tasks))
      }
    }
  }
  for _, v := range p.Tasks {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tasks: ", p), err) }
  return err
}

func (p *QueryRecoveryResult_) Equals(other *QueryRecoveryResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Tasks) != len(other.Tasks) { return false }
  for i, _tgt := range p.Tasks {
    _src73 := other.Tasks[i]
    if !_tgt.Equals(_src73) { return false }
  }
  return true
}

func (p *QueryRecoveryResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("QueryRecoveryResult_(%+v)", *p)
}

// Attributes:
//  - Statuses
type MaintenanceStatusResult_ struct {
  Statuses []*HostStatus `thrift:"statuses,1" db:"statuses" json:"statuses"`
}

func NewMaintenanceStatusResult_() *MaintenanceStatusResult_ {
  return &MaintenanceStatusResult_{}
}


func (p *MaintenanceStatusResult_) GetStatuses() []*HostStatus {
  return p.Statuses
}
func (p *MaintenanceStatusResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *MaintenanceStatusResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*HostStatus, 0, size)
  p.Statuses =  tSet
  for i := 0; i < size; i ++ {
    _elem74 := &HostStatus{}
    if err := _elem74.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem74), err)
    }
    p.Statuses = append(p.Statuses, _elem74)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *MaintenanceStatusResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "MaintenanceStatusResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *MaintenanceStatusResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "statuses", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:statuses: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Statuses)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Statuses); i++ {
    for j := i+1; j<len(p.Statuses); j++ {
      if func(tgt, src *HostStatus) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Statuses[i], p.Statuses[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Statuses))
      }
    }
  }
  for _, v := range p.Statuses {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:statuses: ", p), err) }
  return err
}

func (p *MaintenanceStatusResult_) Equals(other *MaintenanceStatusResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Statuses) != len(other.Statuses) { return false }
  for i, _tgt := range p.Statuses {
    _src75 := other.Statuses[i]
    if !_tgt.Equals(_src75) { return false }
  }
  return true
}

func (p *MaintenanceStatusResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("MaintenanceStatusResult_(%+v)", *p)
}

// Attributes:
//  - Statuses
type EndMaintenanceResult_ struct {
  Statuses []*HostStatus `thrift:"statuses,1" db:"statuses" json:"statuses"`
}

func NewEndMaintenanceResult_() *EndMaintenanceResult_ {
  return &EndMaintenanceResult_{}
}


func (p *EndMaintenanceResult_) GetStatuses() []*HostStatus {
  return p.Statuses
}
func (p *EndMaintenanceResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *EndMaintenanceResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*HostStatus, 0, size)
  p.Statuses =  tSet
  for i := 0; i < size; i ++ {
    _elem76 := &HostStatus{}
    if err := _elem76.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem76), err)
    }
    p.Statuses = append(p.Statuses, _elem76)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *EndMaintenanceResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "EndMaintenanceResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EndMaintenanceResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "statuses", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:statuses: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Statuses)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Statuses); i++ {
    for j := i+1; j<len(p.Statuses); j++ {
      if func(tgt, src *HostStatus) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Statuses[i], p.Statuses[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Statuses))
      }
    }
  }
  for _, v := range p.Statuses {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:statuses: ", p), err) }
  return err
}

func (p *EndMaintenanceResult_) Equals(other *EndMaintenanceResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Statuses) != len(other.Statuses) { return false }
  for i, _tgt := range p.Statuses {
    _src77 := other.Statuses[i]
    if !_tgt.Equals(_src77) { return false }
  }
  return true
}

func (p *EndMaintenanceResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EndMaintenanceResult_(%+v)", *p)
}

// Attributes:
//  - Summaries
type RoleSummaryResult_ struct {
  Summaries []*RoleSummary `thrift:"summaries,1" db:"summaries" json:"summaries"`
}

func NewRoleSummaryResult_() *RoleSummaryResult_ {
  return &RoleSummaryResult_{}
}


func (p *RoleSummaryResult_) GetSummaries() []*RoleSummary {
  return p.Summaries
}
func (p *RoleSummaryResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *RoleSummaryResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*RoleSummary, 0, size)
  p.Summaries =  tSet
  for i := 0; i < size; i ++ {
    _elem78 := &RoleSummary{}
    if err := _elem78.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem78), err)
    }
    p.Summaries = append(p.Summaries, _elem78)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *RoleSummaryResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "RoleSummaryResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *RoleSummaryResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "summaries", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:summaries: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Summaries)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Summaries); i++ {
    for j := i+1; j<len(p.Summaries); j++ {
      if func(tgt, src *RoleSummary) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Summaries[i], p.Summaries[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Summaries))
      }
    }
  }
  for _, v := range p.Summaries {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:summaries: ", p), err) }
  return err
}

func (p *RoleSummaryResult_) Equals(other *RoleSummaryResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Summaries) != len(other.Summaries) { return false }
  for i, _tgt := range p.Summaries {
    _src79 := other.Summaries[i]
    if !_tgt.Equals(_src79) { return false }
  }
  return true
}

func (p *RoleSummaryResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("RoleSummaryResult_(%+v)", *p)
}

// Attributes:
//  - Summaries
type JobSummaryResult_ struct {
  Summaries []*JobSummary `thrift:"summaries,1" db:"summaries" json:"summaries"`
}

func NewJobSummaryResult_() *JobSummaryResult_ {
  return &JobSummaryResult_{}
}


func (p *JobSummaryResult_) GetSummaries() []*JobSummary {
  return p.Summaries
}
func (p *JobSummaryResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *JobSummaryResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*JobSummary, 0, size)
  p.Summaries =  tSet
  for i := 0; i < size; i ++ {
    _elem80 := &JobSummary{}
    if err := _elem80.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem80), err)
    }
    p.Summaries = append(p.Summaries, _elem80)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *JobSummaryResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "JobSummaryResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *JobSummaryResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "summaries", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:summaries: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Summaries)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Summaries); i++ {
    for j := i+1; j<len(p.Summaries); j++ {
      if func(tgt, src *JobSummary) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Summaries[i], p.Summaries[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Summaries))
      }
    }
  }
  for _, v := range p.Summaries {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:summaries: ", p), err) }
  return err
}

func (p *JobSummaryResult_) Equals(other *JobSummaryResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Summaries) != len(other.Summaries) { return false }
  for i, _tgt := range p.Summaries {
    _src81 := other.Summaries[i]
    if !_tgt.Equals(_src81) { return false }
  }
  return true
}

func (p *JobSummaryResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("JobSummaryResult_(%+v)", *p)
}

// Attributes:
//  - Summary
type ConfigSummaryResult_ struct {
  Summary *ConfigSummary `thrift:"summary,1" db:"summary" json:"summary"`
}

func NewConfigSummaryResult_() *ConfigSummaryResult_ {
  return &ConfigSummaryResult_{}
}

var ConfigSummaryResult__Summary_DEFAULT *ConfigSummary
func (p *ConfigSummaryResult_) GetSummary() *ConfigSummary {
  if !p.IsSetSummary() {
    return ConfigSummaryResult__Summary_DEFAULT
  }
return p.Summary
}
func (p *ConfigSummaryResult_) IsSetSummary() bool {
  return p.Summary != nil
}

func (p *ConfigSummaryResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ConfigSummaryResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Summary = &ConfigSummary{}
  if err := p.Summary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Summary), err)
  }
  return nil
}

func (p *ConfigSummaryResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ConfigSummaryResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ConfigSummaryResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "summary", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:summary: ", p), err) }
  if err := p.Summary.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Summary), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:summary: ", p), err) }
  return err
}

func (p *ConfigSummaryResult_) Equals(other *ConfigSummaryResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Summary.Equals(other.Summary) { return false }
  return true
}

func (p *ConfigSummaryResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ConfigSummaryResult_(%+v)", *p)
}

// Attributes:
//  - Reasons
type GetPendingReasonResult_ struct {
  Reasons []*PendingReason `thrift:"reasons,1" db:"reasons" json:"reasons"`
}

func NewGetPendingReasonResult_() *GetPendingReasonResult_ {
  return &GetPendingReasonResult_{}
}


func (p *GetPendingReasonResult_) GetReasons() []*PendingReason {
  return p.Reasons
}
func (p *GetPendingReasonResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetPendingReasonResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*PendingReason, 0, size)
  p.Reasons =  tSet
  for i := 0; i < size; i ++ {
    _elem82 := &PendingReason{}
    if err := _elem82.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem82), err)
    }
    p.Reasons = append(p.Reasons, _elem82)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetPendingReasonResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetPendingReasonResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetPendingReasonResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "reasons", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:reasons: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Reasons)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Reasons); i++ {
    for j := i+1; j<len(p.Reasons); j++ {
      if func(tgt, src *PendingReason) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Reasons[i], p.Reasons[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Reasons))
      }
    }
  }
  for _, v := range p.Reasons {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:reasons: ", p), err) }
  return err
}

func (p *GetPendingReasonResult_) Equals(other *GetPendingReasonResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Reasons) != len(other.Reasons) { return false }
  for i, _tgt := range p.Reasons {
    _src83 := other.Reasons[i]
    if !_tgt.Equals(_src83) { return false }
  }
  return true
}

func (p *GetPendingReasonResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetPendingReasonResult_(%+v)", *p)
}

// Result of the startUpdate call.
// 
// Attributes:
//  - Key: Unique identifier for the job update.
//  - UpdateSummary: Summary of the update that is in progress for the given JobKey.
type StartJobUpdateResult_ struct {
  Key *JobUpdateKey `thrift:"key,1" db:"key" json:"key"`
  UpdateSummary *JobUpdateSummary `thrift:"updateSummary,2" db:"updateSummary" json:"updateSummary,omitempty"`
}

func NewStartJobUpdateResult_() *StartJobUpdateResult_ {
  return &StartJobUpdateResult_{}
}

var StartJobUpdateResult__Key_DEFAULT *JobUpdateKey
func (p *StartJobUpdateResult_) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return StartJobUpdateResult__Key_DEFAULT
  }
return p.Key
}
var StartJobUpdateResult__UpdateSummary_DEFAULT *JobUpdateSummary
func (p *StartJobUpdateResult_) GetUpdateSummary() *JobUpdateSummary {
  if !p.IsSetUpdateSummary() {
    return StartJobUpdateResult__UpdateSummary_DEFAULT
  }
return p.UpdateSummary
}
func (p *StartJobUpdateResult_) IsSetKey() bool {
  return p.Key != nil
}

func (p *StartJobUpdateResult_) IsSetUpdateSummary() bool {
  return p.UpdateSummary != nil
}

func (p *StartJobUpdateResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *StartJobUpdateResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *StartJobUpdateResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.UpdateSummary = &JobUpdateSummary{}
  if err := p.UpdateSummary.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UpdateSummary), err)
  }
  return nil
}

func (p *StartJobUpdateResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "StartJobUpdateResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *StartJobUpdateResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *StartJobUpdateResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateSummary() {
    if err := oprot.WriteFieldBegin(ctx, "updateSummary", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updateSummary: ", p), err) }
    if err := p.UpdateSummary.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UpdateSummary), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updateSummary: ", p), err) }
  }
  return err
}

func (p *StartJobUpdateResult_) Equals(other *StartJobUpdateResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Key.Equals(other.Key) { return false }
  if !p.UpdateSummary.Equals(other.UpdateSummary) { return false }
  return true
}

func (p *StartJobUpdateResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("StartJobUpdateResult_(%+v)", *p)
}

// Result of the getJobUpdateSummaries call.
// 
// Attributes:
//  - UpdateSummaries
type GetJobUpdateSummariesResult_ struct {
  UpdateSummaries []*JobUpdateSummary `thrift:"updateSummaries,1" db:"updateSummaries" json:"updateSummaries"`
}

func NewGetJobUpdateSummariesResult_() *GetJobUpdateSummariesResult_ {
  return &GetJobUpdateSummariesResult_{}
}


func (p *GetJobUpdateSummariesResult_) GetUpdateSummaries() []*JobUpdateSummary {
  return p.UpdateSummaries
}
func (p *GetJobUpdateSummariesResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetJobUpdateSummariesResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*JobUpdateSummary, 0, size)
  p.UpdateSummaries =  tSlice
  for i := 0; i < size; i ++ {
    _elem84 := &JobUpdateSummary{}
    if err := _elem84.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem84), err)
    }
    p.UpdateSummaries = append(p.UpdateSummaries, _elem84)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *GetJobUpdateSummariesResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetJobUpdateSummariesResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetJobUpdateSummariesResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updateSummaries", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:updateSummaries: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.UpdateSummaries)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.UpdateSummaries {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:updateSummaries: ", p), err) }
  return err
}

func (p *GetJobUpdateSummariesResult_) Equals(other *GetJobUpdateSummariesResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.UpdateSummaries) != len(other.UpdateSummaries) { return false }
  for i, _tgt := range p.UpdateSummaries {
    _src85 := other.UpdateSummaries[i]
    if !_tgt.Equals(_src85) { return false }
  }
  return true
}

func (p *GetJobUpdateSummariesResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetJobUpdateSummariesResult_(%+v)", *p)
}

// Result of the getJobUpdateDetails call.
// 
// Attributes:
//  - Details
//  - DetailsList
type GetJobUpdateDetailsResult_ struct {
  Details *JobUpdateDetails `thrift:"details,1" db:"details" json:"details"`
  DetailsList []*JobUpdateDetails `thrift:"detailsList,2" db:"detailsList" json:"detailsList"`
}

func NewGetJobUpdateDetailsResult_() *GetJobUpdateDetailsResult_ {
  return &GetJobUpdateDetailsResult_{}
}

var GetJobUpdateDetailsResult__Details_DEFAULT *JobUpdateDetails
func (p *GetJobUpdateDetailsResult_) GetDetails() *JobUpdateDetails {
  if !p.IsSetDetails() {
    return GetJobUpdateDetailsResult__Details_DEFAULT
  }
return p.Details
}

func (p *GetJobUpdateDetailsResult_) GetDetailsList() []*JobUpdateDetails {
  return p.DetailsList
}
func (p *GetJobUpdateDetailsResult_) IsSetDetails() bool {
  return p.Details != nil
}

func (p *GetJobUpdateDetailsResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetJobUpdateDetailsResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Details = &JobUpdateDetails{}
  if err := p.Details.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Details), err)
  }
  return nil
}

func (p *GetJobUpdateDetailsResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*JobUpdateDetails, 0, size)
  p.DetailsList =  tSlice
  for i := 0; i < size; i ++ {
    _elem86 := &JobUpdateDetails{}
    if err := _elem86.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem86), err)
    }
    p.DetailsList = append(p.DetailsList, _elem86)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *GetJobUpdateDetailsResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetJobUpdateDetailsResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetJobUpdateDetailsResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "details", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:details: ", p), err) }
  if err := p.Details.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Details), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:details: ", p), err) }
  return err
}

func (p *GetJobUpdateDetailsResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "detailsList", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:detailsList: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.DetailsList)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.DetailsList {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:detailsList: ", p), err) }
  return err
}

func (p *GetJobUpdateDetailsResult_) Equals(other *GetJobUpdateDetailsResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Details.Equals(other.Details) { return false }
  if len(p.DetailsList) != len(other.DetailsList) { return false }
  for i, _tgt := range p.DetailsList {
    _src87 := other.DetailsList[i]
    if !_tgt.Equals(_src87) { return false }
  }
  return true
}

func (p *GetJobUpdateDetailsResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetJobUpdateDetailsResult_(%+v)", *p)
}

// Result of the pulseJobUpdate call.
// 
// Attributes:
//  - Status
type PulseJobUpdateResult_ struct {
  Status JobUpdatePulseStatus `thrift:"status,1" db:"status" json:"status"`
}

func NewPulseJobUpdateResult_() *PulseJobUpdateResult_ {
  return &PulseJobUpdateResult_{}
}


func (p *PulseJobUpdateResult_) GetStatus() JobUpdatePulseStatus {
  return p.Status
}
func (p *PulseJobUpdateResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *PulseJobUpdateResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := JobUpdatePulseStatus(v)
  p.Status = temp
}
  return nil
}

func (p *PulseJobUpdateResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "PulseJobUpdateResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *PulseJobUpdateResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.status (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:status: ", p), err) }
  return err
}

func (p *PulseJobUpdateResult_) Equals(other *PulseJobUpdateResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Status != other.Status { return false }
  return true
}

func (p *PulseJobUpdateResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("PulseJobUpdateResult_(%+v)", *p)
}

// Attributes:
//  - Add: Instance addition diff details.
//  - Remove: Instance removal diff details.
//  - Update: Instance update diff details.
//  - Unchanged: Instances unchanged by the update.
type GetJobUpdateDiffResult_ struct {
  Add []*ConfigGroup `thrift:"add,1" db:"add" json:"add"`
  Remove []*ConfigGroup `thrift:"remove,2" db:"remove" json:"remove"`
  Update []*ConfigGroup `thrift:"update,3" db:"update" json:"update"`
  Unchanged []*ConfigGroup `thrift:"unchanged,4" db:"unchanged" json:"unchanged"`
}

func NewGetJobUpdateDiffResult_() *GetJobUpdateDiffResult_ {
  return &GetJobUpdateDiffResult_{}
}


func (p *GetJobUpdateDiffResult_) GetAdd() []*ConfigGroup {
  return p.Add
}

func (p *GetJobUpdateDiffResult_) GetRemove() []*ConfigGroup {
  return p.Remove
}

func (p *GetJobUpdateDiffResult_) GetUpdate() []*ConfigGroup {
  return p.Update
}

func (p *GetJobUpdateDiffResult_) GetUnchanged() []*ConfigGroup {
  return p.Unchanged
}
func (p *GetJobUpdateDiffResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetJobUpdateDiffResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*ConfigGroup, 0, size)
  p.Add =  tSet
  for i := 0; i < size; i ++ {
    _elem88 := &ConfigGroup{}
    if err := _elem88.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem88), err)
    }
    p.Add = append(p.Add, _elem88)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetJobUpdateDiffResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*ConfigGroup, 0, size)
  p.Remove =  tSet
  for i := 0; i < size; i ++ {
    _elem89 := &ConfigGroup{}
    if err := _elem89.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem89), err)
    }
    p.Remove = append(p.Remove, _elem89)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetJobUpdateDiffResult_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*ConfigGroup, 0, size)
  p.Update =  tSet
  for i := 0; i < size; i ++ {
    _elem90 := &ConfigGroup{}
    if err := _elem90.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem90), err)
    }
    p.Update = append(p.Update, _elem90)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetJobUpdateDiffResult_)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*ConfigGroup, 0, size)
  p.Unchanged =  tSet
  for i := 0; i < size; i ++ {
    _elem91 := &ConfigGroup{}
    if err := _elem91.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem91), err)
    }
    p.Unchanged = append(p.Unchanged, _elem91)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetJobUpdateDiffResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetJobUpdateDiffResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetJobUpdateDiffResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "add", thrift.SET, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:add: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Add)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Add); i++ {
    for j := i+1; j<len(p.Add); j++ {
      if func(tgt, src *ConfigGroup) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Add[i], p.Add[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Add))
      }
    }
  }
  for _, v := range p.Add {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:add: ", p), err) }
  return err
}

func (p *GetJobUpdateDiffResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "remove", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:remove: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Remove)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Remove); i++ {
    for j := i+1; j<len(p.Remove); j++ {
      if func(tgt, src *ConfigGroup) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Remove[i], p.Remove[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Remove))
      }
    }
  }
  for _, v := range p.Remove {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:remove: ", p), err) }
  return err
}

func (p *GetJobUpdateDiffResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "update", thrift.SET, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:update: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Update)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Update); i++ {
    for j := i+1; j<len(p.Update); j++ {
      if func(tgt, src *ConfigGroup) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Update[i], p.Update[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Update))
      }
    }
  }
  for _, v := range p.Update {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:update: ", p), err) }
  return err
}

func (p *GetJobUpdateDiffResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "unchanged", thrift.SET, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:unchanged: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Unchanged)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Unchanged); i++ {
    for j := i+1; j<len(p.Unchanged); j++ {
      if func(tgt, src *ConfigGroup) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Unchanged[i], p.Unchanged[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Unchanged))
      }
    }
  }
  for _, v := range p.Unchanged {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:unchanged: ", p), err) }
  return err
}

func (p *GetJobUpdateDiffResult_) Equals(other *GetJobUpdateDiffResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Add) != len(other.Add) { return false }
  for i, _tgt := range p.Add {
    _src92 := other.Add[i]
    if !_tgt.Equals(_src92) { return false }
  }
  if len(p.Remove) != len(other.Remove) { return false }
  for i, _tgt := range p.Remove {
    _src93 := other.Remove[i]
    if !_tgt.Equals(_src93) { return false }
  }
  if len(p.Update) != len(other.Update) { return false }
  for i, _tgt := range p.Update {
    _src94 := other.Update[i]
    if !_tgt.Equals(_src94) { return false }
  }
  if len(p.Unchanged) != len(other.Unchanged) { return false }
  for i, _tgt := range p.Unchanged {
    _src95 := other.Unchanged[i]
    if !_tgt.Equals(_src95) { return false }
  }
  return true
}

func (p *GetJobUpdateDiffResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetJobUpdateDiffResult_(%+v)", *p)
}

// Tier information.
// 
// Attributes:
//  - Name: Name of tier.
//  - Settings: Tier attributes.
type TierConfig struct {
  Name string `thrift:"name,1" db:"name" json:"name"`
  Settings map[string]string `thrift:"settings,2" db:"settings" json:"settings"`
}

func NewTierConfig() *TierConfig {
  return &TierConfig{}
}


func (p *TierConfig) GetName() string {
  return p.Name
}

func (p *TierConfig) GetSettings() map[string]string {
  return p.Settings
}
func (p *TierConfig) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *TierConfig)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Name = v
}
  return nil
}

func (p *TierConfig)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]string, size)
  p.Settings =  tMap
  for i := 0; i < size; i ++ {
var _key96 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key96 = v
}
var _val97 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _val97 = v
}
    p.Settings[_key96] = _val97
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *TierConfig) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "TierConfig"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *TierConfig) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err) }
  return err
}

func (p *TierConfig) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "settings", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:settings: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Settings)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Settings {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:settings: ", p), err) }
  return err
}

func (p *TierConfig) Equals(other *TierConfig) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Name != other.Name { return false }
  if len(p.Settings) != len(other.Settings) { return false }
  for k, _tgt := range p.Settings {
    _src98 := other.Settings[k]
    if _tgt != _src98 { return false }
  }
  return true
}

func (p *TierConfig) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("TierConfig(%+v)", *p)
}

// Result of the getTierConfigResult call.
// 
// Attributes:
//  - DefaultTierName: Name of the default tier.
//  - Tiers: Set of tier configurations.
type GetTierConfigResult_ struct {
  DefaultTierName string `thrift:"defaultTierName,1" db:"defaultTierName" json:"defaultTierName"`
  Tiers []*TierConfig `thrift:"tiers,2" db:"tiers" json:"tiers"`
}

func NewGetTierConfigResult_() *GetTierConfigResult_ {
  return &GetTierConfigResult_{}
}


func (p *GetTierConfigResult_) GetDefaultTierName() string {
  return p.DefaultTierName
}

func (p *GetTierConfigResult_) GetTiers() []*TierConfig {
  return p.Tiers
}
func (p *GetTierConfigResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *GetTierConfigResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.DefaultTierName = v
}
  return nil
}

func (p *GetTierConfigResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]*TierConfig, 0, size)
  p.Tiers =  tSet
  for i := 0; i < size; i ++ {
    _elem99 := &TierConfig{}
    if err := _elem99.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem99), err)
    }
    p.Tiers = append(p.Tiers, _elem99)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *GetTierConfigResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "GetTierConfigResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *GetTierConfigResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "defaultTierName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:defaultTierName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.DefaultTierName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.defaultTierName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:defaultTierName: ", p), err) }
  return err
}

func (p *GetTierConfigResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tiers", thrift.SET, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tiers: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.STRUCT, len(p.Tiers)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Tiers); i++ {
    for j := i+1; j<len(p.Tiers); j++ {
      if func(tgt, src *TierConfig) bool {
        if !tgt.Equals(src) { return false }
        return true
      }(p.Tiers[i], p.Tiers[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Tiers))
      }
    }
  }
  for _, v := range p.Tiers {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tiers: ", p), err) }
  return err
}

func (p *GetTierConfigResult_) Equals(other *GetTierConfigResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.DefaultTierName != other.DefaultTierName { return false }
  if len(p.Tiers) != len(other.Tiers) { return false }
  for i, _tgt := range p.Tiers {
    _src100 := other.Tiers[i]
    if !_tgt.Equals(_src100) { return false }
  }
  return true
}

func (p *GetTierConfigResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("GetTierConfigResult_(%+v)", *p)
}

// Information about the scheduler.
// 
// Attributes:
//  - ClusterName
//  - StatsUrlPrefix: A url prefix for job container stats.
type ServerInfo struct {
  ClusterName string `thrift:"clusterName,1" db:"clusterName" json:"clusterName"`
  // unused field # 2
  StatsUrlPrefix string `thrift:"statsUrlPrefix,3" db:"statsUrlPrefix" json:"statsUrlPrefix"`
}

func NewServerInfo() *ServerInfo {
  return &ServerInfo{}
}


func (p *ServerInfo) GetClusterName() string {
  return p.ClusterName
}

func (p *ServerInfo) GetStatsUrlPrefix() string {
  return p.StatsUrlPrefix
}
func (p *ServerInfo) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServerInfo)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ClusterName = v
}
  return nil
}

func (p *ServerInfo)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.StatsUrlPrefix = v
}
  return nil
}

func (p *ServerInfo) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ServerInfo"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServerInfo) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "clusterName", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clusterName: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.ClusterName)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.clusterName (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clusterName: ", p), err) }
  return err
}

func (p *ServerInfo) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "statsUrlPrefix", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:statsUrlPrefix: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.StatsUrlPrefix)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.statsUrlPrefix (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:statsUrlPrefix: ", p), err) }
  return err
}

func (p *ServerInfo) Equals(other *ServerInfo) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ClusterName != other.ClusterName { return false }
  if p.StatsUrlPrefix != other.StatsUrlPrefix { return false }
  return true
}

func (p *ServerInfo) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServerInfo(%+v)", *p)
}

// Attributes:
//  - PopulateJobResult_
//  - ScheduleStatusResult_
//  - GetJobsResult_
//  - GetQuotaResult_
//  - ListBackupsResult_
//  - StartMaintenanceResult_
//  - DrainHostsResult_
//  - QueryRecoveryResult_
//  - MaintenanceStatusResult_
//  - EndMaintenanceResult_
//  - RoleSummaryResult_
//  - JobSummaryResult_
//  - ConfigSummaryResult_
//  - GetPendingReasonResult_
//  - StartJobUpdateResult_
//  - GetJobUpdateSummariesResult_
//  - GetJobUpdateDetailsResult_
//  - PulseJobUpdateResult_
//  - GetJobUpdateDiffResult_
//  - GetTierConfigResult_
type Result_ struct {
  PopulateJobResult_ *PopulateJobResult_ `thrift:"populateJobResult,1" db:"populateJobResult" json:"populateJobResult,omitempty"`
  // unused field # 2
  ScheduleStatusResult_ *ScheduleStatusResult_ `thrift:"scheduleStatusResult,3" db:"scheduleStatusResult" json:"scheduleStatusResult,omitempty"`
  GetJobsResult_ *GetJobsResult_ `thrift:"getJobsResult,4" db:"getJobsResult" json:"getJobsResult,omitempty"`
  GetQuotaResult_ *GetQuotaResult_ `thrift:"getQuotaResult,5" db:"getQuotaResult" json:"getQuotaResult,omitempty"`
  ListBackupsResult_ *ListBackupsResult_ `thrift:"listBackupsResult,6" db:"listBackupsResult" json:"listBackupsResult,omitempty"`
  StartMaintenanceResult_ *StartMaintenanceResult_ `thrift:"startMaintenanceResult,7" db:"startMaintenanceResult" json:"startMaintenanceResult,omitempty"`
  DrainHostsResult_ *DrainHostsResult_ `thrift:"drainHostsResult,8" db:"drainHostsResult" json:"drainHostsResult,omitempty"`
  QueryRecoveryResult_ *QueryRecoveryResult_ `thrift:"queryRecoveryResult,9" db:"queryRecoveryResult" json:"queryRecoveryResult,omitempty"`
  MaintenanceStatusResult_ *MaintenanceStatusResult_ `thrift:"maintenanceStatusResult,10" db:"maintenanceStatusResult" json:"maintenanceStatusResult,omitempty"`
  EndMaintenanceResult_ *EndMaintenanceResult_ `thrift:"endMaintenanceResult,11" db:"endMaintenanceResult" json:"endMaintenanceResult,omitempty"`
  // unused fields # 12 to 16
  RoleSummaryResult_ *RoleSummaryResult_ `thrift:"roleSummaryResult,17" db:"roleSummaryResult" json:"roleSummaryResult,omitempty"`
  JobSummaryResult_ *JobSummaryResult_ `thrift:"jobSummaryResult,18" db:"jobSummaryResult" json:"jobSummaryResult,omitempty"`
  // unused field # 19
  ConfigSummaryResult_ *ConfigSummaryResult_ `thrift:"configSummaryResult,20" db:"configSummaryResult" json:"configSummaryResult,omitempty"`
  GetPendingReasonResult_ *GetPendingReasonResult_ `thrift:"getPendingReasonResult,21" db:"getPendingReasonResult" json:"getPendingReasonResult,omitempty"`
  StartJobUpdateResult_ *StartJobUpdateResult_ `thrift:"startJobUpdateResult,22" db:"startJobUpdateResult" json:"startJobUpdateResult,omitempty"`
  GetJobUpdateSummariesResult_ *GetJobUpdateSummariesResult_ `thrift:"getJobUpdateSummariesResult,23" db:"getJobUpdateSummariesResult" json:"getJobUpdateSummariesResult,omitempty"`
  GetJobUpdateDetailsResult_ *GetJobUpdateDetailsResult_ `thrift:"getJobUpdateDetailsResult,24" db:"getJobUpdateDetailsResult" json:"getJobUpdateDetailsResult,omitempty"`
  PulseJobUpdateResult_ *PulseJobUpdateResult_ `thrift:"pulseJobUpdateResult,25" db:"pulseJobUpdateResult" json:"pulseJobUpdateResult,omitempty"`
  GetJobUpdateDiffResult_ *GetJobUpdateDiffResult_ `thrift:"getJobUpdateDiffResult,26" db:"getJobUpdateDiffResult" json:"getJobUpdateDiffResult,omitempty"`
  GetTierConfigResult_ *GetTierConfigResult_ `thrift:"getTierConfigResult,27" db:"getTierConfigResult" json:"getTierConfigResult,omitempty"`
}

func NewResult_() *Result_ {
  return &Result_{}
}

var Result__PopulateJobResult__DEFAULT *PopulateJobResult_
func (p *Result_) GetPopulateJobResult_() *PopulateJobResult_ {
  if !p.IsSetPopulateJobResult_() {
    return Result__PopulateJobResult__DEFAULT
  }
return p.PopulateJobResult_
}
var Result__ScheduleStatusResult__DEFAULT *ScheduleStatusResult_
func (p *Result_) GetScheduleStatusResult_() *ScheduleStatusResult_ {
  if !p.IsSetScheduleStatusResult_() {
    return Result__ScheduleStatusResult__DEFAULT
  }
return p.ScheduleStatusResult_
}
var Result__GetJobsResult__DEFAULT *GetJobsResult_
func (p *Result_) GetGetJobsResult_() *GetJobsResult_ {
  if !p.IsSetGetJobsResult_() {
    return Result__GetJobsResult__DEFAULT
  }
return p.GetJobsResult_
}
var Result__GetQuotaResult__DEFAULT *GetQuotaResult_
func (p *Result_) GetGetQuotaResult_() *GetQuotaResult_ {
  if !p.IsSetGetQuotaResult_() {
    return Result__GetQuotaResult__DEFAULT
  }
return p.GetQuotaResult_
}
var Result__ListBackupsResult__DEFAULT *ListBackupsResult_
func (p *Result_) GetListBackupsResult_() *ListBackupsResult_ {
  if !p.IsSetListBackupsResult_() {
    return Result__ListBackupsResult__DEFAULT
  }
return p.ListBackupsResult_
}
var Result__StartMaintenanceResult__DEFAULT *StartMaintenanceResult_
func (p *Result_) GetStartMaintenanceResult_() *StartMaintenanceResult_ {
  if !p.IsSetStartMaintenanceResult_() {
    return Result__StartMaintenanceResult__DEFAULT
  }
return p.StartMaintenanceResult_
}
var Result__DrainHostsResult__DEFAULT *DrainHostsResult_
func (p *Result_) GetDrainHostsResult_() *DrainHostsResult_ {
  if !p.IsSetDrainHostsResult_() {
    return Result__DrainHostsResult__DEFAULT
  }
return p.DrainHostsResult_
}
var Result__QueryRecoveryResult__DEFAULT *QueryRecoveryResult_
func (p *Result_) GetQueryRecoveryResult_() *QueryRecoveryResult_ {
  if !p.IsSetQueryRecoveryResult_() {
    return Result__QueryRecoveryResult__DEFAULT
  }
return p.QueryRecoveryResult_
}
var Result__MaintenanceStatusResult__DEFAULT *MaintenanceStatusResult_
func (p *Result_) GetMaintenanceStatusResult_() *MaintenanceStatusResult_ {
  if !p.IsSetMaintenanceStatusResult_() {
    return Result__MaintenanceStatusResult__DEFAULT
  }
return p.MaintenanceStatusResult_
}
var Result__EndMaintenanceResult__DEFAULT *EndMaintenanceResult_
func (p *Result_) GetEndMaintenanceResult_() *EndMaintenanceResult_ {
  if !p.IsSetEndMaintenanceResult_() {
    return Result__EndMaintenanceResult__DEFAULT
  }
return p.EndMaintenanceResult_
}
var Result__RoleSummaryResult__DEFAULT *RoleSummaryResult_
func (p *Result_) GetRoleSummaryResult_() *RoleSummaryResult_ {
  if !p.IsSetRoleSummaryResult_() {
    return Result__RoleSummaryResult__DEFAULT
  }
return p.RoleSummaryResult_
}
var Result__JobSummaryResult__DEFAULT *JobSummaryResult_
func (p *Result_) GetJobSummaryResult_() *JobSummaryResult_ {
  if !p.IsSetJobSummaryResult_() {
    return Result__JobSummaryResult__DEFAULT
  }
return p.JobSummaryResult_
}
var Result__ConfigSummaryResult__DEFAULT *ConfigSummaryResult_
func (p *Result_) GetConfigSummaryResult_() *ConfigSummaryResult_ {
  if !p.IsSetConfigSummaryResult_() {
    return Result__ConfigSummaryResult__DEFAULT
  }
return p.ConfigSummaryResult_
}
var Result__GetPendingReasonResult__DEFAULT *GetPendingReasonResult_
func (p *Result_) GetGetPendingReasonResult_() *GetPendingReasonResult_ {
  if !p.IsSetGetPendingReasonResult_() {
    return Result__GetPendingReasonResult__DEFAULT
  }
return p.GetPendingReasonResult_
}
var Result__StartJobUpdateResult__DEFAULT *StartJobUpdateResult_
func (p *Result_) GetStartJobUpdateResult_() *StartJobUpdateResult_ {
  if !p.IsSetStartJobUpdateResult_() {
    return Result__StartJobUpdateResult__DEFAULT
  }
return p.StartJobUpdateResult_
}
var Result__GetJobUpdateSummariesResult__DEFAULT *GetJobUpdateSummariesResult_
func (p *Result_) GetGetJobUpdateSummariesResult_() *GetJobUpdateSummariesResult_ {
  if !p.IsSetGetJobUpdateSummariesResult_() {
    return Result__GetJobUpdateSummariesResult__DEFAULT
  }
return p.GetJobUpdateSummariesResult_
}
var Result__GetJobUpdateDetailsResult__DEFAULT *GetJobUpdateDetailsResult_
func (p *Result_) GetGetJobUpdateDetailsResult_() *GetJobUpdateDetailsResult_ {
  if !p.IsSetGetJobUpdateDetailsResult_() {
    return Result__GetJobUpdateDetailsResult__DEFAULT
  }
return p.GetJobUpdateDetailsResult_
}
var Result__PulseJobUpdateResult__DEFAULT *PulseJobUpdateResult_
func (p *Result_) GetPulseJobUpdateResult_() *PulseJobUpdateResult_ {
  if !p.IsSetPulseJobUpdateResult_() {
    return Result__PulseJobUpdateResult__DEFAULT
  }
return p.PulseJobUpdateResult_
}
var Result__GetJobUpdateDiffResult__DEFAULT *GetJobUpdateDiffResult_
func (p *Result_) GetGetJobUpdateDiffResult_() *GetJobUpdateDiffResult_ {
  if !p.IsSetGetJobUpdateDiffResult_() {
    return Result__GetJobUpdateDiffResult__DEFAULT
  }
return p.GetJobUpdateDiffResult_
}
var Result__GetTierConfigResult__DEFAULT *GetTierConfigResult_
func (p *Result_) GetGetTierConfigResult_() *GetTierConfigResult_ {
  if !p.IsSetGetTierConfigResult_() {
    return Result__GetTierConfigResult__DEFAULT
  }
return p.GetTierConfigResult_
}
func (p *Result_) CountSetFieldsResult_() int {
  count := 0
  if (p.IsSetPopulateJobResult_()) {
    count++
  }
  if (p.IsSetScheduleStatusResult_()) {
    count++
  }
  if (p.IsSetGetJobsResult_()) {
    count++
  }
  if (p.IsSetGetQuotaResult_()) {
    count++
  }
  if (p.IsSetListBackupsResult_()) {
    count++
  }
  if (p.IsSetStartMaintenanceResult_()) {
    count++
  }
  if (p.IsSetDrainHostsResult_()) {
    count++
  }
  if (p.IsSetQueryRecoveryResult_()) {
    count++
  }
  if (p.IsSetMaintenanceStatusResult_()) {
    count++
  }
  if (p.IsSetEndMaintenanceResult_()) {
    count++
  }
  if (p.IsSetRoleSummaryResult_()) {
    count++
  }
  if (p.IsSetJobSummaryResult_()) {
    count++
  }
  if (p.IsSetConfigSummaryResult_()) {
    count++
  }
  if (p.IsSetGetPendingReasonResult_()) {
    count++
  }
  if (p.IsSetStartJobUpdateResult_()) {
    count++
  }
  if (p.IsSetGetJobUpdateSummariesResult_()) {
    count++
  }
  if (p.IsSetGetJobUpdateDetailsResult_()) {
    count++
  }
  if (p.IsSetPulseJobUpdateResult_()) {
    count++
  }
  if (p.IsSetGetJobUpdateDiffResult_()) {
    count++
  }
  if (p.IsSetGetTierConfigResult_()) {
    count++
  }
  return count

}

func (p *Result_) IsSetPopulateJobResult_() bool {
  return p.PopulateJobResult_ != nil
}

func (p *Result_) IsSetScheduleStatusResult_() bool {
  return p.ScheduleStatusResult_ != nil
}

func (p *Result_) IsSetGetJobsResult_() bool {
  return p.GetJobsResult_ != nil
}

func (p *Result_) IsSetGetQuotaResult_() bool {
  return p.GetQuotaResult_ != nil
}

func (p *Result_) IsSetListBackupsResult_() bool {
  return p.ListBackupsResult_ != nil
}

func (p *Result_) IsSetStartMaintenanceResult_() bool {
  return p.StartMaintenanceResult_ != nil
}

func (p *Result_) IsSetDrainHostsResult_() bool {
  return p.DrainHostsResult_ != nil
}

func (p *Result_) IsSetQueryRecoveryResult_() bool {
  return p.QueryRecoveryResult_ != nil
}

func (p *Result_) IsSetMaintenanceStatusResult_() bool {
  return p.MaintenanceStatusResult_ != nil
}

func (p *Result_) IsSetEndMaintenanceResult_() bool {
  return p.EndMaintenanceResult_ != nil
}

func (p *Result_) IsSetRoleSummaryResult_() bool {
  return p.RoleSummaryResult_ != nil
}

func (p *Result_) IsSetJobSummaryResult_() bool {
  return p.JobSummaryResult_ != nil
}

func (p *Result_) IsSetConfigSummaryResult_() bool {
  return p.ConfigSummaryResult_ != nil
}

func (p *Result_) IsSetGetPendingReasonResult_() bool {
  return p.GetPendingReasonResult_ != nil
}

func (p *Result_) IsSetStartJobUpdateResult_() bool {
  return p.StartJobUpdateResult_ != nil
}

func (p *Result_) IsSetGetJobUpdateSummariesResult_() bool {
  return p.GetJobUpdateSummariesResult_ != nil
}

func (p *Result_) IsSetGetJobUpdateDetailsResult_() bool {
  return p.GetJobUpdateDetailsResult_ != nil
}

func (p *Result_) IsSetPulseJobUpdateResult_() bool {
  return p.PulseJobUpdateResult_ != nil
}

func (p *Result_) IsSetGetJobUpdateDiffResult_() bool {
  return p.GetJobUpdateDiffResult_ != nil
}

func (p *Result_) IsSetGetTierConfigResult_() bool {
  return p.GetTierConfigResult_ != nil
}

func (p *Result_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 18:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField18(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 20:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField20(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 21:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField21(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 22:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField22(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 23:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField23(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 24:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField24(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 25:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField25(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 26:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField26(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 27:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField27(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Result_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.PopulateJobResult_ = &PopulateJobResult_{}
  if err := p.PopulateJobResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PopulateJobResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.ScheduleStatusResult_ = &ScheduleStatusResult_{}
  if err := p.ScheduleStatusResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ScheduleStatusResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetJobsResult_ = &GetJobsResult_{}
  if err := p.GetJobsResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetJobsResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetQuotaResult_ = &GetQuotaResult_{}
  if err := p.GetQuotaResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetQuotaResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.ListBackupsResult_ = &ListBackupsResult_{}
  if err := p.ListBackupsResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ListBackupsResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.StartMaintenanceResult_ = &StartMaintenanceResult_{}
  if err := p.StartMaintenanceResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.StartMaintenanceResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.DrainHostsResult_ = &DrainHostsResult_{}
  if err := p.DrainHostsResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DrainHostsResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  p.QueryRecoveryResult_ = &QueryRecoveryResult_{}
  if err := p.QueryRecoveryResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.QueryRecoveryResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  p.MaintenanceStatusResult_ = &MaintenanceStatusResult_{}
  if err := p.MaintenanceStatusResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.MaintenanceStatusResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  p.EndMaintenanceResult_ = &EndMaintenanceResult_{}
  if err := p.EndMaintenanceResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.EndMaintenanceResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  p.RoleSummaryResult_ = &RoleSummaryResult_{}
  if err := p.RoleSummaryResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.RoleSummaryResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
  p.JobSummaryResult_ = &JobSummaryResult_{}
  if err := p.JobSummaryResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.JobSummaryResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField20(ctx context.Context, iprot thrift.TProtocol) error {
  p.ConfigSummaryResult_ = &ConfigSummaryResult_{}
  if err := p.ConfigSummaryResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ConfigSummaryResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField21(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetPendingReasonResult_ = &GetPendingReasonResult_{}
  if err := p.GetPendingReasonResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetPendingReasonResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField22(ctx context.Context, iprot thrift.TProtocol) error {
  p.StartJobUpdateResult_ = &StartJobUpdateResult_{}
  if err := p.StartJobUpdateResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.StartJobUpdateResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField23(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetJobUpdateSummariesResult_ = &GetJobUpdateSummariesResult_{}
  if err := p.GetJobUpdateSummariesResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetJobUpdateSummariesResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField24(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetJobUpdateDetailsResult_ = &GetJobUpdateDetailsResult_{}
  if err := p.GetJobUpdateDetailsResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetJobUpdateDetailsResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField25(ctx context.Context, iprot thrift.TProtocol) error {
  p.PulseJobUpdateResult_ = &PulseJobUpdateResult_{}
  if err := p.PulseJobUpdateResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.PulseJobUpdateResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField26(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetJobUpdateDiffResult_ = &GetJobUpdateDiffResult_{}
  if err := p.GetJobUpdateDiffResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetJobUpdateDiffResult_), err)
  }
  return nil
}

func (p *Result_)  ReadField27(ctx context.Context, iprot thrift.TProtocol) error {
  p.GetTierConfigResult_ = &GetTierConfigResult_{}
  if err := p.GetTierConfigResult_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.GetTierConfigResult_), err)
  }
  return nil
}

func (p *Result_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if c := p.CountSetFieldsResult_(); c != 1 {
    return fmt.Errorf("%T write union: exactly one field must be set (%d set).", p, c)
  }
  if err := oprot.WriteStructBegin(ctx, "Result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
    if err := p.writeField18(ctx, oprot); err != nil { return err }
    if err := p.writeField20(ctx, oprot); err != nil { return err }
    if err := p.writeField21(ctx, oprot); err != nil { return err }
    if err := p.writeField22(ctx, oprot); err != nil { return err }
    if err := p.writeField23(ctx, oprot); err != nil { return err }
    if err := p.writeField24(ctx, oprot); err != nil { return err }
    if err := p.writeField25(ctx, oprot); err != nil { return err }
    if err := p.writeField26(ctx, oprot); err != nil { return err }
    if err := p.writeField27(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Result_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPopulateJobResult_() {
    if err := oprot.WriteFieldBegin(ctx, "populateJobResult", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:populateJobResult: ", p), err) }
    if err := p.PopulateJobResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PopulateJobResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:populateJobResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetScheduleStatusResult_() {
    if err := oprot.WriteFieldBegin(ctx, "scheduleStatusResult", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:scheduleStatusResult: ", p), err) }
    if err := p.ScheduleStatusResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ScheduleStatusResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:scheduleStatusResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetJobsResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getJobsResult", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:getJobsResult: ", p), err) }
    if err := p.GetJobsResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetJobsResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:getJobsResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetQuotaResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getQuotaResult", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:getQuotaResult: ", p), err) }
    if err := p.GetQuotaResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetQuotaResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:getQuotaResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetListBackupsResult_() {
    if err := oprot.WriteFieldBegin(ctx, "listBackupsResult", thrift.STRUCT, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:listBackupsResult: ", p), err) }
    if err := p.ListBackupsResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ListBackupsResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:listBackupsResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStartMaintenanceResult_() {
    if err := oprot.WriteFieldBegin(ctx, "startMaintenanceResult", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:startMaintenanceResult: ", p), err) }
    if err := p.StartMaintenanceResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.StartMaintenanceResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:startMaintenanceResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetDrainHostsResult_() {
    if err := oprot.WriteFieldBegin(ctx, "drainHostsResult", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:drainHostsResult: ", p), err) }
    if err := p.DrainHostsResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DrainHostsResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:drainHostsResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetQueryRecoveryResult_() {
    if err := oprot.WriteFieldBegin(ctx, "queryRecoveryResult", thrift.STRUCT, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:queryRecoveryResult: ", p), err) }
    if err := p.QueryRecoveryResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.QueryRecoveryResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:queryRecoveryResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaintenanceStatusResult_() {
    if err := oprot.WriteFieldBegin(ctx, "maintenanceStatusResult", thrift.STRUCT, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:maintenanceStatusResult: ", p), err) }
    if err := p.MaintenanceStatusResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.MaintenanceStatusResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:maintenanceStatusResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEndMaintenanceResult_() {
    if err := oprot.WriteFieldBegin(ctx, "endMaintenanceResult", thrift.STRUCT, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:endMaintenanceResult: ", p), err) }
    if err := p.EndMaintenanceResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.EndMaintenanceResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:endMaintenanceResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRoleSummaryResult_() {
    if err := oprot.WriteFieldBegin(ctx, "roleSummaryResult", thrift.STRUCT, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:roleSummaryResult: ", p), err) }
    if err := p.RoleSummaryResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.RoleSummaryResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:roleSummaryResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetJobSummaryResult_() {
    if err := oprot.WriteFieldBegin(ctx, "jobSummaryResult", thrift.STRUCT, 18); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:jobSummaryResult: ", p), err) }
    if err := p.JobSummaryResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.JobSummaryResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 18:jobSummaryResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField20(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetConfigSummaryResult_() {
    if err := oprot.WriteFieldBegin(ctx, "configSummaryResult", thrift.STRUCT, 20); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:configSummaryResult: ", p), err) }
    if err := p.ConfigSummaryResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ConfigSummaryResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 20:configSummaryResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField21(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetPendingReasonResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getPendingReasonResult", thrift.STRUCT, 21); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 21:getPendingReasonResult: ", p), err) }
    if err := p.GetPendingReasonResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetPendingReasonResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 21:getPendingReasonResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField22(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetStartJobUpdateResult_() {
    if err := oprot.WriteFieldBegin(ctx, "startJobUpdateResult", thrift.STRUCT, 22); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 22:startJobUpdateResult: ", p), err) }
    if err := p.StartJobUpdateResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.StartJobUpdateResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 22:startJobUpdateResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField23(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetJobUpdateSummariesResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getJobUpdateSummariesResult", thrift.STRUCT, 23); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 23:getJobUpdateSummariesResult: ", p), err) }
    if err := p.GetJobUpdateSummariesResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetJobUpdateSummariesResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 23:getJobUpdateSummariesResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField24(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetJobUpdateDetailsResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getJobUpdateDetailsResult", thrift.STRUCT, 24); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 24:getJobUpdateDetailsResult: ", p), err) }
    if err := p.GetJobUpdateDetailsResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetJobUpdateDetailsResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 24:getJobUpdateDetailsResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField25(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPulseJobUpdateResult_() {
    if err := oprot.WriteFieldBegin(ctx, "pulseJobUpdateResult", thrift.STRUCT, 25); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 25:pulseJobUpdateResult: ", p), err) }
    if err := p.PulseJobUpdateResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.PulseJobUpdateResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 25:pulseJobUpdateResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField26(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetJobUpdateDiffResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getJobUpdateDiffResult", thrift.STRUCT, 26); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 26:getJobUpdateDiffResult: ", p), err) }
    if err := p.GetJobUpdateDiffResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetJobUpdateDiffResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 26:getJobUpdateDiffResult: ", p), err) }
  }
  return err
}

func (p *Result_) writeField27(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetGetTierConfigResult_() {
    if err := oprot.WriteFieldBegin(ctx, "getTierConfigResult", thrift.STRUCT, 27); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 27:getTierConfigResult: ", p), err) }
    if err := p.GetTierConfigResult_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.GetTierConfigResult_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 27:getTierConfigResult: ", p), err) }
  }
  return err
}

func (p *Result_) Equals(other *Result_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.PopulateJobResult_.Equals(other.PopulateJobResult_) { return false }
  if !p.ScheduleStatusResult_.Equals(other.ScheduleStatusResult_) { return false }
  if !p.GetJobsResult_.Equals(other.GetJobsResult_) { return false }
  if !p.GetQuotaResult_.Equals(other.GetQuotaResult_) { return false }
  if !p.ListBackupsResult_.Equals(other.ListBackupsResult_) { return false }
  if !p.StartMaintenanceResult_.Equals(other.StartMaintenanceResult_) { return false }
  if !p.DrainHostsResult_.Equals(other.DrainHostsResult_) { return false }
  if !p.QueryRecoveryResult_.Equals(other.QueryRecoveryResult_) { return false }
  if !p.MaintenanceStatusResult_.Equals(other.MaintenanceStatusResult_) { return false }
  if !p.EndMaintenanceResult_.Equals(other.EndMaintenanceResult_) { return false }
  if !p.RoleSummaryResult_.Equals(other.RoleSummaryResult_) { return false }
  if !p.JobSummaryResult_.Equals(other.JobSummaryResult_) { return false }
  if !p.ConfigSummaryResult_.Equals(other.ConfigSummaryResult_) { return false }
  if !p.GetPendingReasonResult_.Equals(other.GetPendingReasonResult_) { return false }
  if !p.StartJobUpdateResult_.Equals(other.StartJobUpdateResult_) { return false }
  if !p.GetJobUpdateSummariesResult_.Equals(other.GetJobUpdateSummariesResult_) { return false }
  if !p.GetJobUpdateDetailsResult_.Equals(other.GetJobUpdateDetailsResult_) { return false }
  if !p.PulseJobUpdateResult_.Equals(other.PulseJobUpdateResult_) { return false }
  if !p.GetJobUpdateDiffResult_.Equals(other.GetJobUpdateDiffResult_) { return false }
  if !p.GetTierConfigResult_.Equals(other.GetTierConfigResult_) { return false }
  return true
}

func (p *Result_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Result_(%+v)", *p)
}

// Attributes:
//  - Message
type ResponseDetail struct {
  Message string `thrift:"message,1" db:"message" json:"message"`
}

func NewResponseDetail() *ResponseDetail {
  return &ResponseDetail{}
}


func (p *ResponseDetail) GetMessage() string {
  return p.Message
}
func (p *ResponseDetail) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ResponseDetail)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *ResponseDetail) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ResponseDetail"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ResponseDetail) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:message: ", p), err) }
  return err
}

func (p *ResponseDetail) Equals(other *ResponseDetail) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Message != other.Message { return false }
  return true
}

func (p *ResponseDetail) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ResponseDetail(%+v)", *p)
}

// Attributes:
//  - ResponseCode
//  - ServerInfo
//  - Result_: Payload from the invoked RPC.
//  - Details: Messages from the server relevant to the request, such as warnings or use of deprecated
// features.
type Response struct {
  ResponseCode ResponseCode `thrift:"responseCode,1" db:"responseCode" json:"responseCode"`
  // unused field # 2
  Result_ *Result_ `thrift:"result,3" db:"result" json:"result,omitempty"`
  // unused field # 4
  ServerInfo *ServerInfo `thrift:"serverInfo,5" db:"serverInfo" json:"serverInfo"`
  Details []*ResponseDetail `thrift:"details,6" db:"details" json:"details"`
}

func NewResponse() *Response {
  return &Response{}
}


func (p *Response) GetResponseCode() ResponseCode {
  return p.ResponseCode
}
var Response_ServerInfo_DEFAULT *ServerInfo
func (p *Response) GetServerInfo() *ServerInfo {
  if !p.IsSetServerInfo() {
    return Response_ServerInfo_DEFAULT
  }
return p.ServerInfo
}
var Response_Result__DEFAULT *Result_
func (p *Response) GetResult_() *Result_ {
  if !p.IsSetResult_() {
    return Response_Result__DEFAULT
  }
return p.Result_
}

func (p *Response) GetDetails() []*ResponseDetail {
  return p.Details
}
func (p *Response) IsSetServerInfo() bool {
  return p.ServerInfo != nil
}

func (p *Response) IsSetResult_() bool {
  return p.Result_ != nil
}

func (p *Response) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Response)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := ResponseCode(v)
  p.ResponseCode = temp
}
  return nil
}

func (p *Response)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.ServerInfo = &ServerInfo{}
  if err := p.ServerInfo.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ServerInfo), err)
  }
  return nil
}

func (p *Response)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Result_ = &Result_{}
  if err := p.Result_.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Result_), err)
  }
  return nil
}

func (p *Response)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*ResponseDetail, 0, size)
  p.Details =  tSlice
  for i := 0; i < size; i ++ {
    _elem101 := &ResponseDetail{}
    if err := _elem101.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem101), err)
    }
    p.Details = append(p.Details, _elem101)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Response) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Response"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Response) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "responseCode", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:responseCode: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.ResponseCode)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.responseCode (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:responseCode: ", p), err) }
  return err
}

func (p *Response) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetResult_() {
    if err := oprot.WriteFieldBegin(ctx, "result", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:result: ", p), err) }
    if err := p.Result_.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Result_), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:result: ", p), err) }
  }
  return err
}

func (p *Response) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serverInfo", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:serverInfo: ", p), err) }
  if err := p.ServerInfo.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ServerInfo), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:serverInfo: ", p), err) }
  return err
}

func (p *Response) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "details", thrift.LIST, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:details: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Details)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Details {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:details: ", p), err) }
  return err
}

func (p *Response) Equals(other *Response) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.ResponseCode != other.ResponseCode { return false }
  if !p.Result_.Equals(other.Result_) { return false }
  if !p.ServerInfo.Equals(other.ServerInfo) { return false }
  if len(p.Details) != len(other.Details) { return false }
  for i, _tgt := range p.Details {
    _src102 := other.Details[i]
    if !_tgt.Equals(_src102) { return false }
  }
  return true
}

func (p *Response) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Response(%+v)", *p)
}

// Attributes:
//  - BatchSize
type ExplicitReconciliationSettings struct {
  BatchSize *int32 `thrift:"batchSize,1" db:"batchSize" json:"batchSize,omitempty"`
}

func NewExplicitReconciliationSettings() *ExplicitReconciliationSettings {
  return &ExplicitReconciliationSettings{}
}

var ExplicitReconciliationSettings_BatchSize_DEFAULT int32
func (p *ExplicitReconciliationSettings) GetBatchSize() int32 {
  if !p.IsSetBatchSize() {
    return ExplicitReconciliationSettings_BatchSize_DEFAULT
  }
return *p.BatchSize
}
func (p *ExplicitReconciliationSettings) IsSetBatchSize() bool {
  return p.BatchSize != nil
}

func (p *ExplicitReconciliationSettings) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ExplicitReconciliationSettings)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.BatchSize = &v
}
  return nil
}

func (p *ExplicitReconciliationSettings) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "ExplicitReconciliationSettings"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ExplicitReconciliationSettings) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBatchSize() {
    if err := oprot.WriteFieldBegin(ctx, "batchSize", thrift.I32, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:batchSize: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BatchSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.batchSize (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:batchSize: ", p), err) }
  }
  return err
}

func (p *ExplicitReconciliationSettings) Equals(other *ExplicitReconciliationSettings) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.BatchSize != other.BatchSize {
    if p.BatchSize == nil || other.BatchSize == nil {
      return false
    }
    if (*p.BatchSize) != (*other.BatchSize) { return false }
  }
  return true
}

func (p *ExplicitReconciliationSettings) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ExplicitReconciliationSettings(%+v)", *p)
}

type ReadOnlyScheduler interface {
  // Returns a summary of the jobs grouped by role.
  GetRoleSummary(ctx context.Context) (r *Response, err error)
  // Returns a summary of jobs, optionally only those owned by a specific role.
  // 
  // Parameters:
  //  - Role
  GetJobSummary(ctx context.Context, role string) (r *Response, err error)
  // Fetches the status of tasks.
  // 
  // Parameters:
  //  - Query
  GetTasksStatus(ctx context.Context, query *TaskQuery) (r *Response, err error)
  // Same as getTaskStatus but without the TaskConfig.ExecutorConfig data set.
  // This is an interim solution until we have a better way to query TaskConfigs (AURORA-541).
  // 
  // Parameters:
  //  - Query
  GetTasksWithoutConfigs(ctx context.Context, query *TaskQuery) (r *Response, err error)
  // Returns user-friendly reasons (if available) for tasks retained in PENDING state.
  // 
  // Parameters:
  //  - Query
  GetPendingReason(ctx context.Context, query *TaskQuery) (r *Response, err error)
  // Fetches the configuration summary of active tasks for the specified job.
  // 
  // Parameters:
  //  - Job
  GetConfigSummary(ctx context.Context, job *JobKey) (r *Response, err error)
  // Fetches the status of jobs.
  // ownerRole is optional, in which case all jobs are returned.
  // 
  // Parameters:
  //  - OwnerRole
  GetJobs(ctx context.Context, ownerRole string) (r *Response, err error)
  // Fetches the quota allocated for a user.
  // 
  // Parameters:
  //  - OwnerRole
  GetQuota(ctx context.Context, ownerRole string) (r *Response, err error)
  // Populates fields in a job configuration as though it were about to be run.
  // This can be used to diff a configuration running tasks.
  // 
  // Parameters:
  //  - Description
  PopulateJobConfig(ctx context.Context, description *JobConfiguration) (r *Response, err error)
  // Gets job update summaries.
  // 
  // Parameters:
  //  - JobUpdateQuery
  GetJobUpdateSummaries(ctx context.Context, jobUpdateQuery *JobUpdateQuery) (r *Response, err error)
  // Gets job update details.
  // 
  // Parameters:
  //  - Query
  GetJobUpdateDetails(ctx context.Context, query *JobUpdateQuery) (r *Response, err error)
  // Gets the diff between client (desired) and server (current) job states.
  // 
  // Parameters:
  //  - Request
  GetJobUpdateDiff(ctx context.Context, request *JobUpdateRequest) (r *Response, err error)
  // Gets tier configurations.
  GetTierConfigs(ctx context.Context) (r *Response, err error)
}

type ReadOnlySchedulerClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewReadOnlySchedulerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ReadOnlySchedulerClient {
  return &ReadOnlySchedulerClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewReadOnlySchedulerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ReadOnlySchedulerClient {
  return &ReadOnlySchedulerClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewReadOnlySchedulerClient(c thrift.TClient) *ReadOnlySchedulerClient {
  return &ReadOnlySchedulerClient{
    c: c,
  }
}

func (p *ReadOnlySchedulerClient) Client_() thrift.TClient {
  return p.c
}

func (p *ReadOnlySchedulerClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ReadOnlySchedulerClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// Returns a summary of the jobs grouped by role.
func (p *ReadOnlySchedulerClient) GetRoleSummary(ctx context.Context) (r *Response, err error) {
  var _args103 ReadOnlySchedulerGetRoleSummaryArgs
  var _result104 ReadOnlySchedulerGetRoleSummaryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getRoleSummary", &_args103, &_result104)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result104.GetSuccess(), nil
}

// Returns a summary of jobs, optionally only those owned by a specific role.
// 
// Parameters:
//  - Role
func (p *ReadOnlySchedulerClient) GetJobSummary(ctx context.Context, role string) (r *Response, err error) {
  var _args105 ReadOnlySchedulerGetJobSummaryArgs
  _args105.Role = role
  var _result106 ReadOnlySchedulerGetJobSummaryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getJobSummary", &_args105, &_result106)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result106.GetSuccess(), nil
}

// Fetches the status of tasks.
// 
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetTasksStatus(ctx context.Context, query *TaskQuery) (r *Response, err error) {
  var _args107 ReadOnlySchedulerGetTasksStatusArgs
  _args107.Query = query
  var _result108 ReadOnlySchedulerGetTasksStatusResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getTasksStatus", &_args107, &_result108)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result108.GetSuccess(), nil
}

// Same as getTaskStatus but without the TaskConfig.ExecutorConfig data set.
// This is an interim solution until we have a better way to query TaskConfigs (AURORA-541).
// 
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetTasksWithoutConfigs(ctx context.Context, query *TaskQuery) (r *Response, err error) {
  var _args109 ReadOnlySchedulerGetTasksWithoutConfigsArgs
  _args109.Query = query
  var _result110 ReadOnlySchedulerGetTasksWithoutConfigsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getTasksWithoutConfigs", &_args109, &_result110)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result110.GetSuccess(), nil
}

// Returns user-friendly reasons (if available) for tasks retained in PENDING state.
// 
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetPendingReason(ctx context.Context, query *TaskQuery) (r *Response, err error) {
  var _args111 ReadOnlySchedulerGetPendingReasonArgs
  _args111.Query = query
  var _result112 ReadOnlySchedulerGetPendingReasonResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getPendingReason", &_args111, &_result112)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result112.GetSuccess(), nil
}

// Fetches the configuration summary of active tasks for the specified job.
// 
// Parameters:
//  - Job
func (p *ReadOnlySchedulerClient) GetConfigSummary(ctx context.Context, job *JobKey) (r *Response, err error) {
  var _args113 ReadOnlySchedulerGetConfigSummaryArgs
  _args113.Job = job
  var _result114 ReadOnlySchedulerGetConfigSummaryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getConfigSummary", &_args113, &_result114)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result114.GetSuccess(), nil
}

// Fetches the status of jobs.
// ownerRole is optional, in which case all jobs are returned.
// 
// Parameters:
//  - OwnerRole
func (p *ReadOnlySchedulerClient) GetJobs(ctx context.Context, ownerRole string) (r *Response, err error) {
  var _args115 ReadOnlySchedulerGetJobsArgs
  _args115.OwnerRole = ownerRole
  var _result116 ReadOnlySchedulerGetJobsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getJobs", &_args115, &_result116)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result116.GetSuccess(), nil
}

// Fetches the quota allocated for a user.
// 
// Parameters:
//  - OwnerRole
func (p *ReadOnlySchedulerClient) GetQuota(ctx context.Context, ownerRole string) (r *Response, err error) {
  var _args117 ReadOnlySchedulerGetQuotaArgs
  _args117.OwnerRole = ownerRole
  var _result118 ReadOnlySchedulerGetQuotaResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getQuota", &_args117, &_result118)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result118.GetSuccess(), nil
}

// Populates fields in a job configuration as though it were about to be run.
// This can be used to diff a configuration running tasks.
// 
// Parameters:
//  - Description
func (p *ReadOnlySchedulerClient) PopulateJobConfig(ctx context.Context, description *JobConfiguration) (r *Response, err error) {
  var _args119 ReadOnlySchedulerPopulateJobConfigArgs
  _args119.Description = description
  var _result120 ReadOnlySchedulerPopulateJobConfigResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "populateJobConfig", &_args119, &_result120)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result120.GetSuccess(), nil
}

// Gets job update summaries.
// 
// Parameters:
//  - JobUpdateQuery
func (p *ReadOnlySchedulerClient) GetJobUpdateSummaries(ctx context.Context, jobUpdateQuery *JobUpdateQuery) (r *Response, err error) {
  var _args121 ReadOnlySchedulerGetJobUpdateSummariesArgs
  _args121.JobUpdateQuery = jobUpdateQuery
  var _result122 ReadOnlySchedulerGetJobUpdateSummariesResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getJobUpdateSummaries", &_args121, &_result122)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result122.GetSuccess(), nil
}

// Gets job update details.
// 
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetJobUpdateDetails(ctx context.Context, query *JobUpdateQuery) (r *Response, err error) {
  var _args123 ReadOnlySchedulerGetJobUpdateDetailsArgs
  _args123.Query = query
  var _result124 ReadOnlySchedulerGetJobUpdateDetailsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getJobUpdateDetails", &_args123, &_result124)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result124.GetSuccess(), nil
}

// Gets the diff between client (desired) and server (current) job states.
// 
// Parameters:
//  - Request
func (p *ReadOnlySchedulerClient) GetJobUpdateDiff(ctx context.Context, request *JobUpdateRequest) (r *Response, err error) {
  var _args125 ReadOnlySchedulerGetJobUpdateDiffArgs
  _args125.Request = request
  var _result126 ReadOnlySchedulerGetJobUpdateDiffResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getJobUpdateDiff", &_args125, &_result126)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result126.GetSuccess(), nil
}

// Gets tier configurations.
func (p *ReadOnlySchedulerClient) GetTierConfigs(ctx context.Context) (r *Response, err error) {
  var _args127 ReadOnlySchedulerGetTierConfigsArgs
  var _result128 ReadOnlySchedulerGetTierConfigsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "getTierConfigs", &_args127, &_result128)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result128.GetSuccess(), nil
}

type ReadOnlySchedulerProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler ReadOnlyScheduler
}

func (p *ReadOnlySchedulerProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ReadOnlySchedulerProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ReadOnlySchedulerProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewReadOnlySchedulerProcessor(handler ReadOnlyScheduler) *ReadOnlySchedulerProcessor {

  self129 := &ReadOnlySchedulerProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self129.processorMap["getRoleSummary"] = &readOnlySchedulerProcessorGetRoleSummary{handler:handler}
  self129.processorMap["getJobSummary"] = &readOnlySchedulerProcessorGetJobSummary{handler:handler}
  self129.processorMap["getTasksStatus"] = &readOnlySchedulerProcessorGetTasksStatus{handler:handler}
  self129.processorMap["getTasksWithoutConfigs"] = &readOnlySchedulerProcessorGetTasksWithoutConfigs{handler:handler}
  self129.processorMap["getPendingReason"] = &readOnlySchedulerProcessorGetPendingReason{handler:handler}
  self129.processorMap["getConfigSummary"] = &readOnlySchedulerProcessorGetConfigSummary{handler:handler}
  self129.processorMap["getJobs"] = &readOnlySchedulerProcessorGetJobs{handler:handler}
  self129.processorMap["getQuota"] = &readOnlySchedulerProcessorGetQuota{handler:handler}
  self129.processorMap["populateJobConfig"] = &readOnlySchedulerProcessorPopulateJobConfig{handler:handler}
  self129.processorMap["getJobUpdateSummaries"] = &readOnlySchedulerProcessorGetJobUpdateSummaries{handler:handler}
  self129.processorMap["getJobUpdateDetails"] = &readOnlySchedulerProcessorGetJobUpdateDetails{handler:handler}
  self129.processorMap["getJobUpdateDiff"] = &readOnlySchedulerProcessorGetJobUpdateDiff{handler:handler}
  self129.processorMap["getTierConfigs"] = &readOnlySchedulerProcessorGetTierConfigs{handler:handler}
return self129
}

func (p *ReadOnlySchedulerProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x130 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x130.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x130

}

type readOnlySchedulerProcessorGetRoleSummary struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetRoleSummary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetRoleSummaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getRoleSummary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetRoleSummaryResult{}
  var retval *Response
  if retval, err2 = p.handler.GetRoleSummary(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRoleSummary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getRoleSummary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getRoleSummary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetJobSummary struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobSummary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetJobSummaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobSummary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetJobSummaryResult{}
  var retval *Response
  if retval, err2 = p.handler.GetJobSummary(ctx, args.Role); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobSummary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobSummary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getJobSummary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetTasksStatus struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetTasksStatus) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetTasksStatusArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTasksStatus", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetTasksStatusResult{}
  var retval *Response
  if retval, err2 = p.handler.GetTasksStatus(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTasksStatus: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getTasksStatus", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getTasksStatus", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetTasksWithoutConfigs struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetTasksWithoutConfigs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetTasksWithoutConfigsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTasksWithoutConfigs", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetTasksWithoutConfigsResult{}
  var retval *Response
  if retval, err2 = p.handler.GetTasksWithoutConfigs(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTasksWithoutConfigs: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getTasksWithoutConfigs", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getTasksWithoutConfigs", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetPendingReason struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetPendingReason) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetPendingReasonArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getPendingReason", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetPendingReasonResult{}
  var retval *Response
  if retval, err2 = p.handler.GetPendingReason(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPendingReason: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getPendingReason", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getPendingReason", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetConfigSummary struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetConfigSummary) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetConfigSummaryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getConfigSummary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetConfigSummaryResult{}
  var retval *Response
  if retval, err2 = p.handler.GetConfigSummary(ctx, args.Job); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getConfigSummary: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getConfigSummary", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getConfigSummary", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetJobs struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetJobsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobs", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetJobsResult{}
  var retval *Response
  if retval, err2 = p.handler.GetJobs(ctx, args.OwnerRole); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobs: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobs", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getJobs", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetQuota struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetQuota) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetQuotaArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getQuota", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetQuotaResult{}
  var retval *Response
  if retval, err2 = p.handler.GetQuota(ctx, args.OwnerRole); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getQuota: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getQuota", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getQuota", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorPopulateJobConfig struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorPopulateJobConfig) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerPopulateJobConfigArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "populateJobConfig", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerPopulateJobConfigResult{}
  var retval *Response
  if retval, err2 = p.handler.PopulateJobConfig(ctx, args.Description); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing populateJobConfig: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "populateJobConfig", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "populateJobConfig", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetJobUpdateSummaries struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobUpdateSummaries) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetJobUpdateSummariesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobUpdateSummaries", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetJobUpdateSummariesResult{}
  var retval *Response
  if retval, err2 = p.handler.GetJobUpdateSummaries(ctx, args.JobUpdateQuery); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobUpdateSummaries: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobUpdateSummaries", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getJobUpdateSummaries", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetJobUpdateDetails struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobUpdateDetails) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetJobUpdateDetailsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobUpdateDetails", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetJobUpdateDetailsResult{}
  var retval *Response
  if retval, err2 = p.handler.GetJobUpdateDetails(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobUpdateDetails: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobUpdateDetails", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getJobUpdateDetails", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetJobUpdateDiff struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobUpdateDiff) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetJobUpdateDiffArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobUpdateDiff", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetJobUpdateDiffResult{}
  var retval *Response
  if retval, err2 = p.handler.GetJobUpdateDiff(ctx, args.Request); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobUpdateDiff: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getJobUpdateDiff", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getJobUpdateDiff", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type readOnlySchedulerProcessorGetTierConfigs struct {
  handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetTierConfigs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := ReadOnlySchedulerGetTierConfigsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "getTierConfigs", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ReadOnlySchedulerGetTierConfigsResult{}
  var retval *Response
  if retval, err2 = p.handler.GetTierConfigs(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTierConfigs: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "getTierConfigs", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "getTierConfigs", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ReadOnlySchedulerGetRoleSummaryArgs struct {
}

func NewReadOnlySchedulerGetRoleSummaryArgs() *ReadOnlySchedulerGetRoleSummaryArgs {
  return &ReadOnlySchedulerGetRoleSummaryArgs{}
}

func (p *ReadOnlySchedulerGetRoleSummaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getRoleSummary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetRoleSummaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetRoleSummaryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetRoleSummaryResult() *ReadOnlySchedulerGetRoleSummaryResult {
  return &ReadOnlySchedulerGetRoleSummaryResult{}
}

var ReadOnlySchedulerGetRoleSummaryResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetRoleSummaryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetRoleSummaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetRoleSummaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getRoleSummary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetRoleSummaryResult(%+v)", *p)
}

// Attributes:
//  - Role
type ReadOnlySchedulerGetJobSummaryArgs struct {
  Role string `thrift:"role,1" db:"role" json:"role"`
}

func NewReadOnlySchedulerGetJobSummaryArgs() *ReadOnlySchedulerGetJobSummaryArgs {
  return &ReadOnlySchedulerGetJobSummaryArgs{}
}


func (p *ReadOnlySchedulerGetJobSummaryArgs) GetRole() string {
  return p.Role
}
func (p *ReadOnlySchedulerGetJobSummaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobSummaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Role = v
}
  return nil
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobSummary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "role", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:role: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Role)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.role (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:role: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobSummaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobSummaryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobSummaryResult() *ReadOnlySchedulerGetJobSummaryResult {
  return &ReadOnlySchedulerGetJobSummaryResult{}
}

var ReadOnlySchedulerGetJobSummaryResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetJobSummaryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetJobSummaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetJobSummaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobSummary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetJobSummaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobSummaryResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetTasksStatusArgs struct {
  Query *TaskQuery `thrift:"query,1" db:"query" json:"query"`
}

func NewReadOnlySchedulerGetTasksStatusArgs() *ReadOnlySchedulerGetTasksStatusArgs {
  return &ReadOnlySchedulerGetTasksStatusArgs{}
}

var ReadOnlySchedulerGetTasksStatusArgs_Query_DEFAULT *TaskQuery
func (p *ReadOnlySchedulerGetTasksStatusArgs) GetQuery() *TaskQuery {
  if !p.IsSetQuery() {
    return ReadOnlySchedulerGetTasksStatusArgs_Query_DEFAULT
  }
return p.Query
}
func (p *ReadOnlySchedulerGetTasksStatusArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &TaskQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTasksStatus_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetTasksStatusArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetTasksStatusResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetTasksStatusResult() *ReadOnlySchedulerGetTasksStatusResult {
  return &ReadOnlySchedulerGetTasksStatusResult{}
}

var ReadOnlySchedulerGetTasksStatusResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetTasksStatusResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetTasksStatusResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetTasksStatusResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTasksStatus_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetTasksStatusResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetTasksStatusResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetTasksWithoutConfigsArgs struct {
  Query *TaskQuery `thrift:"query,1" db:"query" json:"query"`
}

func NewReadOnlySchedulerGetTasksWithoutConfigsArgs() *ReadOnlySchedulerGetTasksWithoutConfigsArgs {
  return &ReadOnlySchedulerGetTasksWithoutConfigsArgs{}
}

var ReadOnlySchedulerGetTasksWithoutConfigsArgs_Query_DEFAULT *TaskQuery
func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) GetQuery() *TaskQuery {
  if !p.IsSetQuery() {
    return ReadOnlySchedulerGetTasksWithoutConfigsArgs_Query_DEFAULT
  }
return p.Query
}
func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &TaskQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTasksWithoutConfigs_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetTasksWithoutConfigsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetTasksWithoutConfigsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetTasksWithoutConfigsResult() *ReadOnlySchedulerGetTasksWithoutConfigsResult {
  return &ReadOnlySchedulerGetTasksWithoutConfigsResult{}
}

var ReadOnlySchedulerGetTasksWithoutConfigsResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetTasksWithoutConfigsResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTasksWithoutConfigs_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetTasksWithoutConfigsResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetPendingReasonArgs struct {
  Query *TaskQuery `thrift:"query,1" db:"query" json:"query"`
}

func NewReadOnlySchedulerGetPendingReasonArgs() *ReadOnlySchedulerGetPendingReasonArgs {
  return &ReadOnlySchedulerGetPendingReasonArgs{}
}

var ReadOnlySchedulerGetPendingReasonArgs_Query_DEFAULT *TaskQuery
func (p *ReadOnlySchedulerGetPendingReasonArgs) GetQuery() *TaskQuery {
  if !p.IsSetQuery() {
    return ReadOnlySchedulerGetPendingReasonArgs_Query_DEFAULT
  }
return p.Query
}
func (p *ReadOnlySchedulerGetPendingReasonArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &TaskQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPendingReason_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetPendingReasonArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetPendingReasonResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetPendingReasonResult() *ReadOnlySchedulerGetPendingReasonResult {
  return &ReadOnlySchedulerGetPendingReasonResult{}
}

var ReadOnlySchedulerGetPendingReasonResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetPendingReasonResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetPendingReasonResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetPendingReasonResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getPendingReason_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetPendingReasonResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetPendingReasonResult(%+v)", *p)
}

// Attributes:
//  - Job
type ReadOnlySchedulerGetConfigSummaryArgs struct {
  Job *JobKey `thrift:"job,1" db:"job" json:"job"`
}

func NewReadOnlySchedulerGetConfigSummaryArgs() *ReadOnlySchedulerGetConfigSummaryArgs {
  return &ReadOnlySchedulerGetConfigSummaryArgs{}
}

var ReadOnlySchedulerGetConfigSummaryArgs_Job_DEFAULT *JobKey
func (p *ReadOnlySchedulerGetConfigSummaryArgs) GetJob() *JobKey {
  if !p.IsSetJob() {
    return ReadOnlySchedulerGetConfigSummaryArgs_Job_DEFAULT
  }
return p.Job
}
func (p *ReadOnlySchedulerGetConfigSummaryArgs) IsSetJob() bool {
  return p.Job != nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getConfigSummary_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:job: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetConfigSummaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetConfigSummaryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetConfigSummaryResult() *ReadOnlySchedulerGetConfigSummaryResult {
  return &ReadOnlySchedulerGetConfigSummaryResult{}
}

var ReadOnlySchedulerGetConfigSummaryResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetConfigSummaryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetConfigSummaryResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetConfigSummaryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getConfigSummary_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetConfigSummaryResult(%+v)", *p)
}

// Attributes:
//  - OwnerRole
type ReadOnlySchedulerGetJobsArgs struct {
  OwnerRole string `thrift:"ownerRole,1" db:"ownerRole" json:"ownerRole"`
}

func NewReadOnlySchedulerGetJobsArgs() *ReadOnlySchedulerGetJobsArgs {
  return &ReadOnlySchedulerGetJobsArgs{}
}


func (p *ReadOnlySchedulerGetJobsArgs) GetOwnerRole() string {
  return p.OwnerRole
}
func (p *ReadOnlySchedulerGetJobsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.OwnerRole = v
}
  return nil
}

func (p *ReadOnlySchedulerGetJobsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobs_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ownerRole", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ownerRole: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.OwnerRole)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ownerRole (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ownerRole: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetJobsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobsResult() *ReadOnlySchedulerGetJobsResult {
  return &ReadOnlySchedulerGetJobsResult{}
}

var ReadOnlySchedulerGetJobsResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetJobsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetJobsResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetJobsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobs_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetJobsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobsResult(%+v)", *p)
}

// Attributes:
//  - OwnerRole
type ReadOnlySchedulerGetQuotaArgs struct {
  OwnerRole string `thrift:"ownerRole,1" db:"ownerRole" json:"ownerRole"`
}

func NewReadOnlySchedulerGetQuotaArgs() *ReadOnlySchedulerGetQuotaArgs {
  return &ReadOnlySchedulerGetQuotaArgs{}
}


func (p *ReadOnlySchedulerGetQuotaArgs) GetOwnerRole() string {
  return p.OwnerRole
}
func (p *ReadOnlySchedulerGetQuotaArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetQuotaArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.OwnerRole = v
}
  return nil
}

func (p *ReadOnlySchedulerGetQuotaArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getQuota_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetQuotaArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ownerRole", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ownerRole: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.OwnerRole)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ownerRole (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ownerRole: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetQuotaArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetQuotaArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetQuotaResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetQuotaResult() *ReadOnlySchedulerGetQuotaResult {
  return &ReadOnlySchedulerGetQuotaResult{}
}

var ReadOnlySchedulerGetQuotaResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetQuotaResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetQuotaResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetQuotaResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetQuotaResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetQuotaResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetQuotaResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getQuota_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetQuotaResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetQuotaResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetQuotaResult(%+v)", *p)
}

// Attributes:
//  - Description
type ReadOnlySchedulerPopulateJobConfigArgs struct {
  Description *JobConfiguration `thrift:"description,1" db:"description" json:"description"`
}

func NewReadOnlySchedulerPopulateJobConfigArgs() *ReadOnlySchedulerPopulateJobConfigArgs {
  return &ReadOnlySchedulerPopulateJobConfigArgs{}
}

var ReadOnlySchedulerPopulateJobConfigArgs_Description_DEFAULT *JobConfiguration
func (p *ReadOnlySchedulerPopulateJobConfigArgs) GetDescription() *JobConfiguration {
  if !p.IsSetDescription() {
    return ReadOnlySchedulerPopulateJobConfigArgs_Description_DEFAULT
  }
return p.Description
}
func (p *ReadOnlySchedulerPopulateJobConfigArgs) IsSetDescription() bool {
  return p.Description != nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Description = &JobConfiguration{}
  if err := p.Description.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Description), err)
  }
  return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "populateJobConfig_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "description", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:description: ", p), err) }
  if err := p.Description.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Description), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:description: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerPopulateJobConfigArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerPopulateJobConfigResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerPopulateJobConfigResult() *ReadOnlySchedulerPopulateJobConfigResult {
  return &ReadOnlySchedulerPopulateJobConfigResult{}
}

var ReadOnlySchedulerPopulateJobConfigResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerPopulateJobConfigResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerPopulateJobConfigResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerPopulateJobConfigResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "populateJobConfig_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerPopulateJobConfigResult(%+v)", *p)
}

// Attributes:
//  - JobUpdateQuery
type ReadOnlySchedulerGetJobUpdateSummariesArgs struct {
  JobUpdateQuery *JobUpdateQuery `thrift:"jobUpdateQuery,1" db:"jobUpdateQuery" json:"jobUpdateQuery"`
}

func NewReadOnlySchedulerGetJobUpdateSummariesArgs() *ReadOnlySchedulerGetJobUpdateSummariesArgs {
  return &ReadOnlySchedulerGetJobUpdateSummariesArgs{}
}

var ReadOnlySchedulerGetJobUpdateSummariesArgs_JobUpdateQuery_DEFAULT *JobUpdateQuery
func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) GetJobUpdateQuery() *JobUpdateQuery {
  if !p.IsSetJobUpdateQuery() {
    return ReadOnlySchedulerGetJobUpdateSummariesArgs_JobUpdateQuery_DEFAULT
  }
return p.JobUpdateQuery
}
func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) IsSetJobUpdateQuery() bool {
  return p.JobUpdateQuery != nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.JobUpdateQuery = &JobUpdateQuery{}
  if err := p.JobUpdateQuery.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.JobUpdateQuery), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobUpdateSummaries_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "jobUpdateQuery", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:jobUpdateQuery: ", p), err) }
  if err := p.JobUpdateQuery.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.JobUpdateQuery), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:jobUpdateQuery: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateSummariesArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobUpdateSummariesResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobUpdateSummariesResult() *ReadOnlySchedulerGetJobUpdateSummariesResult {
  return &ReadOnlySchedulerGetJobUpdateSummariesResult{}
}

var ReadOnlySchedulerGetJobUpdateSummariesResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetJobUpdateSummariesResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobUpdateSummaries_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateSummariesResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetJobUpdateDetailsArgs struct {
  // unused field # 1
  Query *JobUpdateQuery `thrift:"query,2" db:"query" json:"query"`
}

func NewReadOnlySchedulerGetJobUpdateDetailsArgs() *ReadOnlySchedulerGetJobUpdateDetailsArgs {
  return &ReadOnlySchedulerGetJobUpdateDetailsArgs{}
}

var ReadOnlySchedulerGetJobUpdateDetailsArgs_Query_DEFAULT *JobUpdateQuery
func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) GetQuery() *JobUpdateQuery {
  if !p.IsSetQuery() {
    return ReadOnlySchedulerGetJobUpdateDetailsArgs_Query_DEFAULT
  }
return p.Query
}
func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &JobUpdateQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobUpdateDetails_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:query: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDetailsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobUpdateDetailsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobUpdateDetailsResult() *ReadOnlySchedulerGetJobUpdateDetailsResult {
  return &ReadOnlySchedulerGetJobUpdateDetailsResult{}
}

var ReadOnlySchedulerGetJobUpdateDetailsResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetJobUpdateDetailsResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobUpdateDetails_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDetailsResult(%+v)", *p)
}

// Attributes:
//  - Request
type ReadOnlySchedulerGetJobUpdateDiffArgs struct {
  Request *JobUpdateRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewReadOnlySchedulerGetJobUpdateDiffArgs() *ReadOnlySchedulerGetJobUpdateDiffArgs {
  return &ReadOnlySchedulerGetJobUpdateDiffArgs{}
}

var ReadOnlySchedulerGetJobUpdateDiffArgs_Request_DEFAULT *JobUpdateRequest
func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) GetRequest() *JobUpdateRequest {
  if !p.IsSetRequest() {
    return ReadOnlySchedulerGetJobUpdateDiffArgs_Request_DEFAULT
  }
return p.Request
}
func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) IsSetRequest() bool {
  return p.Request != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Request = &JobUpdateRequest{}
  if err := p.Request.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobUpdateDiff_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err) }
  if err := p.Request.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err) }
  return err
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDiffArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobUpdateDiffResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobUpdateDiffResult() *ReadOnlySchedulerGetJobUpdateDiffResult {
  return &ReadOnlySchedulerGetJobUpdateDiffResult{}
}

var ReadOnlySchedulerGetJobUpdateDiffResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetJobUpdateDiffResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetJobUpdateDiffResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetJobUpdateDiffResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getJobUpdateDiff_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDiffResult(%+v)", *p)
}

type ReadOnlySchedulerGetTierConfigsArgs struct {
}

func NewReadOnlySchedulerGetTierConfigsArgs() *ReadOnlySchedulerGetTierConfigsArgs {
  return &ReadOnlySchedulerGetTierConfigsArgs{}
}

func (p *ReadOnlySchedulerGetTierConfigsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTierConfigsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTierConfigs_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetTierConfigsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetTierConfigsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetTierConfigsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetTierConfigsResult() *ReadOnlySchedulerGetTierConfigsResult {
  return &ReadOnlySchedulerGetTierConfigsResult{}
}

var ReadOnlySchedulerGetTierConfigsResult_Success_DEFAULT *Response
func (p *ReadOnlySchedulerGetTierConfigsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return ReadOnlySchedulerGetTierConfigsResult_Success_DEFAULT
  }
return p.Success
}
func (p *ReadOnlySchedulerGetTierConfigsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "getTierConfigs_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ReadOnlySchedulerGetTierConfigsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ReadOnlySchedulerGetTierConfigsResult(%+v)", *p)
}


type AuroraSchedulerManager interface {
ReadOnlyScheduler

  // Creates a new job.  The request will be denied if a job with the provided name already exists
  // in the cluster.
  // 
  // Parameters:
  //  - Description
  CreateJob(ctx context.Context, description *JobConfiguration) (r *Response, err error)
  // Enters a job into the cron schedule, without actually starting the job.
  // If the job is already present in the schedule, this will update the schedule entry with the new
  // configuration.
  // 
  // Parameters:
  //  - Description
  ScheduleCronJob(ctx context.Context, description *JobConfiguration) (r *Response, err error)
  // Removes a job from the cron schedule. The request will be denied if the job was not previously
  // scheduled with scheduleCronJob.
  // 
  // Parameters:
  //  - Job
  DescheduleCronJob(ctx context.Context, job *JobKey) (r *Response, err error)
  // Starts a cron job immediately.  The request will be denied if the specified job does not
  // exist for the role account, or the job is not a cron job.
  // 
  // Parameters:
  //  - Job
  StartCronJob(ctx context.Context, job *JobKey) (r *Response, err error)
  // Restarts a batch of shards.
  // 
  // Parameters:
  //  - Job
  //  - ShardIds
  RestartShards(ctx context.Context, job *JobKey, shardIds []int32) (r *Response, err error)
  // Initiates a kill on tasks.
  // 
  // Parameters:
  //  - Job
  //  - Instances
  //  - Message
  KillTasks(ctx context.Context, job *JobKey, instances []int32, message string) (r *Response, err error)
  // Adds new instances with the TaskConfig of the existing instance pointed by the key.
  // 
  // Parameters:
  //  - Key
  //  - Count
  AddInstances(ctx context.Context, key *InstanceKey, count int32) (r *Response, err error)
  // Replaces the template (configuration) for the existing cron job.
  // The cron job template (configuration) must exist for the call to succeed.
  // 
  // Parameters:
  //  - Config
  ReplaceCronTemplate(ctx context.Context, config *JobConfiguration) (r *Response, err error)
  // Starts update of the existing service job.
  // 
  // Parameters:
  //  - Request: A description of how to change the job.
  //  - Message: A user-specified message to include with the induced job update state change.
  StartJobUpdate(ctx context.Context, request *JobUpdateRequest, message string) (r *Response, err error)
  // Pauses the specified job update. Can be resumed by resumeUpdate call.
  // 
  // Parameters:
  //  - Key: The update to pause.
  //  - Message: A user-specified message to include with the induced job update state change.
  PauseJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error)
  // Resumes progress of a previously paused job update.
  // 
  // Parameters:
  //  - Key: The update to resume.
  //  - Message: A user-specified message to include with the induced job update state change.
  ResumeJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error)
  // Permanently aborts the job update. Does not remove the update history.
  // 
  // Parameters:
  //  - Key: The update to abort.
  //  - Message: A user-specified message to include with the induced job update state change.
  AbortJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error)
  // Rollbacks the specified active job update to the initial state.
  // 
  // Parameters:
  //  - Key: The update to rollback.
  //  - Message: A user-specified message to include with the induced job update state change.
  RollbackJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error)
  // Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in
  // JobUpdateSettings. Unblocks progress if the update was previously blocked.
  // Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.
  // 
  // Parameters:
  //  - Key
  PulseJobUpdate(ctx context.Context, key *JobUpdateKey) (r *Response, err error)
}

type AuroraSchedulerManagerClient struct {
  *ReadOnlySchedulerClient
}

func NewAuroraSchedulerManagerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *AuroraSchedulerManagerClient {
  return &AuroraSchedulerManagerClient{ReadOnlySchedulerClient: NewReadOnlySchedulerClientFactory(t, f)}}

func NewAuroraSchedulerManagerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *AuroraSchedulerManagerClient {
  return &AuroraSchedulerManagerClient{ReadOnlySchedulerClient: NewReadOnlySchedulerClientProtocol(t, iprot, oprot)}
}

func NewAuroraSchedulerManagerClient(c thrift.TClient) *AuroraSchedulerManagerClient {
  return &AuroraSchedulerManagerClient{
    ReadOnlySchedulerClient: NewReadOnlySchedulerClient(c),
  }
}

// Creates a new job.  The request will be denied if a job with the provided name already exists
// in the cluster.
// 
// Parameters:
//  - Description
func (p *AuroraSchedulerManagerClient) CreateJob(ctx context.Context, description *JobConfiguration) (r *Response, err error) {
  var _args182 AuroraSchedulerManagerCreateJobArgs
  _args182.Description = description
  var _result183 AuroraSchedulerManagerCreateJobResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "createJob", &_args182, &_result183)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result183.GetSuccess(), nil
}

// Enters a job into the cron schedule, without actually starting the job.
// If the job is already present in the schedule, this will update the schedule entry with the new
// configuration.
// 
// Parameters:
//  - Description
func (p *AuroraSchedulerManagerClient) ScheduleCronJob(ctx context.Context, description *JobConfiguration) (r *Response, err error) {
  var _args184 AuroraSchedulerManagerScheduleCronJobArgs
  _args184.Description = description
  var _result185 AuroraSchedulerManagerScheduleCronJobResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "scheduleCronJob", &_args184, &_result185)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result185.GetSuccess(), nil
}

// Removes a job from the cron schedule. The request will be denied if the job was not previously
// scheduled with scheduleCronJob.
// 
// Parameters:
//  - Job
func (p *AuroraSchedulerManagerClient) DescheduleCronJob(ctx context.Context, job *JobKey) (r *Response, err error) {
  var _args186 AuroraSchedulerManagerDescheduleCronJobArgs
  _args186.Job = job
  var _result187 AuroraSchedulerManagerDescheduleCronJobResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "descheduleCronJob", &_args186, &_result187)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result187.GetSuccess(), nil
}

// Starts a cron job immediately.  The request will be denied if the specified job does not
// exist for the role account, or the job is not a cron job.
// 
// Parameters:
//  - Job
func (p *AuroraSchedulerManagerClient) StartCronJob(ctx context.Context, job *JobKey) (r *Response, err error) {
  var _args188 AuroraSchedulerManagerStartCronJobArgs
  _args188.Job = job
  var _result189 AuroraSchedulerManagerStartCronJobResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "startCronJob", &_args188, &_result189)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result189.GetSuccess(), nil
}

// Restarts a batch of shards.
// 
// Parameters:
//  - Job
//  - ShardIds
func (p *AuroraSchedulerManagerClient) RestartShards(ctx context.Context, job *JobKey, shardIds []int32) (r *Response, err error) {
  var _args190 AuroraSchedulerManagerRestartShardsArgs
  _args190.Job = job
  _args190.ShardIds = shardIds
  var _result191 AuroraSchedulerManagerRestartShardsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "restartShards", &_args190, &_result191)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result191.GetSuccess(), nil
}

// Initiates a kill on tasks.
// 
// Parameters:
//  - Job
//  - Instances
//  - Message
func (p *AuroraSchedulerManagerClient) KillTasks(ctx context.Context, job *JobKey, instances []int32, message string) (r *Response, err error) {
  var _args192 AuroraSchedulerManagerKillTasksArgs
  _args192.Job = job
  _args192.Instances = instances
  _args192.Message = message
  var _result193 AuroraSchedulerManagerKillTasksResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "killTasks", &_args192, &_result193)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result193.GetSuccess(), nil
}

// Adds new instances with the TaskConfig of the existing instance pointed by the key.
// 
// Parameters:
//  - Key
//  - Count
func (p *AuroraSchedulerManagerClient) AddInstances(ctx context.Context, key *InstanceKey, count int32) (r *Response, err error) {
  var _args194 AuroraSchedulerManagerAddInstancesArgs
  _args194.Key = key
  _args194.Count = count
  var _result195 AuroraSchedulerManagerAddInstancesResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "addInstances", &_args194, &_result195)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result195.GetSuccess(), nil
}

// Replaces the template (configuration) for the existing cron job.
// The cron job template (configuration) must exist for the call to succeed.
// 
// Parameters:
//  - Config
func (p *AuroraSchedulerManagerClient) ReplaceCronTemplate(ctx context.Context, config *JobConfiguration) (r *Response, err error) {
  var _args196 AuroraSchedulerManagerReplaceCronTemplateArgs
  _args196.Config = config
  var _result197 AuroraSchedulerManagerReplaceCronTemplateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "replaceCronTemplate", &_args196, &_result197)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result197.GetSuccess(), nil
}

// Starts update of the existing service job.
// 
// Parameters:
//  - Request: A description of how to change the job.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) StartJobUpdate(ctx context.Context, request *JobUpdateRequest, message string) (r *Response, err error) {
  var _args198 AuroraSchedulerManagerStartJobUpdateArgs
  _args198.Request = request
  _args198.Message = message
  var _result199 AuroraSchedulerManagerStartJobUpdateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "startJobUpdate", &_args198, &_result199)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result199.GetSuccess(), nil
}

// Pauses the specified job update. Can be resumed by resumeUpdate call.
// 
// Parameters:
//  - Key: The update to pause.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) PauseJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error) {
  var _args200 AuroraSchedulerManagerPauseJobUpdateArgs
  _args200.Key = key
  _args200.Message = message
  var _result201 AuroraSchedulerManagerPauseJobUpdateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "pauseJobUpdate", &_args200, &_result201)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result201.GetSuccess(), nil
}

// Resumes progress of a previously paused job update.
// 
// Parameters:
//  - Key: The update to resume.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) ResumeJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error) {
  var _args202 AuroraSchedulerManagerResumeJobUpdateArgs
  _args202.Key = key
  _args202.Message = message
  var _result203 AuroraSchedulerManagerResumeJobUpdateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "resumeJobUpdate", &_args202, &_result203)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result203.GetSuccess(), nil
}

// Permanently aborts the job update. Does not remove the update history.
// 
// Parameters:
//  - Key: The update to abort.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) AbortJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error) {
  var _args204 AuroraSchedulerManagerAbortJobUpdateArgs
  _args204.Key = key
  _args204.Message = message
  var _result205 AuroraSchedulerManagerAbortJobUpdateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "abortJobUpdate", &_args204, &_result205)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result205.GetSuccess(), nil
}

// Rollbacks the specified active job update to the initial state.
// 
// Parameters:
//  - Key: The update to rollback.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) RollbackJobUpdate(ctx context.Context, key *JobUpdateKey, message string) (r *Response, err error) {
  var _args206 AuroraSchedulerManagerRollbackJobUpdateArgs
  _args206.Key = key
  _args206.Message = message
  var _result207 AuroraSchedulerManagerRollbackJobUpdateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "rollbackJobUpdate", &_args206, &_result207)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result207.GetSuccess(), nil
}

// Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in
// JobUpdateSettings. Unblocks progress if the update was previously blocked.
// Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.
// 
// Parameters:
//  - Key
func (p *AuroraSchedulerManagerClient) PulseJobUpdate(ctx context.Context, key *JobUpdateKey) (r *Response, err error) {
  var _args208 AuroraSchedulerManagerPulseJobUpdateArgs
  _args208.Key = key
  var _result209 AuroraSchedulerManagerPulseJobUpdateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "pulseJobUpdate", &_args208, &_result209)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result209.GetSuccess(), nil
}

type AuroraSchedulerManagerProcessor struct {
  *ReadOnlySchedulerProcessor
}

func NewAuroraSchedulerManagerProcessor(handler AuroraSchedulerManager) *AuroraSchedulerManagerProcessor {
  self210 := &AuroraSchedulerManagerProcessor{NewReadOnlySchedulerProcessor(handler)}
  self210.AddToProcessorMap("createJob", &auroraSchedulerManagerProcessorCreateJob{handler:handler})
  self210.AddToProcessorMap("scheduleCronJob", &auroraSchedulerManagerProcessorScheduleCronJob{handler:handler})
  self210.AddToProcessorMap("descheduleCronJob", &auroraSchedulerManagerProcessorDescheduleCronJob{handler:handler})
  self210.AddToProcessorMap("startCronJob", &auroraSchedulerManagerProcessorStartCronJob{handler:handler})
  self210.AddToProcessorMap("restartShards", &auroraSchedulerManagerProcessorRestartShards{handler:handler})
  self210.AddToProcessorMap("killTasks", &auroraSchedulerManagerProcessorKillTasks{handler:handler})
  self210.AddToProcessorMap("addInstances", &auroraSchedulerManagerProcessorAddInstances{handler:handler})
  self210.AddToProcessorMap("replaceCronTemplate", &auroraSchedulerManagerProcessorReplaceCronTemplate{handler:handler})
  self210.AddToProcessorMap("startJobUpdate", &auroraSchedulerManagerProcessorStartJobUpdate{handler:handler})
  self210.AddToProcessorMap("pauseJobUpdate", &auroraSchedulerManagerProcessorPauseJobUpdate{handler:handler})
  self210.AddToProcessorMap("resumeJobUpdate", &auroraSchedulerManagerProcessorResumeJobUpdate{handler:handler})
  self210.AddToProcessorMap("abortJobUpdate", &auroraSchedulerManagerProcessorAbortJobUpdate{handler:handler})
  self210.AddToProcessorMap("rollbackJobUpdate", &auroraSchedulerManagerProcessorRollbackJobUpdate{handler:handler})
  self210.AddToProcessorMap("pulseJobUpdate", &auroraSchedulerManagerProcessorPulseJobUpdate{handler:handler})
  return self210
}

type auroraSchedulerManagerProcessorCreateJob struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorCreateJob) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerCreateJobArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "createJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerCreateJobResult{}
  var retval *Response
  if retval, err2 = p.handler.CreateJob(ctx, args.Description); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createJob: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "createJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "createJob", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorScheduleCronJob struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorScheduleCronJob) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerScheduleCronJobArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "scheduleCronJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerScheduleCronJobResult{}
  var retval *Response
  if retval, err2 = p.handler.ScheduleCronJob(ctx, args.Description); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scheduleCronJob: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "scheduleCronJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "scheduleCronJob", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorDescheduleCronJob struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorDescheduleCronJob) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerDescheduleCronJobArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "descheduleCronJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerDescheduleCronJobResult{}
  var retval *Response
  if retval, err2 = p.handler.DescheduleCronJob(ctx, args.Job); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing descheduleCronJob: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "descheduleCronJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "descheduleCronJob", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorStartCronJob struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorStartCronJob) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerStartCronJobArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "startCronJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerStartCronJobResult{}
  var retval *Response
  if retval, err2 = p.handler.StartCronJob(ctx, args.Job); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startCronJob: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "startCronJob", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "startCronJob", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorRestartShards struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorRestartShards) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerRestartShardsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "restartShards", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerRestartShardsResult{}
  var retval *Response
  if retval, err2 = p.handler.RestartShards(ctx, args.Job, args.ShardIds); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing restartShards: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "restartShards", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "restartShards", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorKillTasks struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorKillTasks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerKillTasksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "killTasks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerKillTasksResult{}
  var retval *Response
  if retval, err2 = p.handler.KillTasks(ctx, args.Job, args.Instances, args.Message); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing killTasks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "killTasks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "killTasks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorAddInstances struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorAddInstances) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerAddInstancesArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "addInstances", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerAddInstancesResult{}
  var retval *Response
  if retval, err2 = p.handler.AddInstances(ctx, args.Key, args.Count); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addInstances: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "addInstances", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "addInstances", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorReplaceCronTemplate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorReplaceCronTemplate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerReplaceCronTemplateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "replaceCronTemplate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerReplaceCronTemplateResult{}
  var retval *Response
  if retval, err2 = p.handler.ReplaceCronTemplate(ctx, args.Config); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing replaceCronTemplate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "replaceCronTemplate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "replaceCronTemplate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorStartJobUpdate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorStartJobUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerStartJobUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "startJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerStartJobUpdateResult{}
  var retval *Response
  if retval, err2 = p.handler.StartJobUpdate(ctx, args.Request, args.Message); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startJobUpdate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "startJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "startJobUpdate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorPauseJobUpdate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorPauseJobUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerPauseJobUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pauseJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerPauseJobUpdateResult{}
  var retval *Response
  if retval, err2 = p.handler.PauseJobUpdate(ctx, args.Key, args.Message); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pauseJobUpdate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pauseJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pauseJobUpdate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorResumeJobUpdate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorResumeJobUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerResumeJobUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "resumeJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerResumeJobUpdateResult{}
  var retval *Response
  if retval, err2 = p.handler.ResumeJobUpdate(ctx, args.Key, args.Message); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing resumeJobUpdate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "resumeJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "resumeJobUpdate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorAbortJobUpdate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorAbortJobUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerAbortJobUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "abortJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerAbortJobUpdateResult{}
  var retval *Response
  if retval, err2 = p.handler.AbortJobUpdate(ctx, args.Key, args.Message); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing abortJobUpdate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "abortJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "abortJobUpdate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorRollbackJobUpdate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorRollbackJobUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerRollbackJobUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "rollbackJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerRollbackJobUpdateResult{}
  var retval *Response
  if retval, err2 = p.handler.RollbackJobUpdate(ctx, args.Key, args.Message); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing rollbackJobUpdate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "rollbackJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "rollbackJobUpdate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraSchedulerManagerProcessorPulseJobUpdate struct {
  handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorPulseJobUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraSchedulerManagerPulseJobUpdateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pulseJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraSchedulerManagerPulseJobUpdateResult{}
  var retval *Response
  if retval, err2 = p.handler.PulseJobUpdate(ctx, args.Key); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pulseJobUpdate: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pulseJobUpdate", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pulseJobUpdate", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Description
type AuroraSchedulerManagerCreateJobArgs struct {
  Description *JobConfiguration `thrift:"description,1" db:"description" json:"description"`
}

func NewAuroraSchedulerManagerCreateJobArgs() *AuroraSchedulerManagerCreateJobArgs {
  return &AuroraSchedulerManagerCreateJobArgs{}
}

var AuroraSchedulerManagerCreateJobArgs_Description_DEFAULT *JobConfiguration
func (p *AuroraSchedulerManagerCreateJobArgs) GetDescription() *JobConfiguration {
  if !p.IsSetDescription() {
    return AuroraSchedulerManagerCreateJobArgs_Description_DEFAULT
  }
return p.Description
}
func (p *AuroraSchedulerManagerCreateJobArgs) IsSetDescription() bool {
  return p.Description != nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerCreateJobArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Description = &JobConfiguration{}
  if err := p.Description.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Description), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createJob_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "description", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:description: ", p), err) }
  if err := p.Description.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Description), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:description: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerCreateJobArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerCreateJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerCreateJobResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerCreateJobResult() *AuroraSchedulerManagerCreateJobResult {
  return &AuroraSchedulerManagerCreateJobResult{}
}

var AuroraSchedulerManagerCreateJobResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerCreateJobResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerCreateJobResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerCreateJobResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerCreateJobResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerCreateJobResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerCreateJobResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "createJob_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerCreateJobResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerCreateJobResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerCreateJobResult(%+v)", *p)
}

// Attributes:
//  - Description
type AuroraSchedulerManagerScheduleCronJobArgs struct {
  Description *JobConfiguration `thrift:"description,1" db:"description" json:"description"`
}

func NewAuroraSchedulerManagerScheduleCronJobArgs() *AuroraSchedulerManagerScheduleCronJobArgs {
  return &AuroraSchedulerManagerScheduleCronJobArgs{}
}

var AuroraSchedulerManagerScheduleCronJobArgs_Description_DEFAULT *JobConfiguration
func (p *AuroraSchedulerManagerScheduleCronJobArgs) GetDescription() *JobConfiguration {
  if !p.IsSetDescription() {
    return AuroraSchedulerManagerScheduleCronJobArgs_Description_DEFAULT
  }
return p.Description
}
func (p *AuroraSchedulerManagerScheduleCronJobArgs) IsSetDescription() bool {
  return p.Description != nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Description = &JobConfiguration{}
  if err := p.Description.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Description), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scheduleCronJob_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "description", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:description: ", p), err) }
  if err := p.Description.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Description), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:description: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerScheduleCronJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerScheduleCronJobResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerScheduleCronJobResult() *AuroraSchedulerManagerScheduleCronJobResult {
  return &AuroraSchedulerManagerScheduleCronJobResult{}
}

var AuroraSchedulerManagerScheduleCronJobResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerScheduleCronJobResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerScheduleCronJobResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerScheduleCronJobResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scheduleCronJob_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerScheduleCronJobResult(%+v)", *p)
}

// Attributes:
//  - Job
type AuroraSchedulerManagerDescheduleCronJobArgs struct {
  // unused fields # 1 to 3
  Job *JobKey `thrift:"job,4" db:"job" json:"job"`
}

func NewAuroraSchedulerManagerDescheduleCronJobArgs() *AuroraSchedulerManagerDescheduleCronJobArgs {
  return &AuroraSchedulerManagerDescheduleCronJobArgs{}
}

var AuroraSchedulerManagerDescheduleCronJobArgs_Job_DEFAULT *JobKey
func (p *AuroraSchedulerManagerDescheduleCronJobArgs) GetJob() *JobKey {
  if !p.IsSetJob() {
    return AuroraSchedulerManagerDescheduleCronJobArgs_Job_DEFAULT
  }
return p.Job
}
func (p *AuroraSchedulerManagerDescheduleCronJobArgs) IsSetJob() bool {
  return p.Job != nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "descheduleCronJob_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:job: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerDescheduleCronJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerDescheduleCronJobResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerDescheduleCronJobResult() *AuroraSchedulerManagerDescheduleCronJobResult {
  return &AuroraSchedulerManagerDescheduleCronJobResult{}
}

var AuroraSchedulerManagerDescheduleCronJobResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerDescheduleCronJobResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerDescheduleCronJobResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerDescheduleCronJobResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "descheduleCronJob_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerDescheduleCronJobResult(%+v)", *p)
}

// Attributes:
//  - Job
type AuroraSchedulerManagerStartCronJobArgs struct {
  // unused fields # 1 to 3
  Job *JobKey `thrift:"job,4" db:"job" json:"job"`
}

func NewAuroraSchedulerManagerStartCronJobArgs() *AuroraSchedulerManagerStartCronJobArgs {
  return &AuroraSchedulerManagerStartCronJobArgs{}
}

var AuroraSchedulerManagerStartCronJobArgs_Job_DEFAULT *JobKey
func (p *AuroraSchedulerManagerStartCronJobArgs) GetJob() *JobKey {
  if !p.IsSetJob() {
    return AuroraSchedulerManagerStartCronJobArgs_Job_DEFAULT
  }
return p.Job
}
func (p *AuroraSchedulerManagerStartCronJobArgs) IsSetJob() bool {
  return p.Job != nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startCronJob_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:job: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerStartCronJobArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerStartCronJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerStartCronJobResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerStartCronJobResult() *AuroraSchedulerManagerStartCronJobResult {
  return &AuroraSchedulerManagerStartCronJobResult{}
}

var AuroraSchedulerManagerStartCronJobResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerStartCronJobResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerStartCronJobResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerStartCronJobResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartCronJobResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startCronJob_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerStartCronJobResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerStartCronJobResult(%+v)", *p)
}

// Attributes:
//  - Job
//  - ShardIds
type AuroraSchedulerManagerRestartShardsArgs struct {
  // unused fields # 1 to 2
  ShardIds []int32 `thrift:"shardIds,3" db:"shardIds" json:"shardIds"`
  // unused field # 4
  Job *JobKey `thrift:"job,5" db:"job" json:"job"`
}

func NewAuroraSchedulerManagerRestartShardsArgs() *AuroraSchedulerManagerRestartShardsArgs {
  return &AuroraSchedulerManagerRestartShardsArgs{}
}

var AuroraSchedulerManagerRestartShardsArgs_Job_DEFAULT *JobKey
func (p *AuroraSchedulerManagerRestartShardsArgs) GetJob() *JobKey {
  if !p.IsSetJob() {
    return AuroraSchedulerManagerRestartShardsArgs_Job_DEFAULT
  }
return p.Job
}

func (p *AuroraSchedulerManagerRestartShardsArgs) GetShardIds() []int32 {
  return p.ShardIds
}
func (p *AuroraSchedulerManagerRestartShardsArgs) IsSetJob() bool {
  return p.Job != nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]int32, 0, size)
  p.ShardIds =  tSet
  for i := 0; i < size; i ++ {
var _elem211 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem211 = v
}
    p.ShardIds = append(p.ShardIds, _elem211)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "restartShards_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "shardIds", thrift.SET, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:shardIds: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.ShardIds)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.ShardIds); i++ {
    for j := i+1; j<len(p.ShardIds); j++ {
      if func(tgt, src int32) bool {
        if tgt != src { return false }
        return true
      }(p.ShardIds[i], p.ShardIds[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.ShardIds))
      }
    }
  }
  for _, v := range p.ShardIds {
    if err := oprot.WriteI32(ctx, int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:shardIds: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerRestartShardsArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:job: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerRestartShardsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerRestartShardsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerRestartShardsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerRestartShardsResult() *AuroraSchedulerManagerRestartShardsResult {
  return &AuroraSchedulerManagerRestartShardsResult{}
}

var AuroraSchedulerManagerRestartShardsResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerRestartShardsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerRestartShardsResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerRestartShardsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "restartShards_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerRestartShardsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerRestartShardsResult(%+v)", *p)
}

// Attributes:
//  - Job
//  - Instances
//  - Message
type AuroraSchedulerManagerKillTasksArgs struct {
  // unused fields # 1 to 3
  Job *JobKey `thrift:"job,4" db:"job" json:"job"`
  Instances []int32 `thrift:"instances,5" db:"instances" json:"instances"`
  Message string `thrift:"message,6" db:"message" json:"message"`
}

func NewAuroraSchedulerManagerKillTasksArgs() *AuroraSchedulerManagerKillTasksArgs {
  return &AuroraSchedulerManagerKillTasksArgs{}
}

var AuroraSchedulerManagerKillTasksArgs_Job_DEFAULT *JobKey
func (p *AuroraSchedulerManagerKillTasksArgs) GetJob() *JobKey {
  if !p.IsSetJob() {
    return AuroraSchedulerManagerKillTasksArgs_Job_DEFAULT
  }
return p.Job
}

func (p *AuroraSchedulerManagerKillTasksArgs) GetInstances() []int32 {
  return p.Instances
}

func (p *AuroraSchedulerManagerKillTasksArgs) GetMessage() string {
  return p.Message
}
func (p *AuroraSchedulerManagerKillTasksArgs) IsSetJob() bool {
  return p.Job != nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.SET {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Job = &JobKey{}
  if err := p.Job.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadSetBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
  }
  tSet := make([]int32, 0, size)
  p.Instances =  tSet
  for i := 0; i < size; i ++ {
var _elem212 int32
    if v, err := iprot.ReadI32(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem212 = v
}
    p.Instances = append(p.Instances, _elem212)
  }
  if err := iprot.ReadSetEnd(ctx); err != nil {
    return thrift.PrependError("error reading set end: ", err)
  }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "killTasks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "job", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:job: ", p), err) }
  if err := p.Job.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:job: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerKillTasksArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "instances", thrift.SET, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:instances: ", p), err) }
  if err := oprot.WriteSetBegin(ctx, thrift.I32, len(p.Instances)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
  }
  for i := 0; i<len(p.Instances); i++ {
    for j := i+1; j<len(p.Instances); j++ {
      if func(tgt, src int32) bool {
        if tgt != src { return false }
        return true
      }(p.Instances[i], p.Instances[j]) {
        return thrift.PrependError("", fmt.Errorf("%T error writing set field: slice is not unique", p.Instances))
      }
    }
  }
  for _, v := range p.Instances {
    if err := oprot.WriteI32(ctx, int32(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteSetEnd(ctx); err != nil {
    return thrift.PrependError("error writing set end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:instances: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerKillTasksArgs) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:message: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerKillTasksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerKillTasksArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerKillTasksResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerKillTasksResult() *AuroraSchedulerManagerKillTasksResult {
  return &AuroraSchedulerManagerKillTasksResult{}
}

var AuroraSchedulerManagerKillTasksResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerKillTasksResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerKillTasksResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerKillTasksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerKillTasksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "killTasks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerKillTasksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerKillTasksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerKillTasksResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - Count
type AuroraSchedulerManagerAddInstancesArgs struct {
  // unused fields # 1 to 2
  Key *InstanceKey `thrift:"key,3" db:"key" json:"key"`
  Count int32 `thrift:"count,4" db:"count" json:"count"`
}

func NewAuroraSchedulerManagerAddInstancesArgs() *AuroraSchedulerManagerAddInstancesArgs {
  return &AuroraSchedulerManagerAddInstancesArgs{}
}

var AuroraSchedulerManagerAddInstancesArgs_Key_DEFAULT *InstanceKey
func (p *AuroraSchedulerManagerAddInstancesArgs) GetKey() *InstanceKey {
  if !p.IsSetKey() {
    return AuroraSchedulerManagerAddInstancesArgs_Key_DEFAULT
  }
return p.Key
}

func (p *AuroraSchedulerManagerAddInstancesArgs) GetCount() int32 {
  return p.Count
}
func (p *AuroraSchedulerManagerAddInstancesArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &InstanceKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Count = v
}
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "addInstances_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerAddInstancesArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "count", thrift.I32, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:count: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Count)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.count (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:count: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerAddInstancesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerAddInstancesArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerAddInstancesResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerAddInstancesResult() *AuroraSchedulerManagerAddInstancesResult {
  return &AuroraSchedulerManagerAddInstancesResult{}
}

var AuroraSchedulerManagerAddInstancesResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerAddInstancesResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerAddInstancesResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerAddInstancesResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "addInstances_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerAddInstancesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerAddInstancesResult(%+v)", *p)
}

// Attributes:
//  - Config
type AuroraSchedulerManagerReplaceCronTemplateArgs struct {
  Config *JobConfiguration `thrift:"config,1" db:"config" json:"config"`
}

func NewAuroraSchedulerManagerReplaceCronTemplateArgs() *AuroraSchedulerManagerReplaceCronTemplateArgs {
  return &AuroraSchedulerManagerReplaceCronTemplateArgs{}
}

var AuroraSchedulerManagerReplaceCronTemplateArgs_Config_DEFAULT *JobConfiguration
func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) GetConfig() *JobConfiguration {
  if !p.IsSetConfig() {
    return AuroraSchedulerManagerReplaceCronTemplateArgs_Config_DEFAULT
  }
return p.Config
}
func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) IsSetConfig() bool {
  return p.Config != nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Config = &JobConfiguration{}
  if err := p.Config.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Config), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "replaceCronTemplate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "config", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:config: ", p), err) }
  if err := p.Config.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Config), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:config: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerReplaceCronTemplateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerReplaceCronTemplateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerReplaceCronTemplateResult() *AuroraSchedulerManagerReplaceCronTemplateResult {
  return &AuroraSchedulerManagerReplaceCronTemplateResult{}
}

var AuroraSchedulerManagerReplaceCronTemplateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerReplaceCronTemplateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerReplaceCronTemplateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerReplaceCronTemplateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "replaceCronTemplate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerReplaceCronTemplateResult(%+v)", *p)
}

// Attributes:
//  - Request: A description of how to change the job.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerStartJobUpdateArgs struct {
  Request *JobUpdateRequest `thrift:"request,1" db:"request" json:"request"`
  // unused field # 2
  Message string `thrift:"message,3" db:"message" json:"message"`
}

func NewAuroraSchedulerManagerStartJobUpdateArgs() *AuroraSchedulerManagerStartJobUpdateArgs {
  return &AuroraSchedulerManagerStartJobUpdateArgs{}
}

var AuroraSchedulerManagerStartJobUpdateArgs_Request_DEFAULT *JobUpdateRequest
func (p *AuroraSchedulerManagerStartJobUpdateArgs) GetRequest() *JobUpdateRequest {
  if !p.IsSetRequest() {
    return AuroraSchedulerManagerStartJobUpdateArgs_Request_DEFAULT
  }
return p.Request
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) GetMessage() string {
  return p.Message
}
func (p *AuroraSchedulerManagerStartJobUpdateArgs) IsSetRequest() bool {
  return p.Request != nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Request = &JobUpdateRequest{}
  if err := p.Request.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startJobUpdate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err) }
  if err := p.Request.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerStartJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerStartJobUpdateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerStartJobUpdateResult() *AuroraSchedulerManagerStartJobUpdateResult {
  return &AuroraSchedulerManagerStartJobUpdateResult{}
}

var AuroraSchedulerManagerStartJobUpdateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerStartJobUpdateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerStartJobUpdateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerStartJobUpdateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startJobUpdate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerStartJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to pause.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerPauseJobUpdateArgs struct {
  Key *JobUpdateKey `thrift:"key,1" db:"key" json:"key"`
  // unused field # 2
  Message string `thrift:"message,3" db:"message" json:"message"`
}

func NewAuroraSchedulerManagerPauseJobUpdateArgs() *AuroraSchedulerManagerPauseJobUpdateArgs {
  return &AuroraSchedulerManagerPauseJobUpdateArgs{}
}

var AuroraSchedulerManagerPauseJobUpdateArgs_Key_DEFAULT *JobUpdateKey
func (p *AuroraSchedulerManagerPauseJobUpdateArgs) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return AuroraSchedulerManagerPauseJobUpdateArgs_Key_DEFAULT
  }
return p.Key
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) GetMessage() string {
  return p.Message
}
func (p *AuroraSchedulerManagerPauseJobUpdateArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pauseJobUpdate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerPauseJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerPauseJobUpdateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerPauseJobUpdateResult() *AuroraSchedulerManagerPauseJobUpdateResult {
  return &AuroraSchedulerManagerPauseJobUpdateResult{}
}

var AuroraSchedulerManagerPauseJobUpdateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerPauseJobUpdateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerPauseJobUpdateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerPauseJobUpdateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pauseJobUpdate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerPauseJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to resume.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerResumeJobUpdateArgs struct {
  Key *JobUpdateKey `thrift:"key,1" db:"key" json:"key"`
  // unused field # 2
  Message string `thrift:"message,3" db:"message" json:"message"`
}

func NewAuroraSchedulerManagerResumeJobUpdateArgs() *AuroraSchedulerManagerResumeJobUpdateArgs {
  return &AuroraSchedulerManagerResumeJobUpdateArgs{}
}

var AuroraSchedulerManagerResumeJobUpdateArgs_Key_DEFAULT *JobUpdateKey
func (p *AuroraSchedulerManagerResumeJobUpdateArgs) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return AuroraSchedulerManagerResumeJobUpdateArgs_Key_DEFAULT
  }
return p.Key
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) GetMessage() string {
  return p.Message
}
func (p *AuroraSchedulerManagerResumeJobUpdateArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "resumeJobUpdate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerResumeJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerResumeJobUpdateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerResumeJobUpdateResult() *AuroraSchedulerManagerResumeJobUpdateResult {
  return &AuroraSchedulerManagerResumeJobUpdateResult{}
}

var AuroraSchedulerManagerResumeJobUpdateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerResumeJobUpdateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerResumeJobUpdateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerResumeJobUpdateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "resumeJobUpdate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerResumeJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to abort.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerAbortJobUpdateArgs struct {
  Key *JobUpdateKey `thrift:"key,1" db:"key" json:"key"`
  // unused field # 2
  Message string `thrift:"message,3" db:"message" json:"message"`
}

func NewAuroraSchedulerManagerAbortJobUpdateArgs() *AuroraSchedulerManagerAbortJobUpdateArgs {
  return &AuroraSchedulerManagerAbortJobUpdateArgs{}
}

var AuroraSchedulerManagerAbortJobUpdateArgs_Key_DEFAULT *JobUpdateKey
func (p *AuroraSchedulerManagerAbortJobUpdateArgs) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return AuroraSchedulerManagerAbortJobUpdateArgs_Key_DEFAULT
  }
return p.Key
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) GetMessage() string {
  return p.Message
}
func (p *AuroraSchedulerManagerAbortJobUpdateArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "abortJobUpdate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerAbortJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerAbortJobUpdateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerAbortJobUpdateResult() *AuroraSchedulerManagerAbortJobUpdateResult {
  return &AuroraSchedulerManagerAbortJobUpdateResult{}
}

var AuroraSchedulerManagerAbortJobUpdateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerAbortJobUpdateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerAbortJobUpdateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerAbortJobUpdateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "abortJobUpdate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerAbortJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to rollback.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerRollbackJobUpdateArgs struct {
  Key *JobUpdateKey `thrift:"key,1" db:"key" json:"key"`
  Message string `thrift:"message,2" db:"message" json:"message"`
}

func NewAuroraSchedulerManagerRollbackJobUpdateArgs() *AuroraSchedulerManagerRollbackJobUpdateArgs {
  return &AuroraSchedulerManagerRollbackJobUpdateArgs{}
}

var AuroraSchedulerManagerRollbackJobUpdateArgs_Key_DEFAULT *JobUpdateKey
func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return AuroraSchedulerManagerRollbackJobUpdateArgs_Key_DEFAULT
  }
return p.Key
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) GetMessage() string {
  return p.Message
}
func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "rollbackJobUpdate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerRollbackJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerRollbackJobUpdateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerRollbackJobUpdateResult() *AuroraSchedulerManagerRollbackJobUpdateResult {
  return &AuroraSchedulerManagerRollbackJobUpdateResult{}
}

var AuroraSchedulerManagerRollbackJobUpdateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerRollbackJobUpdateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerRollbackJobUpdateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerRollbackJobUpdateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "rollbackJobUpdate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerRollbackJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key
type AuroraSchedulerManagerPulseJobUpdateArgs struct {
  Key *JobUpdateKey `thrift:"key,1" db:"key" json:"key"`
}

func NewAuroraSchedulerManagerPulseJobUpdateArgs() *AuroraSchedulerManagerPulseJobUpdateArgs {
  return &AuroraSchedulerManagerPulseJobUpdateArgs{}
}

var AuroraSchedulerManagerPulseJobUpdateArgs_Key_DEFAULT *JobUpdateKey
func (p *AuroraSchedulerManagerPulseJobUpdateArgs) GetKey() *JobUpdateKey {
  if !p.IsSetKey() {
    return AuroraSchedulerManagerPulseJobUpdateArgs_Key_DEFAULT
  }
return p.Key
}
func (p *AuroraSchedulerManagerPulseJobUpdateArgs) IsSetKey() bool {
  return p.Key != nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Key = &JobUpdateKey{}
  if err := p.Key.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pulseJobUpdate_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err) }
  if err := p.Key.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err) }
  return err
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerPulseJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerPulseJobUpdateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerPulseJobUpdateResult() *AuroraSchedulerManagerPulseJobUpdateResult {
  return &AuroraSchedulerManagerPulseJobUpdateResult{}
}

var AuroraSchedulerManagerPulseJobUpdateResult_Success_DEFAULT *Response
func (p *AuroraSchedulerManagerPulseJobUpdateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraSchedulerManagerPulseJobUpdateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraSchedulerManagerPulseJobUpdateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pulseJobUpdate_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraSchedulerManagerPulseJobUpdateResult(%+v)", *p)
}


type AuroraAdmin interface {
AuroraSchedulerManager

  // Assign quota to a user.  This will overwrite any pre-existing quota for the user.
  // 
  // Parameters:
  //  - OwnerRole
  //  - Quota
  SetQuota(ctx context.Context, ownerRole string, quota *ResourceAggregate) (r *Response, err error)
  // Forces a task into a specific state.  This does not guarantee the task will enter the given
  // state, as the task must still transition within the bounds of the state machine.  However,
  // it attempts to enter that state via the state machine.
  // 
  // Parameters:
  //  - TaskId
  //  - Status
  ForceTaskState(ctx context.Context, taskId string, status ScheduleStatus) (r *Response, err error)
  // Immediately writes a storage snapshot to disk.
  PerformBackup(ctx context.Context) (r *Response, err error)
  // Lists backups that are available for recovery.
  ListBackups(ctx context.Context) (r *Response, err error)
  // Loads a backup to an in-memory storage.  This must precede all other recovery operations.
  // 
  // Parameters:
  //  - BackupId
  StageRecovery(ctx context.Context, backupId string) (r *Response, err error)
  // Queries for tasks in a staged recovery.
  // 
  // Parameters:
  //  - Query
  QueryRecovery(ctx context.Context, query *TaskQuery) (r *Response, err error)
  // Deletes tasks from a staged recovery.
  // 
  // Parameters:
  //  - Query
  DeleteRecoveryTasks(ctx context.Context, query *TaskQuery) (r *Response, err error)
  // Commits a staged recovery, completely replacing the previous storage state.
  CommitRecovery(ctx context.Context) (r *Response, err error)
  // Unloads (aborts) a staged recovery.
  UnloadRecovery(ctx context.Context) (r *Response, err error)
  // Put the given hosts into maintenance mode.
  // 
  // Parameters:
  //  - Hosts
  StartMaintenance(ctx context.Context, hosts *Hosts) (r *Response, err error)
  // Ask scheduler to begin moving tasks scheduled on given hosts.
  // 
  // Parameters:
  //  - Hosts
  DrainHosts(ctx context.Context, hosts *Hosts) (r *Response, err error)
  // Retrieve the current maintenance states for a group of hosts.
  // 
  // Parameters:
  //  - Hosts
  MaintenanceStatus(ctx context.Context, hosts *Hosts) (r *Response, err error)
  // Set the given hosts back into serving mode.
  // 
  // Parameters:
  //  - Hosts
  EndMaintenance(ctx context.Context, hosts *Hosts) (r *Response, err error)
  // Ask scheduler to put hosts into DRAINING mode and move scheduled tasks off of the hosts
  // such that its SLA requirements are satisfied. Use defaultSlaPolicy if it is not set for a task.
  // 
  // 
  // Parameters:
  //  - Hosts
  //  - DefaultSlaPolicy
  //  - TimeoutSecs
  SlaDrainHosts(ctx context.Context, hosts *Hosts, defaultSlaPolicy *SlaPolicy, timeoutSecs int64) (r *Response, err error)
  // Start a storage snapshot and block until it completes.
  Snapshot(ctx context.Context) (r *Response, err error)
  // Tell scheduler to trigger an explicit task reconciliation with the given settings.
  // 
  // Parameters:
  //  - Settings
  TriggerExplicitTaskReconciliation(ctx context.Context, settings *ExplicitReconciliationSettings) (r *Response, err error)
  // Tell scheduler to trigger an implicit task reconciliation.
  TriggerImplicitTaskReconciliation(ctx context.Context) (r *Response, err error)
  // Force prune any (terminal) tasks that match the query. If no statuses are supplied with the
  // query, it will default to all terminal task states. If statuses are supplied, they must be
  // terminal states.
  // 
  // Parameters:
  //  - Query
  PruneTasks(ctx context.Context, query *TaskQuery) (r *Response, err error)
}

type AuroraAdminClient struct {
  *AuroraSchedulerManagerClient
}

func NewAuroraAdminClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *AuroraAdminClient {
  return &AuroraAdminClient{AuroraSchedulerManagerClient: NewAuroraSchedulerManagerClientFactory(t, f)}}

func NewAuroraAdminClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *AuroraAdminClient {
  return &AuroraAdminClient{AuroraSchedulerManagerClient: NewAuroraSchedulerManagerClientProtocol(t, iprot, oprot)}
}

func NewAuroraAdminClient(c thrift.TClient) *AuroraAdminClient {
  return &AuroraAdminClient{
    AuroraSchedulerManagerClient: NewAuroraSchedulerManagerClient(c),
  }
}

// Assign quota to a user.  This will overwrite any pre-existing quota for the user.
// 
// Parameters:
//  - OwnerRole
//  - Quota
func (p *AuroraAdminClient) SetQuota(ctx context.Context, ownerRole string, quota *ResourceAggregate) (r *Response, err error) {
  var _args367 AuroraAdminSetQuotaArgs
  _args367.OwnerRole = ownerRole
  _args367.Quota = quota
  var _result368 AuroraAdminSetQuotaResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "setQuota", &_args367, &_result368)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result368.GetSuccess(), nil
}

// Forces a task into a specific state.  This does not guarantee the task will enter the given
// state, as the task must still transition within the bounds of the state machine.  However,
// it attempts to enter that state via the state machine.
// 
// Parameters:
//  - TaskId
//  - Status
func (p *AuroraAdminClient) ForceTaskState(ctx context.Context, taskId string, status ScheduleStatus) (r *Response, err error) {
  var _args369 AuroraAdminForceTaskStateArgs
  _args369.TaskId = taskId
  _args369.Status = status
  var _result370 AuroraAdminForceTaskStateResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "forceTaskState", &_args369, &_result370)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result370.GetSuccess(), nil
}

// Immediately writes a storage snapshot to disk.
func (p *AuroraAdminClient) PerformBackup(ctx context.Context) (r *Response, err error) {
  var _args371 AuroraAdminPerformBackupArgs
  var _result372 AuroraAdminPerformBackupResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "performBackup", &_args371, &_result372)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result372.GetSuccess(), nil
}

// Lists backups that are available for recovery.
func (p *AuroraAdminClient) ListBackups(ctx context.Context) (r *Response, err error) {
  var _args373 AuroraAdminListBackupsArgs
  var _result374 AuroraAdminListBackupsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "listBackups", &_args373, &_result374)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result374.GetSuccess(), nil
}

// Loads a backup to an in-memory storage.  This must precede all other recovery operations.
// 
// Parameters:
//  - BackupId
func (p *AuroraAdminClient) StageRecovery(ctx context.Context, backupId string) (r *Response, err error) {
  var _args375 AuroraAdminStageRecoveryArgs
  _args375.BackupId = backupId
  var _result376 AuroraAdminStageRecoveryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "stageRecovery", &_args375, &_result376)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result376.GetSuccess(), nil
}

// Queries for tasks in a staged recovery.
// 
// Parameters:
//  - Query
func (p *AuroraAdminClient) QueryRecovery(ctx context.Context, query *TaskQuery) (r *Response, err error) {
  var _args377 AuroraAdminQueryRecoveryArgs
  _args377.Query = query
  var _result378 AuroraAdminQueryRecoveryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "queryRecovery", &_args377, &_result378)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result378.GetSuccess(), nil
}

// Deletes tasks from a staged recovery.
// 
// Parameters:
//  - Query
func (p *AuroraAdminClient) DeleteRecoveryTasks(ctx context.Context, query *TaskQuery) (r *Response, err error) {
  var _args379 AuroraAdminDeleteRecoveryTasksArgs
  _args379.Query = query
  var _result380 AuroraAdminDeleteRecoveryTasksResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "deleteRecoveryTasks", &_args379, &_result380)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result380.GetSuccess(), nil
}

// Commits a staged recovery, completely replacing the previous storage state.
func (p *AuroraAdminClient) CommitRecovery(ctx context.Context) (r *Response, err error) {
  var _args381 AuroraAdminCommitRecoveryArgs
  var _result382 AuroraAdminCommitRecoveryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "commitRecovery", &_args381, &_result382)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result382.GetSuccess(), nil
}

// Unloads (aborts) a staged recovery.
func (p *AuroraAdminClient) UnloadRecovery(ctx context.Context) (r *Response, err error) {
  var _args383 AuroraAdminUnloadRecoveryArgs
  var _result384 AuroraAdminUnloadRecoveryResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "unloadRecovery", &_args383, &_result384)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result384.GetSuccess(), nil
}

// Put the given hosts into maintenance mode.
// 
// Parameters:
//  - Hosts
func (p *AuroraAdminClient) StartMaintenance(ctx context.Context, hosts *Hosts) (r *Response, err error) {
  var _args385 AuroraAdminStartMaintenanceArgs
  _args385.Hosts = hosts
  var _result386 AuroraAdminStartMaintenanceResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "startMaintenance", &_args385, &_result386)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result386.GetSuccess(), nil
}

// Ask scheduler to begin moving tasks scheduled on given hosts.
// 
// Parameters:
//  - Hosts
func (p *AuroraAdminClient) DrainHosts(ctx context.Context, hosts *Hosts) (r *Response, err error) {
  var _args387 AuroraAdminDrainHostsArgs
  _args387.Hosts = hosts
  var _result388 AuroraAdminDrainHostsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "drainHosts", &_args387, &_result388)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result388.GetSuccess(), nil
}

// Retrieve the current maintenance states for a group of hosts.
// 
// Parameters:
//  - Hosts
func (p *AuroraAdminClient) MaintenanceStatus(ctx context.Context, hosts *Hosts) (r *Response, err error) {
  var _args389 AuroraAdminMaintenanceStatusArgs
  _args389.Hosts = hosts
  var _result390 AuroraAdminMaintenanceStatusResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "maintenanceStatus", &_args389, &_result390)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result390.GetSuccess(), nil
}

// Set the given hosts back into serving mode.
// 
// Parameters:
//  - Hosts
func (p *AuroraAdminClient) EndMaintenance(ctx context.Context, hosts *Hosts) (r *Response, err error) {
  var _args391 AuroraAdminEndMaintenanceArgs
  _args391.Hosts = hosts
  var _result392 AuroraAdminEndMaintenanceResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "endMaintenance", &_args391, &_result392)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result392.GetSuccess(), nil
}

// Ask scheduler to put hosts into DRAINING mode and move scheduled tasks off of the hosts
// such that its SLA requirements are satisfied. Use defaultSlaPolicy if it is not set for a task.
// 
// 
// Parameters:
//  - Hosts
//  - DefaultSlaPolicy
//  - TimeoutSecs
func (p *AuroraAdminClient) SlaDrainHosts(ctx context.Context, hosts *Hosts, defaultSlaPolicy *SlaPolicy, timeoutSecs int64) (r *Response, err error) {
  var _args393 AuroraAdminSlaDrainHostsArgs
  _args393.Hosts = hosts
  _args393.DefaultSlaPolicy = defaultSlaPolicy
  _args393.TimeoutSecs = timeoutSecs
  var _result394 AuroraAdminSlaDrainHostsResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "slaDrainHosts", &_args393, &_result394)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result394.GetSuccess(), nil
}

// Start a storage snapshot and block until it completes.
func (p *AuroraAdminClient) Snapshot(ctx context.Context) (r *Response, err error) {
  var _args395 AuroraAdminSnapshotArgs
  var _result396 AuroraAdminSnapshotResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "snapshot", &_args395, &_result396)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result396.GetSuccess(), nil
}

// Tell scheduler to trigger an explicit task reconciliation with the given settings.
// 
// Parameters:
//  - Settings
func (p *AuroraAdminClient) TriggerExplicitTaskReconciliation(ctx context.Context, settings *ExplicitReconciliationSettings) (r *Response, err error) {
  var _args397 AuroraAdminTriggerExplicitTaskReconciliationArgs
  _args397.Settings = settings
  var _result398 AuroraAdminTriggerExplicitTaskReconciliationResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "triggerExplicitTaskReconciliation", &_args397, &_result398)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result398.GetSuccess(), nil
}

// Tell scheduler to trigger an implicit task reconciliation.
func (p *AuroraAdminClient) TriggerImplicitTaskReconciliation(ctx context.Context) (r *Response, err error) {
  var _args399 AuroraAdminTriggerImplicitTaskReconciliationArgs
  var _result400 AuroraAdminTriggerImplicitTaskReconciliationResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "triggerImplicitTaskReconciliation", &_args399, &_result400)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result400.GetSuccess(), nil
}

// Force prune any (terminal) tasks that match the query. If no statuses are supplied with the
// query, it will default to all terminal task states. If statuses are supplied, they must be
// terminal states.
// 
// Parameters:
//  - Query
func (p *AuroraAdminClient) PruneTasks(ctx context.Context, query *TaskQuery) (r *Response, err error) {
  var _args401 AuroraAdminPruneTasksArgs
  _args401.Query = query
  var _result402 AuroraAdminPruneTasksResult
  var meta thrift.ResponseMeta
  meta, err = p.Client_().Call(ctx, "pruneTasks", &_args401, &_result402)
  p.SetLastResponseMeta_(meta)
  if err != nil {
    return
  }
  return _result402.GetSuccess(), nil
}

type AuroraAdminProcessor struct {
  *AuroraSchedulerManagerProcessor
}

func NewAuroraAdminProcessor(handler AuroraAdmin) *AuroraAdminProcessor {
  self403 := &AuroraAdminProcessor{NewAuroraSchedulerManagerProcessor(handler)}
  self403.AddToProcessorMap("setQuota", &auroraAdminProcessorSetQuota{handler:handler})
  self403.AddToProcessorMap("forceTaskState", &auroraAdminProcessorForceTaskState{handler:handler})
  self403.AddToProcessorMap("performBackup", &auroraAdminProcessorPerformBackup{handler:handler})
  self403.AddToProcessorMap("listBackups", &auroraAdminProcessorListBackups{handler:handler})
  self403.AddToProcessorMap("stageRecovery", &auroraAdminProcessorStageRecovery{handler:handler})
  self403.AddToProcessorMap("queryRecovery", &auroraAdminProcessorQueryRecovery{handler:handler})
  self403.AddToProcessorMap("deleteRecoveryTasks", &auroraAdminProcessorDeleteRecoveryTasks{handler:handler})
  self403.AddToProcessorMap("commitRecovery", &auroraAdminProcessorCommitRecovery{handler:handler})
  self403.AddToProcessorMap("unloadRecovery", &auroraAdminProcessorUnloadRecovery{handler:handler})
  self403.AddToProcessorMap("startMaintenance", &auroraAdminProcessorStartMaintenance{handler:handler})
  self403.AddToProcessorMap("drainHosts", &auroraAdminProcessorDrainHosts{handler:handler})
  self403.AddToProcessorMap("maintenanceStatus", &auroraAdminProcessorMaintenanceStatus{handler:handler})
  self403.AddToProcessorMap("endMaintenance", &auroraAdminProcessorEndMaintenance{handler:handler})
  self403.AddToProcessorMap("slaDrainHosts", &auroraAdminProcessorSlaDrainHosts{handler:handler})
  self403.AddToProcessorMap("snapshot", &auroraAdminProcessorSnapshot{handler:handler})
  self403.AddToProcessorMap("triggerExplicitTaskReconciliation", &auroraAdminProcessorTriggerExplicitTaskReconciliation{handler:handler})
  self403.AddToProcessorMap("triggerImplicitTaskReconciliation", &auroraAdminProcessorTriggerImplicitTaskReconciliation{handler:handler})
  self403.AddToProcessorMap("pruneTasks", &auroraAdminProcessorPruneTasks{handler:handler})
  return self403
}

type auroraAdminProcessorSetQuota struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorSetQuota) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminSetQuotaArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "setQuota", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminSetQuotaResult{}
  var retval *Response
  if retval, err2 = p.handler.SetQuota(ctx, args.OwnerRole, args.Quota); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setQuota: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "setQuota", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "setQuota", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorForceTaskState struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorForceTaskState) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminForceTaskStateArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "forceTaskState", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminForceTaskStateResult{}
  var retval *Response
  if retval, err2 = p.handler.ForceTaskState(ctx, args.TaskId, args.Status); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing forceTaskState: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "forceTaskState", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "forceTaskState", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorPerformBackup struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorPerformBackup) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminPerformBackupArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "performBackup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminPerformBackupResult{}
  var retval *Response
  if retval, err2 = p.handler.PerformBackup(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing performBackup: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "performBackup", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "performBackup", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorListBackups struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorListBackups) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminListBackupsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "listBackups", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminListBackupsResult{}
  var retval *Response
  if retval, err2 = p.handler.ListBackups(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBackups: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "listBackups", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "listBackups", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorStageRecovery struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorStageRecovery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminStageRecoveryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "stageRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminStageRecoveryResult{}
  var retval *Response
  if retval, err2 = p.handler.StageRecovery(ctx, args.BackupId); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing stageRecovery: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "stageRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "stageRecovery", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorQueryRecovery struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorQueryRecovery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminQueryRecoveryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "queryRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminQueryRecoveryResult{}
  var retval *Response
  if retval, err2 = p.handler.QueryRecovery(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing queryRecovery: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "queryRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "queryRecovery", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorDeleteRecoveryTasks struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorDeleteRecoveryTasks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminDeleteRecoveryTasksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteRecoveryTasks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminDeleteRecoveryTasksResult{}
  var retval *Response
  if retval, err2 = p.handler.DeleteRecoveryTasks(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteRecoveryTasks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "deleteRecoveryTasks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "deleteRecoveryTasks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorCommitRecovery struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorCommitRecovery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminCommitRecoveryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "commitRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminCommitRecoveryResult{}
  var retval *Response
  if retval, err2 = p.handler.CommitRecovery(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing commitRecovery: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "commitRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "commitRecovery", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorUnloadRecovery struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorUnloadRecovery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminUnloadRecoveryArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "unloadRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminUnloadRecoveryResult{}
  var retval *Response
  if retval, err2 = p.handler.UnloadRecovery(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing unloadRecovery: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "unloadRecovery", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "unloadRecovery", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorStartMaintenance struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorStartMaintenance) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminStartMaintenanceArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "startMaintenance", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminStartMaintenanceResult{}
  var retval *Response
  if retval, err2 = p.handler.StartMaintenance(ctx, args.Hosts); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startMaintenance: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "startMaintenance", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "startMaintenance", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorDrainHosts struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorDrainHosts) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminDrainHostsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "drainHosts", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminDrainHostsResult{}
  var retval *Response
  if retval, err2 = p.handler.DrainHosts(ctx, args.Hosts); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing drainHosts: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "drainHosts", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "drainHosts", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorMaintenanceStatus struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorMaintenanceStatus) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminMaintenanceStatusArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "maintenanceStatus", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminMaintenanceStatusResult{}
  var retval *Response
  if retval, err2 = p.handler.MaintenanceStatus(ctx, args.Hosts); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing maintenanceStatus: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "maintenanceStatus", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "maintenanceStatus", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorEndMaintenance struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorEndMaintenance) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminEndMaintenanceArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "endMaintenance", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminEndMaintenanceResult{}
  var retval *Response
  if retval, err2 = p.handler.EndMaintenance(ctx, args.Hosts); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing endMaintenance: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "endMaintenance", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "endMaintenance", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorSlaDrainHosts struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorSlaDrainHosts) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminSlaDrainHostsArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "slaDrainHosts", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminSlaDrainHostsResult{}
  var retval *Response
  if retval, err2 = p.handler.SlaDrainHosts(ctx, args.Hosts, args.DefaultSlaPolicy, args.TimeoutSecs); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing slaDrainHosts: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "slaDrainHosts", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "slaDrainHosts", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorSnapshot struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorSnapshot) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminSnapshotArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "snapshot", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminSnapshotResult{}
  var retval *Response
  if retval, err2 = p.handler.Snapshot(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing snapshot: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "snapshot", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "snapshot", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorTriggerExplicitTaskReconciliation struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorTriggerExplicitTaskReconciliation) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminTriggerExplicitTaskReconciliationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "triggerExplicitTaskReconciliation", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminTriggerExplicitTaskReconciliationResult{}
  var retval *Response
  if retval, err2 = p.handler.TriggerExplicitTaskReconciliation(ctx, args.Settings); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing triggerExplicitTaskReconciliation: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "triggerExplicitTaskReconciliation", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "triggerExplicitTaskReconciliation", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorTriggerImplicitTaskReconciliation struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorTriggerImplicitTaskReconciliation) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminTriggerImplicitTaskReconciliationArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "triggerImplicitTaskReconciliation", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminTriggerImplicitTaskReconciliationResult{}
  var retval *Response
  if retval, err2 = p.handler.TriggerImplicitTaskReconciliation(ctx); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing triggerImplicitTaskReconciliation: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "triggerImplicitTaskReconciliation", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "triggerImplicitTaskReconciliation", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}

type auroraAdminProcessorPruneTasks struct {
  handler AuroraAdmin
}

func (p *auroraAdminProcessorPruneTasks) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  args := AuroraAdminPruneTasksArgs{}
  var err2 error
  if err2 = args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "pruneTasks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelFunc
    ctx, cancel = context.WithCancel(ctx)
    defer cancel()
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel()
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := AuroraAdminPruneTasksResult{}
  var retval *Response
  if retval, err2 = p.handler.PruneTasks(ctx, args.Query); err2 != nil {
    tickerCancel()
    if err2 == thrift.ErrAbandonRequest {
      return false, thrift.WrapTException(err2)
    }
    x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pruneTasks: " + err2.Error())
    oprot.WriteMessageBegin(ctx, "pruneTasks", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return true, thrift.WrapTException(err2)
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 = oprot.WriteMessageBegin(ctx, "pruneTasks", thrift.REPLY, seqId); err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = result.Write(ctx, oprot); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.WriteMessageEnd(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
    err = thrift.WrapTException(err2)
  }
  if err != nil {
    return
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - OwnerRole
//  - Quota
type AuroraAdminSetQuotaArgs struct {
  OwnerRole string `thrift:"ownerRole,1" db:"ownerRole" json:"ownerRole"`
  Quota *ResourceAggregate `thrift:"quota,2" db:"quota" json:"quota"`
}

func NewAuroraAdminSetQuotaArgs() *AuroraAdminSetQuotaArgs {
  return &AuroraAdminSetQuotaArgs{}
}


func (p *AuroraAdminSetQuotaArgs) GetOwnerRole() string {
  return p.OwnerRole
}
var AuroraAdminSetQuotaArgs_Quota_DEFAULT *ResourceAggregate
func (p *AuroraAdminSetQuotaArgs) GetQuota() *ResourceAggregate {
  if !p.IsSetQuota() {
    return AuroraAdminSetQuotaArgs_Quota_DEFAULT
  }
return p.Quota
}
func (p *AuroraAdminSetQuotaArgs) IsSetQuota() bool {
  return p.Quota != nil
}

func (p *AuroraAdminSetQuotaArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminSetQuotaArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.OwnerRole = v
}
  return nil
}

func (p *AuroraAdminSetQuotaArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Quota = &ResourceAggregate{}
  if err := p.Quota.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Quota), err)
  }
  return nil
}

func (p *AuroraAdminSetQuotaArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setQuota_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminSetQuotaArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ownerRole", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ownerRole: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.OwnerRole)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ownerRole (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ownerRole: ", p), err) }
  return err
}

func (p *AuroraAdminSetQuotaArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "quota", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:quota: ", p), err) }
  if err := p.Quota.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Quota), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:quota: ", p), err) }
  return err
}

func (p *AuroraAdminSetQuotaArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminSetQuotaArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminSetQuotaResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminSetQuotaResult() *AuroraAdminSetQuotaResult {
  return &AuroraAdminSetQuotaResult{}
}

var AuroraAdminSetQuotaResult_Success_DEFAULT *Response
func (p *AuroraAdminSetQuotaResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminSetQuotaResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminSetQuotaResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminSetQuotaResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminSetQuotaResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminSetQuotaResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "setQuota_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminSetQuotaResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminSetQuotaResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminSetQuotaResult(%+v)", *p)
}

// Attributes:
//  - TaskId
//  - Status
type AuroraAdminForceTaskStateArgs struct {
  TaskId string `thrift:"taskId,1" db:"taskId" json:"taskId"`
  Status ScheduleStatus `thrift:"status,2" db:"status" json:"status"`
}

func NewAuroraAdminForceTaskStateArgs() *AuroraAdminForceTaskStateArgs {
  return &AuroraAdminForceTaskStateArgs{}
}


func (p *AuroraAdminForceTaskStateArgs) GetTaskId() string {
  return p.TaskId
}

func (p *AuroraAdminForceTaskStateArgs) GetStatus() ScheduleStatus {
  return p.Status
}
func (p *AuroraAdminForceTaskStateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminForceTaskStateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.TaskId = v
}
  return nil
}

func (p *AuroraAdminForceTaskStateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := ScheduleStatus(v)
  p.Status = temp
}
  return nil
}

func (p *AuroraAdminForceTaskStateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "forceTaskState_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminForceTaskStateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "taskId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:taskId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.TaskId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.taskId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:taskId: ", p), err) }
  return err
}

func (p *AuroraAdminForceTaskStateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "status", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:status: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Status)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.status (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:status: ", p), err) }
  return err
}

func (p *AuroraAdminForceTaskStateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminForceTaskStateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminForceTaskStateResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminForceTaskStateResult() *AuroraAdminForceTaskStateResult {
  return &AuroraAdminForceTaskStateResult{}
}

var AuroraAdminForceTaskStateResult_Success_DEFAULT *Response
func (p *AuroraAdminForceTaskStateResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminForceTaskStateResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminForceTaskStateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminForceTaskStateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminForceTaskStateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminForceTaskStateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "forceTaskState_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminForceTaskStateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminForceTaskStateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminForceTaskStateResult(%+v)", *p)
}

type AuroraAdminPerformBackupArgs struct {
}

func NewAuroraAdminPerformBackupArgs() *AuroraAdminPerformBackupArgs {
  return &AuroraAdminPerformBackupArgs{}
}

func (p *AuroraAdminPerformBackupArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminPerformBackupArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "performBackup_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminPerformBackupArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminPerformBackupArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminPerformBackupResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminPerformBackupResult() *AuroraAdminPerformBackupResult {
  return &AuroraAdminPerformBackupResult{}
}

var AuroraAdminPerformBackupResult_Success_DEFAULT *Response
func (p *AuroraAdminPerformBackupResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminPerformBackupResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminPerformBackupResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminPerformBackupResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminPerformBackupResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminPerformBackupResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "performBackup_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminPerformBackupResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminPerformBackupResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminPerformBackupResult(%+v)", *p)
}

type AuroraAdminListBackupsArgs struct {
}

func NewAuroraAdminListBackupsArgs() *AuroraAdminListBackupsArgs {
  return &AuroraAdminListBackupsArgs{}
}

func (p *AuroraAdminListBackupsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminListBackupsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listBackups_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminListBackupsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminListBackupsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminListBackupsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminListBackupsResult() *AuroraAdminListBackupsResult {
  return &AuroraAdminListBackupsResult{}
}

var AuroraAdminListBackupsResult_Success_DEFAULT *Response
func (p *AuroraAdminListBackupsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminListBackupsResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminListBackupsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminListBackupsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminListBackupsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminListBackupsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "listBackups_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminListBackupsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminListBackupsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminListBackupsResult(%+v)", *p)
}

// Attributes:
//  - BackupId
type AuroraAdminStageRecoveryArgs struct {
  BackupId string `thrift:"backupId,1" db:"backupId" json:"backupId"`
}

func NewAuroraAdminStageRecoveryArgs() *AuroraAdminStageRecoveryArgs {
  return &AuroraAdminStageRecoveryArgs{}
}


func (p *AuroraAdminStageRecoveryArgs) GetBackupId() string {
  return p.BackupId
}
func (p *AuroraAdminStageRecoveryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminStageRecoveryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.BackupId = v
}
  return nil
}

func (p *AuroraAdminStageRecoveryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "stageRecovery_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminStageRecoveryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "backupId", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:backupId: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.BackupId)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.backupId (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:backupId: ", p), err) }
  return err
}

func (p *AuroraAdminStageRecoveryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminStageRecoveryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminStageRecoveryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminStageRecoveryResult() *AuroraAdminStageRecoveryResult {
  return &AuroraAdminStageRecoveryResult{}
}

var AuroraAdminStageRecoveryResult_Success_DEFAULT *Response
func (p *AuroraAdminStageRecoveryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminStageRecoveryResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminStageRecoveryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminStageRecoveryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminStageRecoveryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminStageRecoveryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "stageRecovery_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminStageRecoveryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminStageRecoveryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminStageRecoveryResult(%+v)", *p)
}

// Attributes:
//  - Query
type AuroraAdminQueryRecoveryArgs struct {
  Query *TaskQuery `thrift:"query,1" db:"query" json:"query"`
}

func NewAuroraAdminQueryRecoveryArgs() *AuroraAdminQueryRecoveryArgs {
  return &AuroraAdminQueryRecoveryArgs{}
}

var AuroraAdminQueryRecoveryArgs_Query_DEFAULT *TaskQuery
func (p *AuroraAdminQueryRecoveryArgs) GetQuery() *TaskQuery {
  if !p.IsSetQuery() {
    return AuroraAdminQueryRecoveryArgs_Query_DEFAULT
  }
return p.Query
}
func (p *AuroraAdminQueryRecoveryArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *AuroraAdminQueryRecoveryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminQueryRecoveryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &TaskQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *AuroraAdminQueryRecoveryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "queryRecovery_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminQueryRecoveryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *AuroraAdminQueryRecoveryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminQueryRecoveryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminQueryRecoveryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminQueryRecoveryResult() *AuroraAdminQueryRecoveryResult {
  return &AuroraAdminQueryRecoveryResult{}
}

var AuroraAdminQueryRecoveryResult_Success_DEFAULT *Response
func (p *AuroraAdminQueryRecoveryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminQueryRecoveryResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminQueryRecoveryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminQueryRecoveryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminQueryRecoveryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminQueryRecoveryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "queryRecovery_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminQueryRecoveryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminQueryRecoveryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminQueryRecoveryResult(%+v)", *p)
}

// Attributes:
//  - Query
type AuroraAdminDeleteRecoveryTasksArgs struct {
  Query *TaskQuery `thrift:"query,1" db:"query" json:"query"`
}

func NewAuroraAdminDeleteRecoveryTasksArgs() *AuroraAdminDeleteRecoveryTasksArgs {
  return &AuroraAdminDeleteRecoveryTasksArgs{}
}

var AuroraAdminDeleteRecoveryTasksArgs_Query_DEFAULT *TaskQuery
func (p *AuroraAdminDeleteRecoveryTasksArgs) GetQuery() *TaskQuery {
  if !p.IsSetQuery() {
    return AuroraAdminDeleteRecoveryTasksArgs_Query_DEFAULT
  }
return p.Query
}
func (p *AuroraAdminDeleteRecoveryTasksArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *AuroraAdminDeleteRecoveryTasksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminDeleteRecoveryTasksArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &TaskQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *AuroraAdminDeleteRecoveryTasksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteRecoveryTasks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminDeleteRecoveryTasksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *AuroraAdminDeleteRecoveryTasksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminDeleteRecoveryTasksArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminDeleteRecoveryTasksResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminDeleteRecoveryTasksResult() *AuroraAdminDeleteRecoveryTasksResult {
  return &AuroraAdminDeleteRecoveryTasksResult{}
}

var AuroraAdminDeleteRecoveryTasksResult_Success_DEFAULT *Response
func (p *AuroraAdminDeleteRecoveryTasksResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminDeleteRecoveryTasksResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminDeleteRecoveryTasksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminDeleteRecoveryTasksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminDeleteRecoveryTasksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminDeleteRecoveryTasksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "deleteRecoveryTasks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminDeleteRecoveryTasksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminDeleteRecoveryTasksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminDeleteRecoveryTasksResult(%+v)", *p)
}

type AuroraAdminCommitRecoveryArgs struct {
}

func NewAuroraAdminCommitRecoveryArgs() *AuroraAdminCommitRecoveryArgs {
  return &AuroraAdminCommitRecoveryArgs{}
}

func (p *AuroraAdminCommitRecoveryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminCommitRecoveryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "commitRecovery_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminCommitRecoveryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminCommitRecoveryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminCommitRecoveryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminCommitRecoveryResult() *AuroraAdminCommitRecoveryResult {
  return &AuroraAdminCommitRecoveryResult{}
}

var AuroraAdminCommitRecoveryResult_Success_DEFAULT *Response
func (p *AuroraAdminCommitRecoveryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminCommitRecoveryResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminCommitRecoveryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminCommitRecoveryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminCommitRecoveryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminCommitRecoveryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "commitRecovery_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminCommitRecoveryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminCommitRecoveryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminCommitRecoveryResult(%+v)", *p)
}

type AuroraAdminUnloadRecoveryArgs struct {
}

func NewAuroraAdminUnloadRecoveryArgs() *AuroraAdminUnloadRecoveryArgs {
  return &AuroraAdminUnloadRecoveryArgs{}
}

func (p *AuroraAdminUnloadRecoveryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminUnloadRecoveryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unloadRecovery_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminUnloadRecoveryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminUnloadRecoveryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminUnloadRecoveryResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminUnloadRecoveryResult() *AuroraAdminUnloadRecoveryResult {
  return &AuroraAdminUnloadRecoveryResult{}
}

var AuroraAdminUnloadRecoveryResult_Success_DEFAULT *Response
func (p *AuroraAdminUnloadRecoveryResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminUnloadRecoveryResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminUnloadRecoveryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminUnloadRecoveryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminUnloadRecoveryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminUnloadRecoveryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "unloadRecovery_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminUnloadRecoveryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminUnloadRecoveryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminUnloadRecoveryResult(%+v)", *p)
}

// Attributes:
//  - Hosts
type AuroraAdminStartMaintenanceArgs struct {
  Hosts *Hosts `thrift:"hosts,1" db:"hosts" json:"hosts"`
}

func NewAuroraAdminStartMaintenanceArgs() *AuroraAdminStartMaintenanceArgs {
  return &AuroraAdminStartMaintenanceArgs{}
}

var AuroraAdminStartMaintenanceArgs_Hosts_DEFAULT *Hosts
func (p *AuroraAdminStartMaintenanceArgs) GetHosts() *Hosts {
  if !p.IsSetHosts() {
    return AuroraAdminStartMaintenanceArgs_Hosts_DEFAULT
  }
return p.Hosts
}
func (p *AuroraAdminStartMaintenanceArgs) IsSetHosts() bool {
  return p.Hosts != nil
}

func (p *AuroraAdminStartMaintenanceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminStartMaintenanceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hosts = &Hosts{}
  if err := p.Hosts.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hosts), err)
  }
  return nil
}

func (p *AuroraAdminStartMaintenanceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startMaintenance_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminStartMaintenanceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hosts", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hosts: ", p), err) }
  if err := p.Hosts.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hosts), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hosts: ", p), err) }
  return err
}

func (p *AuroraAdminStartMaintenanceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminStartMaintenanceArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminStartMaintenanceResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminStartMaintenanceResult() *AuroraAdminStartMaintenanceResult {
  return &AuroraAdminStartMaintenanceResult{}
}

var AuroraAdminStartMaintenanceResult_Success_DEFAULT *Response
func (p *AuroraAdminStartMaintenanceResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminStartMaintenanceResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminStartMaintenanceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminStartMaintenanceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminStartMaintenanceResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminStartMaintenanceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "startMaintenance_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminStartMaintenanceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminStartMaintenanceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminStartMaintenanceResult(%+v)", *p)
}

// Attributes:
//  - Hosts
type AuroraAdminDrainHostsArgs struct {
  Hosts *Hosts `thrift:"hosts,1" db:"hosts" json:"hosts"`
}

func NewAuroraAdminDrainHostsArgs() *AuroraAdminDrainHostsArgs {
  return &AuroraAdminDrainHostsArgs{}
}

var AuroraAdminDrainHostsArgs_Hosts_DEFAULT *Hosts
func (p *AuroraAdminDrainHostsArgs) GetHosts() *Hosts {
  if !p.IsSetHosts() {
    return AuroraAdminDrainHostsArgs_Hosts_DEFAULT
  }
return p.Hosts
}
func (p *AuroraAdminDrainHostsArgs) IsSetHosts() bool {
  return p.Hosts != nil
}

func (p *AuroraAdminDrainHostsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminDrainHostsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hosts = &Hosts{}
  if err := p.Hosts.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hosts), err)
  }
  return nil
}

func (p *AuroraAdminDrainHostsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "drainHosts_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminDrainHostsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hosts", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hosts: ", p), err) }
  if err := p.Hosts.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hosts), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hosts: ", p), err) }
  return err
}

func (p *AuroraAdminDrainHostsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminDrainHostsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminDrainHostsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminDrainHostsResult() *AuroraAdminDrainHostsResult {
  return &AuroraAdminDrainHostsResult{}
}

var AuroraAdminDrainHostsResult_Success_DEFAULT *Response
func (p *AuroraAdminDrainHostsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminDrainHostsResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminDrainHostsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminDrainHostsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminDrainHostsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminDrainHostsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "drainHosts_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminDrainHostsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminDrainHostsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminDrainHostsResult(%+v)", *p)
}

// Attributes:
//  - Hosts
type AuroraAdminMaintenanceStatusArgs struct {
  Hosts *Hosts `thrift:"hosts,1" db:"hosts" json:"hosts"`
}

func NewAuroraAdminMaintenanceStatusArgs() *AuroraAdminMaintenanceStatusArgs {
  return &AuroraAdminMaintenanceStatusArgs{}
}

var AuroraAdminMaintenanceStatusArgs_Hosts_DEFAULT *Hosts
func (p *AuroraAdminMaintenanceStatusArgs) GetHosts() *Hosts {
  if !p.IsSetHosts() {
    return AuroraAdminMaintenanceStatusArgs_Hosts_DEFAULT
  }
return p.Hosts
}
func (p *AuroraAdminMaintenanceStatusArgs) IsSetHosts() bool {
  return p.Hosts != nil
}

func (p *AuroraAdminMaintenanceStatusArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminMaintenanceStatusArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hosts = &Hosts{}
  if err := p.Hosts.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hosts), err)
  }
  return nil
}

func (p *AuroraAdminMaintenanceStatusArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "maintenanceStatus_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminMaintenanceStatusArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hosts", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hosts: ", p), err) }
  if err := p.Hosts.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hosts), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hosts: ", p), err) }
  return err
}

func (p *AuroraAdminMaintenanceStatusArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminMaintenanceStatusArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminMaintenanceStatusResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminMaintenanceStatusResult() *AuroraAdminMaintenanceStatusResult {
  return &AuroraAdminMaintenanceStatusResult{}
}

var AuroraAdminMaintenanceStatusResult_Success_DEFAULT *Response
func (p *AuroraAdminMaintenanceStatusResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminMaintenanceStatusResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminMaintenanceStatusResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminMaintenanceStatusResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminMaintenanceStatusResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminMaintenanceStatusResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "maintenanceStatus_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminMaintenanceStatusResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminMaintenanceStatusResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminMaintenanceStatusResult(%+v)", *p)
}

// Attributes:
//  - Hosts
type AuroraAdminEndMaintenanceArgs struct {
  Hosts *Hosts `thrift:"hosts,1" db:"hosts" json:"hosts"`
}

func NewAuroraAdminEndMaintenanceArgs() *AuroraAdminEndMaintenanceArgs {
  return &AuroraAdminEndMaintenanceArgs{}
}

var AuroraAdminEndMaintenanceArgs_Hosts_DEFAULT *Hosts
func (p *AuroraAdminEndMaintenanceArgs) GetHosts() *Hosts {
  if !p.IsSetHosts() {
    return AuroraAdminEndMaintenanceArgs_Hosts_DEFAULT
  }
return p.Hosts
}
func (p *AuroraAdminEndMaintenanceArgs) IsSetHosts() bool {
  return p.Hosts != nil
}

func (p *AuroraAdminEndMaintenanceArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminEndMaintenanceArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hosts = &Hosts{}
  if err := p.Hosts.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hosts), err)
  }
  return nil
}

func (p *AuroraAdminEndMaintenanceArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "endMaintenance_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminEndMaintenanceArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hosts", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hosts: ", p), err) }
  if err := p.Hosts.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hosts), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hosts: ", p), err) }
  return err
}

func (p *AuroraAdminEndMaintenanceArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminEndMaintenanceArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminEndMaintenanceResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminEndMaintenanceResult() *AuroraAdminEndMaintenanceResult {
  return &AuroraAdminEndMaintenanceResult{}
}

var AuroraAdminEndMaintenanceResult_Success_DEFAULT *Response
func (p *AuroraAdminEndMaintenanceResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminEndMaintenanceResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminEndMaintenanceResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminEndMaintenanceResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminEndMaintenanceResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminEndMaintenanceResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "endMaintenance_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminEndMaintenanceResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminEndMaintenanceResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminEndMaintenanceResult(%+v)", *p)
}

// Attributes:
//  - Hosts
//  - DefaultSlaPolicy
//  - TimeoutSecs
type AuroraAdminSlaDrainHostsArgs struct {
  Hosts *Hosts `thrift:"hosts,1" db:"hosts" json:"hosts"`
  DefaultSlaPolicy *SlaPolicy `thrift:"defaultSlaPolicy,2" db:"defaultSlaPolicy" json:"defaultSlaPolicy"`
  TimeoutSecs int64 `thrift:"timeoutSecs,3" db:"timeoutSecs" json:"timeoutSecs"`
}

func NewAuroraAdminSlaDrainHostsArgs() *AuroraAdminSlaDrainHostsArgs {
  return &AuroraAdminSlaDrainHostsArgs{}
}

var AuroraAdminSlaDrainHostsArgs_Hosts_DEFAULT *Hosts
func (p *AuroraAdminSlaDrainHostsArgs) GetHosts() *Hosts {
  if !p.IsSetHosts() {
    return AuroraAdminSlaDrainHostsArgs_Hosts_DEFAULT
  }
return p.Hosts
}
var AuroraAdminSlaDrainHostsArgs_DefaultSlaPolicy_DEFAULT *SlaPolicy
func (p *AuroraAdminSlaDrainHostsArgs) GetDefaultSlaPolicy() *SlaPolicy {
  if !p.IsSetDefaultSlaPolicy() {
    return AuroraAdminSlaDrainHostsArgs_DefaultSlaPolicy_DEFAULT
  }
return p.DefaultSlaPolicy
}

func (p *AuroraAdminSlaDrainHostsArgs) GetTimeoutSecs() int64 {
  return p.TimeoutSecs
}
func (p *AuroraAdminSlaDrainHostsArgs) IsSetHosts() bool {
  return p.Hosts != nil
}

func (p *AuroraAdminSlaDrainHostsArgs) IsSetDefaultSlaPolicy() bool {
  return p.DefaultSlaPolicy != nil
}

func (p *AuroraAdminSlaDrainHostsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminSlaDrainHostsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Hosts = &Hosts{}
  if err := p.Hosts.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Hosts), err)
  }
  return nil
}

func (p *AuroraAdminSlaDrainHostsArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.DefaultSlaPolicy = &SlaPolicy{}
  if err := p.DefaultSlaPolicy.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.DefaultSlaPolicy), err)
  }
  return nil
}

func (p *AuroraAdminSlaDrainHostsArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.TimeoutSecs = v
}
  return nil
}

func (p *AuroraAdminSlaDrainHostsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "slaDrainHosts_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminSlaDrainHostsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "hosts", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:hosts: ", p), err) }
  if err := p.Hosts.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Hosts), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:hosts: ", p), err) }
  return err
}

func (p *AuroraAdminSlaDrainHostsArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "defaultSlaPolicy", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:defaultSlaPolicy: ", p), err) }
  if err := p.DefaultSlaPolicy.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.DefaultSlaPolicy), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:defaultSlaPolicy: ", p), err) }
  return err
}

func (p *AuroraAdminSlaDrainHostsArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "timeoutSecs", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timeoutSecs: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.TimeoutSecs)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.timeoutSecs (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timeoutSecs: ", p), err) }
  return err
}

func (p *AuroraAdminSlaDrainHostsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminSlaDrainHostsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminSlaDrainHostsResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminSlaDrainHostsResult() *AuroraAdminSlaDrainHostsResult {
  return &AuroraAdminSlaDrainHostsResult{}
}

var AuroraAdminSlaDrainHostsResult_Success_DEFAULT *Response
func (p *AuroraAdminSlaDrainHostsResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminSlaDrainHostsResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminSlaDrainHostsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminSlaDrainHostsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminSlaDrainHostsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminSlaDrainHostsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "slaDrainHosts_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminSlaDrainHostsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminSlaDrainHostsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminSlaDrainHostsResult(%+v)", *p)
}

type AuroraAdminSnapshotArgs struct {
}

func NewAuroraAdminSnapshotArgs() *AuroraAdminSnapshotArgs {
  return &AuroraAdminSnapshotArgs{}
}

func (p *AuroraAdminSnapshotArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminSnapshotArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "snapshot_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminSnapshotArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminSnapshotArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminSnapshotResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminSnapshotResult() *AuroraAdminSnapshotResult {
  return &AuroraAdminSnapshotResult{}
}

var AuroraAdminSnapshotResult_Success_DEFAULT *Response
func (p *AuroraAdminSnapshotResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminSnapshotResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminSnapshotResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminSnapshotResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminSnapshotResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminSnapshotResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "snapshot_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminSnapshotResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminSnapshotResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminSnapshotResult(%+v)", *p)
}

// Attributes:
//  - Settings
type AuroraAdminTriggerExplicitTaskReconciliationArgs struct {
  Settings *ExplicitReconciliationSettings `thrift:"settings,1" db:"settings" json:"settings"`
}

func NewAuroraAdminTriggerExplicitTaskReconciliationArgs() *AuroraAdminTriggerExplicitTaskReconciliationArgs {
  return &AuroraAdminTriggerExplicitTaskReconciliationArgs{}
}

var AuroraAdminTriggerExplicitTaskReconciliationArgs_Settings_DEFAULT *ExplicitReconciliationSettings
func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs) GetSettings() *ExplicitReconciliationSettings {
  if !p.IsSetSettings() {
    return AuroraAdminTriggerExplicitTaskReconciliationArgs_Settings_DEFAULT
  }
return p.Settings
}
func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs) IsSetSettings() bool {
  return p.Settings != nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Settings = &ExplicitReconciliationSettings{}
  if err := p.Settings.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Settings), err)
  }
  return nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "triggerExplicitTaskReconciliation_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "settings", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:settings: ", p), err) }
  if err := p.Settings.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Settings), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:settings: ", p), err) }
  return err
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminTriggerExplicitTaskReconciliationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminTriggerExplicitTaskReconciliationResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminTriggerExplicitTaskReconciliationResult() *AuroraAdminTriggerExplicitTaskReconciliationResult {
  return &AuroraAdminTriggerExplicitTaskReconciliationResult{}
}

var AuroraAdminTriggerExplicitTaskReconciliationResult_Success_DEFAULT *Response
func (p *AuroraAdminTriggerExplicitTaskReconciliationResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminTriggerExplicitTaskReconciliationResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminTriggerExplicitTaskReconciliationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "triggerExplicitTaskReconciliation_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminTriggerExplicitTaskReconciliationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminTriggerExplicitTaskReconciliationResult(%+v)", *p)
}

type AuroraAdminTriggerImplicitTaskReconciliationArgs struct {
}

func NewAuroraAdminTriggerImplicitTaskReconciliationArgs() *AuroraAdminTriggerImplicitTaskReconciliationArgs {
  return &AuroraAdminTriggerImplicitTaskReconciliationArgs{}
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    if err := iprot.Skip(ctx, fieldTypeId); err != nil {
      return err
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "triggerImplicitTaskReconciliation_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminTriggerImplicitTaskReconciliationArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminTriggerImplicitTaskReconciliationResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminTriggerImplicitTaskReconciliationResult() *AuroraAdminTriggerImplicitTaskReconciliationResult {
  return &AuroraAdminTriggerImplicitTaskReconciliationResult{}
}

var AuroraAdminTriggerImplicitTaskReconciliationResult_Success_DEFAULT *Response
func (p *AuroraAdminTriggerImplicitTaskReconciliationResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminTriggerImplicitTaskReconciliationResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminTriggerImplicitTaskReconciliationResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "triggerImplicitTaskReconciliation_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminTriggerImplicitTaskReconciliationResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminTriggerImplicitTaskReconciliationResult(%+v)", *p)
}

// Attributes:
//  - Query
type AuroraAdminPruneTasksArgs struct {
  Query *TaskQuery `thrift:"query,1" db:"query" json:"query"`
}

func NewAuroraAdminPruneTasksArgs() *AuroraAdminPruneTasksArgs {
  return &AuroraAdminPruneTasksArgs{}
}

var AuroraAdminPruneTasksArgs_Query_DEFAULT *TaskQuery
func (p *AuroraAdminPruneTasksArgs) GetQuery() *TaskQuery {
  if !p.IsSetQuery() {
    return AuroraAdminPruneTasksArgs_Query_DEFAULT
  }
return p.Query
}
func (p *AuroraAdminPruneTasksArgs) IsSetQuery() bool {
  return p.Query != nil
}

func (p *AuroraAdminPruneTasksArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminPruneTasksArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Query = &TaskQuery{}
  if err := p.Query.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
  }
  return nil
}

func (p *AuroraAdminPruneTasksArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pruneTasks_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminPruneTasksArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err) }
  if err := p.Query.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err) }
  return err
}

func (p *AuroraAdminPruneTasksArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminPruneTasksArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraAdminPruneTasksResult struct {
  Success *Response `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewAuroraAdminPruneTasksResult() *AuroraAdminPruneTasksResult {
  return &AuroraAdminPruneTasksResult{}
}

var AuroraAdminPruneTasksResult_Success_DEFAULT *Response
func (p *AuroraAdminPruneTasksResult) GetSuccess() *Response {
  if !p.IsSetSuccess() {
    return AuroraAdminPruneTasksResult_Success_DEFAULT
  }
return p.Success
}
func (p *AuroraAdminPruneTasksResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *AuroraAdminPruneTasksResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *AuroraAdminPruneTasksResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Response{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *AuroraAdminPruneTasksResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "pruneTasks_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *AuroraAdminPruneTasksResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *AuroraAdminPruneTasksResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("AuroraAdminPruneTasksResult(%+v)", *p)
}


