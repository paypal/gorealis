// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package aurora

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type ReadOnlyScheduler interface {
	// Returns a summary of the jobs grouped by role.
	GetRoleSummary() (r *Response, err error)
	// Returns a summary of jobs, optionally only those owned by a specific role.
	//
	// Parameters:
	//  - Role
	GetJobSummary(role string) (r *Response, err error)
	// Fetches the status of tasks.
	//
	// Parameters:
	//  - Query
	GetTasksStatus(query *TaskQuery) (r *Response, err error)
	// Same as getTaskStatus but without the TaskConfig.ExecutorConfig data set.
	// This is an interim solution until we have a better way to query TaskConfigs (AURORA-541).
	//
	// Parameters:
	//  - Query
	GetTasksWithoutConfigs(query *TaskQuery) (r *Response, err error)
	// Returns user-friendly reasons (if available) for tasks retained in PENDING state.
	//
	// Parameters:
	//  - Query
	GetPendingReason(query *TaskQuery) (r *Response, err error)
	// Fetches the configuration summary of active tasks for the specified job.
	//
	// Parameters:
	//  - Job
	GetConfigSummary(job *JobKey) (r *Response, err error)
	// Fetches the status of jobs.
	// ownerRole is optional, in which case all jobs are returned.
	//
	// Parameters:
	//  - OwnerRole
	GetJobs(ownerRole string) (r *Response, err error)
	// Fetches the quota allocated for a user.
	//
	// Parameters:
	//  - OwnerRole
	GetQuota(ownerRole string) (r *Response, err error)
	// Populates fields in a job configuration as though it were about to be run.
	// This can be used to diff a configuration running tasks.
	//
	// Parameters:
	//  - Description
	PopulateJobConfig(description *JobConfiguration) (r *Response, err error)
	// Gets job update summaries.
	//
	// Parameters:
	//  - JobUpdateQuery
	GetJobUpdateSummaries(jobUpdateQuery *JobUpdateQuery) (r *Response, err error)
	// Gets job update details.
	//
	// Parameters:
	//  - Query
	GetJobUpdateDetails(query *JobUpdateQuery) (r *Response, err error)
	// Gets the diff between client (desired) and server (current) job states.
	//
	// Parameters:
	//  - Request
	GetJobUpdateDiff(request *JobUpdateRequest) (r *Response, err error)
	// Gets tier configurations.
	GetTierConfigs() (r *Response, err error)
}

type ReadOnlySchedulerClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewReadOnlySchedulerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ReadOnlySchedulerClient {
	return &ReadOnlySchedulerClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewReadOnlySchedulerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ReadOnlySchedulerClient {
	return &ReadOnlySchedulerClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Returns a summary of the jobs grouped by role.
func (p *ReadOnlySchedulerClient) GetRoleSummary() (r *Response, err error) {
	if err = p.sendGetRoleSummary(); err != nil {
		return
	}
	return p.recvGetRoleSummary()
}

func (p *ReadOnlySchedulerClient) sendGetRoleSummary() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRoleSummary", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetRoleSummaryArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetRoleSummary() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getRoleSummary" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getRoleSummary failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRoleSummary failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error53 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error54 error
		error54, err = error53.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error54
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getRoleSummary failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetRoleSummaryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Returns a summary of jobs, optionally only those owned by a specific role.
//
// Parameters:
//  - Role
func (p *ReadOnlySchedulerClient) GetJobSummary(role string) (r *Response, err error) {
	if err = p.sendGetJobSummary(role); err != nil {
		return
	}
	return p.recvGetJobSummary()
}

func (p *ReadOnlySchedulerClient) sendGetJobSummary(role string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getJobSummary", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetJobSummaryArgs{
		Role: role,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetJobSummary() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getJobSummary" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getJobSummary failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getJobSummary failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getJobSummary failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetJobSummaryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Fetches the status of tasks.
//
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetTasksStatus(query *TaskQuery) (r *Response, err error) {
	if err = p.sendGetTasksStatus(query); err != nil {
		return
	}
	return p.recvGetTasksStatus()
}

func (p *ReadOnlySchedulerClient) sendGetTasksStatus(query *TaskQuery) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTasksStatus", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetTasksStatusArgs{
		Query: query,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetTasksStatus() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTasksStatus" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTasksStatus failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTasksStatus failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error57 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error58 error
		error58, err = error57.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error58
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTasksStatus failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetTasksStatusResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Same as getTaskStatus but without the TaskConfig.ExecutorConfig data set.
// This is an interim solution until we have a better way to query TaskConfigs (AURORA-541).
//
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetTasksWithoutConfigs(query *TaskQuery) (r *Response, err error) {
	if err = p.sendGetTasksWithoutConfigs(query); err != nil {
		return
	}
	return p.recvGetTasksWithoutConfigs()
}

func (p *ReadOnlySchedulerClient) sendGetTasksWithoutConfigs(query *TaskQuery) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTasksWithoutConfigs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetTasksWithoutConfigsArgs{
		Query: query,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetTasksWithoutConfigs() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTasksWithoutConfigs" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTasksWithoutConfigs failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTasksWithoutConfigs failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTasksWithoutConfigs failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetTasksWithoutConfigsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Returns user-friendly reasons (if available) for tasks retained in PENDING state.
//
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetPendingReason(query *TaskQuery) (r *Response, err error) {
	if err = p.sendGetPendingReason(query); err != nil {
		return
	}
	return p.recvGetPendingReason()
}

func (p *ReadOnlySchedulerClient) sendGetPendingReason(query *TaskQuery) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getPendingReason", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetPendingReasonArgs{
		Query: query,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetPendingReason() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getPendingReason" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getPendingReason failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getPendingReason failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error61 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error62 error
		error62, err = error61.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error62
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getPendingReason failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetPendingReasonResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Fetches the configuration summary of active tasks for the specified job.
//
// Parameters:
//  - Job
func (p *ReadOnlySchedulerClient) GetConfigSummary(job *JobKey) (r *Response, err error) {
	if err = p.sendGetConfigSummary(job); err != nil {
		return
	}
	return p.recvGetConfigSummary()
}

func (p *ReadOnlySchedulerClient) sendGetConfigSummary(job *JobKey) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getConfigSummary", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetConfigSummaryArgs{
		Job: job,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetConfigSummary() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getConfigSummary" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getConfigSummary failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getConfigSummary failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getConfigSummary failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetConfigSummaryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Fetches the status of jobs.
// ownerRole is optional, in which case all jobs are returned.
//
// Parameters:
//  - OwnerRole
func (p *ReadOnlySchedulerClient) GetJobs(ownerRole string) (r *Response, err error) {
	if err = p.sendGetJobs(ownerRole); err != nil {
		return
	}
	return p.recvGetJobs()
}

func (p *ReadOnlySchedulerClient) sendGetJobs(ownerRole string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getJobs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetJobsArgs{
		OwnerRole: ownerRole,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetJobs() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getJobs" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getJobs failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getJobs failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error65 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error66 error
		error66, err = error65.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error66
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getJobs failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetJobsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Fetches the quota allocated for a user.
//
// Parameters:
//  - OwnerRole
func (p *ReadOnlySchedulerClient) GetQuota(ownerRole string) (r *Response, err error) {
	if err = p.sendGetQuota(ownerRole); err != nil {
		return
	}
	return p.recvGetQuota()
}

func (p *ReadOnlySchedulerClient) sendGetQuota(ownerRole string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getQuota", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetQuotaArgs{
		OwnerRole: ownerRole,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetQuota() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getQuota" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getQuota failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getQuota failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getQuota failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetQuotaResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Populates fields in a job configuration as though it were about to be run.
// This can be used to diff a configuration running tasks.
//
// Parameters:
//  - Description
func (p *ReadOnlySchedulerClient) PopulateJobConfig(description *JobConfiguration) (r *Response, err error) {
	if err = p.sendPopulateJobConfig(description); err != nil {
		return
	}
	return p.recvPopulateJobConfig()
}

func (p *ReadOnlySchedulerClient) sendPopulateJobConfig(description *JobConfiguration) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("populateJobConfig", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerPopulateJobConfigArgs{
		Description: description,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvPopulateJobConfig() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "populateJobConfig" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "populateJobConfig failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "populateJobConfig failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error69 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error70 error
		error70, err = error69.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error70
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "populateJobConfig failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerPopulateJobConfigResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Gets job update summaries.
//
// Parameters:
//  - JobUpdateQuery
func (p *ReadOnlySchedulerClient) GetJobUpdateSummaries(jobUpdateQuery *JobUpdateQuery) (r *Response, err error) {
	if err = p.sendGetJobUpdateSummaries(jobUpdateQuery); err != nil {
		return
	}
	return p.recvGetJobUpdateSummaries()
}

func (p *ReadOnlySchedulerClient) sendGetJobUpdateSummaries(jobUpdateQuery *JobUpdateQuery) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getJobUpdateSummaries", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetJobUpdateSummariesArgs{
		JobUpdateQuery: jobUpdateQuery,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetJobUpdateSummaries() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getJobUpdateSummaries" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getJobUpdateSummaries failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getJobUpdateSummaries failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getJobUpdateSummaries failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetJobUpdateSummariesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Gets job update details.
//
// Parameters:
//  - Query
func (p *ReadOnlySchedulerClient) GetJobUpdateDetails(query *JobUpdateQuery) (r *Response, err error) {
	if err = p.sendGetJobUpdateDetails(query); err != nil {
		return
	}
	return p.recvGetJobUpdateDetails()
}

func (p *ReadOnlySchedulerClient) sendGetJobUpdateDetails(query *JobUpdateQuery) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getJobUpdateDetails", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetJobUpdateDetailsArgs{
		Query: query,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetJobUpdateDetails() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getJobUpdateDetails" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getJobUpdateDetails failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getJobUpdateDetails failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error73 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error74 error
		error74, err = error73.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error74
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getJobUpdateDetails failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetJobUpdateDetailsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Gets the diff between client (desired) and server (current) job states.
//
// Parameters:
//  - Request
func (p *ReadOnlySchedulerClient) GetJobUpdateDiff(request *JobUpdateRequest) (r *Response, err error) {
	if err = p.sendGetJobUpdateDiff(request); err != nil {
		return
	}
	return p.recvGetJobUpdateDiff()
}

func (p *ReadOnlySchedulerClient) sendGetJobUpdateDiff(request *JobUpdateRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getJobUpdateDiff", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetJobUpdateDiffArgs{
		Request: request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetJobUpdateDiff() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getJobUpdateDiff" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getJobUpdateDiff failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getJobUpdateDiff failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getJobUpdateDiff failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetJobUpdateDiffResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Gets tier configurations.
func (p *ReadOnlySchedulerClient) GetTierConfigs() (r *Response, err error) {
	if err = p.sendGetTierConfigs(); err != nil {
		return
	}
	return p.recvGetTierConfigs()
}

func (p *ReadOnlySchedulerClient) sendGetTierConfigs() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTierConfigs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ReadOnlySchedulerGetTierConfigsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ReadOnlySchedulerClient) recvGetTierConfigs() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getTierConfigs" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getTierConfigs failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTierConfigs failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error77 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error78 error
		error78, err = error77.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error78
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getTierConfigs failed: invalid message type")
		return
	}
	result := ReadOnlySchedulerGetTierConfigsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

type ReadOnlySchedulerProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ReadOnlyScheduler
}

func (p *ReadOnlySchedulerProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ReadOnlySchedulerProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ReadOnlySchedulerProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewReadOnlySchedulerProcessor(handler ReadOnlyScheduler) *ReadOnlySchedulerProcessor {

	self79 := &ReadOnlySchedulerProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self79.processorMap["getRoleSummary"] = &readOnlySchedulerProcessorGetRoleSummary{handler: handler}
	self79.processorMap["getJobSummary"] = &readOnlySchedulerProcessorGetJobSummary{handler: handler}
	self79.processorMap["getTasksStatus"] = &readOnlySchedulerProcessorGetTasksStatus{handler: handler}
	self79.processorMap["getTasksWithoutConfigs"] = &readOnlySchedulerProcessorGetTasksWithoutConfigs{handler: handler}
	self79.processorMap["getPendingReason"] = &readOnlySchedulerProcessorGetPendingReason{handler: handler}
	self79.processorMap["getConfigSummary"] = &readOnlySchedulerProcessorGetConfigSummary{handler: handler}
	self79.processorMap["getJobs"] = &readOnlySchedulerProcessorGetJobs{handler: handler}
	self79.processorMap["getQuota"] = &readOnlySchedulerProcessorGetQuota{handler: handler}
	self79.processorMap["populateJobConfig"] = &readOnlySchedulerProcessorPopulateJobConfig{handler: handler}
	self79.processorMap["getJobUpdateSummaries"] = &readOnlySchedulerProcessorGetJobUpdateSummaries{handler: handler}
	self79.processorMap["getJobUpdateDetails"] = &readOnlySchedulerProcessorGetJobUpdateDetails{handler: handler}
	self79.processorMap["getJobUpdateDiff"] = &readOnlySchedulerProcessorGetJobUpdateDiff{handler: handler}
	self79.processorMap["getTierConfigs"] = &readOnlySchedulerProcessorGetTierConfigs{handler: handler}
	return self79
}

func (p *ReadOnlySchedulerProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x80 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x80.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x80

}

type readOnlySchedulerProcessorGetRoleSummary struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetRoleSummary) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetRoleSummaryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRoleSummary", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetRoleSummaryResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetRoleSummary(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRoleSummary: "+err2.Error())
		oprot.WriteMessageBegin("getRoleSummary", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRoleSummary", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetJobSummary struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobSummary) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetJobSummaryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getJobSummary", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetJobSummaryResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetJobSummary(args.Role); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobSummary: "+err2.Error())
		oprot.WriteMessageBegin("getJobSummary", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getJobSummary", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetTasksStatus struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetTasksStatus) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetTasksStatusArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTasksStatus", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetTasksStatusResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetTasksStatus(args.Query); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTasksStatus: "+err2.Error())
		oprot.WriteMessageBegin("getTasksStatus", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTasksStatus", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetTasksWithoutConfigs struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetTasksWithoutConfigs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetTasksWithoutConfigsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTasksWithoutConfigs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetTasksWithoutConfigsResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetTasksWithoutConfigs(args.Query); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTasksWithoutConfigs: "+err2.Error())
		oprot.WriteMessageBegin("getTasksWithoutConfigs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTasksWithoutConfigs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetPendingReason struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetPendingReason) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetPendingReasonArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPendingReason", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetPendingReasonResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetPendingReason(args.Query); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPendingReason: "+err2.Error())
		oprot.WriteMessageBegin("getPendingReason", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getPendingReason", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetConfigSummary struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetConfigSummary) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetConfigSummaryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getConfigSummary", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetConfigSummaryResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetConfigSummary(args.Job); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getConfigSummary: "+err2.Error())
		oprot.WriteMessageBegin("getConfigSummary", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getConfigSummary", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetJobs struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetJobsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getJobs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetJobsResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetJobs(args.OwnerRole); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobs: "+err2.Error())
		oprot.WriteMessageBegin("getJobs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getJobs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetQuota struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetQuota) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetQuotaArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getQuota", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetQuotaResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetQuota(args.OwnerRole); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getQuota: "+err2.Error())
		oprot.WriteMessageBegin("getQuota", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getQuota", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorPopulateJobConfig struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorPopulateJobConfig) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerPopulateJobConfigArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("populateJobConfig", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerPopulateJobConfigResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.PopulateJobConfig(args.Description); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing populateJobConfig: "+err2.Error())
		oprot.WriteMessageBegin("populateJobConfig", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("populateJobConfig", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetJobUpdateSummaries struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobUpdateSummaries) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetJobUpdateSummariesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getJobUpdateSummaries", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetJobUpdateSummariesResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetJobUpdateSummaries(args.JobUpdateQuery); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobUpdateSummaries: "+err2.Error())
		oprot.WriteMessageBegin("getJobUpdateSummaries", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getJobUpdateSummaries", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetJobUpdateDetails struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobUpdateDetails) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetJobUpdateDetailsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getJobUpdateDetails", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetJobUpdateDetailsResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetJobUpdateDetails(args.Query); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobUpdateDetails: "+err2.Error())
		oprot.WriteMessageBegin("getJobUpdateDetails", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getJobUpdateDetails", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetJobUpdateDiff struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetJobUpdateDiff) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetJobUpdateDiffArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getJobUpdateDiff", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetJobUpdateDiffResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetJobUpdateDiff(args.Request); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getJobUpdateDiff: "+err2.Error())
		oprot.WriteMessageBegin("getJobUpdateDiff", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getJobUpdateDiff", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type readOnlySchedulerProcessorGetTierConfigs struct {
	handler ReadOnlyScheduler
}

func (p *readOnlySchedulerProcessorGetTierConfigs) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ReadOnlySchedulerGetTierConfigsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTierConfigs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ReadOnlySchedulerGetTierConfigsResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.GetTierConfigs(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTierConfigs: "+err2.Error())
		oprot.WriteMessageBegin("getTierConfigs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTierConfigs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type ReadOnlySchedulerGetRoleSummaryArgs struct {
}

func NewReadOnlySchedulerGetRoleSummaryArgs() *ReadOnlySchedulerGetRoleSummaryArgs {
	return &ReadOnlySchedulerGetRoleSummaryArgs{}
}

func (p *ReadOnlySchedulerGetRoleSummaryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRoleSummary_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetRoleSummaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetRoleSummaryResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetRoleSummaryResult() *ReadOnlySchedulerGetRoleSummaryResult {
	return &ReadOnlySchedulerGetRoleSummaryResult{}
}

var ReadOnlySchedulerGetRoleSummaryResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetRoleSummaryResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetRoleSummaryResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetRoleSummaryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRoleSummary_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetRoleSummaryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetRoleSummaryResult(%+v)", *p)
}

// Attributes:
//  - Role
type ReadOnlySchedulerGetJobSummaryArgs struct {
	Role string `thrift:"role,1" json:"role"`
}

func NewReadOnlySchedulerGetJobSummaryArgs() *ReadOnlySchedulerGetJobSummaryArgs {
	return &ReadOnlySchedulerGetJobSummaryArgs{}
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) GetRole() string {
	return p.Role
}
func (p *ReadOnlySchedulerGetJobSummaryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Role = v
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobSummary_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("role", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:role: ", p), err)
	}
	if err := oprot.WriteString(string(p.Role)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.role (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:role: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetJobSummaryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobSummaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobSummaryResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobSummaryResult() *ReadOnlySchedulerGetJobSummaryResult {
	return &ReadOnlySchedulerGetJobSummaryResult{}
}

var ReadOnlySchedulerGetJobSummaryResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetJobSummaryResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetJobSummaryResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetJobSummaryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobSummary_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobSummaryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetJobSummaryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobSummaryResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetTasksStatusArgs struct {
	Query *TaskQuery `thrift:"query,1" json:"query"`
}

func NewReadOnlySchedulerGetTasksStatusArgs() *ReadOnlySchedulerGetTasksStatusArgs {
	return &ReadOnlySchedulerGetTasksStatusArgs{}
}

var ReadOnlySchedulerGetTasksStatusArgs_Query_DEFAULT *TaskQuery

func (p *ReadOnlySchedulerGetTasksStatusArgs) GetQuery() *TaskQuery {
	if !p.IsSetQuery() {
		return ReadOnlySchedulerGetTasksStatusArgs_Query_DEFAULT
	}
	return p.Query
}
func (p *ReadOnlySchedulerGetTasksStatusArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) readField1(iprot thrift.TProtocol) error {
	p.Query = &TaskQuery{}
	if err := p.Query.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTasksStatus_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetTasksStatusArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetTasksStatusArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetTasksStatusResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetTasksStatusResult() *ReadOnlySchedulerGetTasksStatusResult {
	return &ReadOnlySchedulerGetTasksStatusResult{}
}

var ReadOnlySchedulerGetTasksStatusResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetTasksStatusResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetTasksStatusResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetTasksStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTasksStatus_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksStatusResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetTasksStatusResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetTasksStatusResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetTasksWithoutConfigsArgs struct {
	Query *TaskQuery `thrift:"query,1" json:"query"`
}

func NewReadOnlySchedulerGetTasksWithoutConfigsArgs() *ReadOnlySchedulerGetTasksWithoutConfigsArgs {
	return &ReadOnlySchedulerGetTasksWithoutConfigsArgs{}
}

var ReadOnlySchedulerGetTasksWithoutConfigsArgs_Query_DEFAULT *TaskQuery

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) GetQuery() *TaskQuery {
	if !p.IsSetQuery() {
		return ReadOnlySchedulerGetTasksWithoutConfigsArgs_Query_DEFAULT
	}
	return p.Query
}
func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) readField1(iprot thrift.TProtocol) error {
	p.Query = &TaskQuery{}
	if err := p.Query.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTasksWithoutConfigs_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetTasksWithoutConfigsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetTasksWithoutConfigsResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetTasksWithoutConfigsResult() *ReadOnlySchedulerGetTasksWithoutConfigsResult {
	return &ReadOnlySchedulerGetTasksWithoutConfigsResult{}
}

var ReadOnlySchedulerGetTasksWithoutConfigsResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetTasksWithoutConfigsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTasksWithoutConfigs_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetTasksWithoutConfigsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetTasksWithoutConfigsResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetPendingReasonArgs struct {
	Query *TaskQuery `thrift:"query,1" json:"query"`
}

func NewReadOnlySchedulerGetPendingReasonArgs() *ReadOnlySchedulerGetPendingReasonArgs {
	return &ReadOnlySchedulerGetPendingReasonArgs{}
}

var ReadOnlySchedulerGetPendingReasonArgs_Query_DEFAULT *TaskQuery

func (p *ReadOnlySchedulerGetPendingReasonArgs) GetQuery() *TaskQuery {
	if !p.IsSetQuery() {
		return ReadOnlySchedulerGetPendingReasonArgs_Query_DEFAULT
	}
	return p.Query
}
func (p *ReadOnlySchedulerGetPendingReasonArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) readField1(iprot thrift.TProtocol) error {
	p.Query = &TaskQuery{}
	if err := p.Query.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPendingReason_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetPendingReasonArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetPendingReasonArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetPendingReasonResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetPendingReasonResult() *ReadOnlySchedulerGetPendingReasonResult {
	return &ReadOnlySchedulerGetPendingReasonResult{}
}

var ReadOnlySchedulerGetPendingReasonResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetPendingReasonResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetPendingReasonResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetPendingReasonResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPendingReason_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetPendingReasonResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetPendingReasonResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetPendingReasonResult(%+v)", *p)
}

// Attributes:
//  - Job
type ReadOnlySchedulerGetConfigSummaryArgs struct {
	Job *JobKey `thrift:"job,1" json:"job"`
}

func NewReadOnlySchedulerGetConfigSummaryArgs() *ReadOnlySchedulerGetConfigSummaryArgs {
	return &ReadOnlySchedulerGetConfigSummaryArgs{}
}

var ReadOnlySchedulerGetConfigSummaryArgs_Job_DEFAULT *JobKey

func (p *ReadOnlySchedulerGetConfigSummaryArgs) GetJob() *JobKey {
	if !p.IsSetJob() {
		return ReadOnlySchedulerGetConfigSummaryArgs_Job_DEFAULT
	}
	return p.Job
}
func (p *ReadOnlySchedulerGetConfigSummaryArgs) IsSetJob() bool {
	return p.Job != nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) readField1(iprot thrift.TProtocol) error {
	p.Job = &JobKey{}
	if err := p.Job.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getConfigSummary_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("job", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:job: ", p), err)
	}
	if err := p.Job.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:job: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetConfigSummaryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetConfigSummaryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetConfigSummaryResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetConfigSummaryResult() *ReadOnlySchedulerGetConfigSummaryResult {
	return &ReadOnlySchedulerGetConfigSummaryResult{}
}

var ReadOnlySchedulerGetConfigSummaryResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetConfigSummaryResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetConfigSummaryResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetConfigSummaryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getConfigSummary_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetConfigSummaryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetConfigSummaryResult(%+v)", *p)
}

// Attributes:
//  - OwnerRole
type ReadOnlySchedulerGetJobsArgs struct {
	OwnerRole string `thrift:"ownerRole,1" json:"ownerRole"`
}

func NewReadOnlySchedulerGetJobsArgs() *ReadOnlySchedulerGetJobsArgs {
	return &ReadOnlySchedulerGetJobsArgs{}
}

func (p *ReadOnlySchedulerGetJobsArgs) GetOwnerRole() string {
	return p.OwnerRole
}
func (p *ReadOnlySchedulerGetJobsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.OwnerRole = v
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobs_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ownerRole", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ownerRole: ", p), err)
	}
	if err := oprot.WriteString(string(p.OwnerRole)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ownerRole (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ownerRole: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetJobsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobsResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobsResult() *ReadOnlySchedulerGetJobsResult {
	return &ReadOnlySchedulerGetJobsResult{}
}

var ReadOnlySchedulerGetJobsResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetJobsResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetJobsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetJobsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobs_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetJobsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobsResult(%+v)", *p)
}

// Attributes:
//  - OwnerRole
type ReadOnlySchedulerGetQuotaArgs struct {
	OwnerRole string `thrift:"ownerRole,1" json:"ownerRole"`
}

func NewReadOnlySchedulerGetQuotaArgs() *ReadOnlySchedulerGetQuotaArgs {
	return &ReadOnlySchedulerGetQuotaArgs{}
}

func (p *ReadOnlySchedulerGetQuotaArgs) GetOwnerRole() string {
	return p.OwnerRole
}
func (p *ReadOnlySchedulerGetQuotaArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetQuotaArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.OwnerRole = v
	}
	return nil
}

func (p *ReadOnlySchedulerGetQuotaArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getQuota_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetQuotaArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ownerRole", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ownerRole: ", p), err)
	}
	if err := oprot.WriteString(string(p.OwnerRole)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ownerRole (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ownerRole: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetQuotaArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetQuotaArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetQuotaResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetQuotaResult() *ReadOnlySchedulerGetQuotaResult {
	return &ReadOnlySchedulerGetQuotaResult{}
}

var ReadOnlySchedulerGetQuotaResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetQuotaResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetQuotaResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetQuotaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetQuotaResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetQuotaResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetQuotaResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getQuota_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetQuotaResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetQuotaResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetQuotaResult(%+v)", *p)
}

// Attributes:
//  - Description
type ReadOnlySchedulerPopulateJobConfigArgs struct {
	Description *JobConfiguration `thrift:"description,1" json:"description"`
}

func NewReadOnlySchedulerPopulateJobConfigArgs() *ReadOnlySchedulerPopulateJobConfigArgs {
	return &ReadOnlySchedulerPopulateJobConfigArgs{}
}

var ReadOnlySchedulerPopulateJobConfigArgs_Description_DEFAULT *JobConfiguration

func (p *ReadOnlySchedulerPopulateJobConfigArgs) GetDescription() *JobConfiguration {
	if !p.IsSetDescription() {
		return ReadOnlySchedulerPopulateJobConfigArgs_Description_DEFAULT
	}
	return p.Description
}
func (p *ReadOnlySchedulerPopulateJobConfigArgs) IsSetDescription() bool {
	return p.Description != nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) readField1(iprot thrift.TProtocol) error {
	p.Description = &JobConfiguration{}
	if err := p.Description.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Description), err)
	}
	return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("populateJobConfig_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("description", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:description: ", p), err)
	}
	if err := p.Description.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Description), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:description: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerPopulateJobConfigArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerPopulateJobConfigArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerPopulateJobConfigResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerPopulateJobConfigResult() *ReadOnlySchedulerPopulateJobConfigResult {
	return &ReadOnlySchedulerPopulateJobConfigResult{}
}

var ReadOnlySchedulerPopulateJobConfigResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerPopulateJobConfigResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerPopulateJobConfigResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerPopulateJobConfigResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("populateJobConfig_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerPopulateJobConfigResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerPopulateJobConfigResult(%+v)", *p)
}

// Attributes:
//  - JobUpdateQuery
type ReadOnlySchedulerGetJobUpdateSummariesArgs struct {
	JobUpdateQuery *JobUpdateQuery `thrift:"jobUpdateQuery,1" json:"jobUpdateQuery"`
}

func NewReadOnlySchedulerGetJobUpdateSummariesArgs() *ReadOnlySchedulerGetJobUpdateSummariesArgs {
	return &ReadOnlySchedulerGetJobUpdateSummariesArgs{}
}

var ReadOnlySchedulerGetJobUpdateSummariesArgs_JobUpdateQuery_DEFAULT *JobUpdateQuery

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) GetJobUpdateQuery() *JobUpdateQuery {
	if !p.IsSetJobUpdateQuery() {
		return ReadOnlySchedulerGetJobUpdateSummariesArgs_JobUpdateQuery_DEFAULT
	}
	return p.JobUpdateQuery
}
func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) IsSetJobUpdateQuery() bool {
	return p.JobUpdateQuery != nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) readField1(iprot thrift.TProtocol) error {
	p.JobUpdateQuery = &JobUpdateQuery{}
	if err := p.JobUpdateQuery.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.JobUpdateQuery), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobUpdateSummaries_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("jobUpdateQuery", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:jobUpdateQuery: ", p), err)
	}
	if err := p.JobUpdateQuery.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.JobUpdateQuery), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:jobUpdateQuery: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateSummariesArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobUpdateSummariesResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobUpdateSummariesResult() *ReadOnlySchedulerGetJobUpdateSummariesResult {
	return &ReadOnlySchedulerGetJobUpdateSummariesResult{}
}

var ReadOnlySchedulerGetJobUpdateSummariesResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetJobUpdateSummariesResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobUpdateSummaries_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetJobUpdateSummariesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateSummariesResult(%+v)", *p)
}

// Attributes:
//  - Query
type ReadOnlySchedulerGetJobUpdateDetailsArgs struct {
	// unused field # 1
	Query *JobUpdateQuery `thrift:"query,2" json:"query"`
}

func NewReadOnlySchedulerGetJobUpdateDetailsArgs() *ReadOnlySchedulerGetJobUpdateDetailsArgs {
	return &ReadOnlySchedulerGetJobUpdateDetailsArgs{}
}

var ReadOnlySchedulerGetJobUpdateDetailsArgs_Query_DEFAULT *JobUpdateQuery

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) GetQuery() *JobUpdateQuery {
	if !p.IsSetQuery() {
		return ReadOnlySchedulerGetJobUpdateDetailsArgs_Query_DEFAULT
	}
	return p.Query
}
func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) readField2(iprot thrift.TProtocol) error {
	p.Query = &JobUpdateQuery{}
	if err := p.Query.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobUpdateDetails_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:query: ", p), err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:query: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDetailsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobUpdateDetailsResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobUpdateDetailsResult() *ReadOnlySchedulerGetJobUpdateDetailsResult {
	return &ReadOnlySchedulerGetJobUpdateDetailsResult{}
}

var ReadOnlySchedulerGetJobUpdateDetailsResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetJobUpdateDetailsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobUpdateDetails_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetJobUpdateDetailsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDetailsResult(%+v)", *p)
}

// Attributes:
//  - Request
type ReadOnlySchedulerGetJobUpdateDiffArgs struct {
	Request *JobUpdateRequest `thrift:"request,1" json:"request"`
}

func NewReadOnlySchedulerGetJobUpdateDiffArgs() *ReadOnlySchedulerGetJobUpdateDiffArgs {
	return &ReadOnlySchedulerGetJobUpdateDiffArgs{}
}

var ReadOnlySchedulerGetJobUpdateDiffArgs_Request_DEFAULT *JobUpdateRequest

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) GetRequest() *JobUpdateRequest {
	if !p.IsSetRequest() {
		return ReadOnlySchedulerGetJobUpdateDiffArgs_Request_DEFAULT
	}
	return p.Request
}
func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) readField1(iprot thrift.TProtocol) error {
	p.Request = &JobUpdateRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobUpdateDiff_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *ReadOnlySchedulerGetJobUpdateDiffArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDiffArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetJobUpdateDiffResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetJobUpdateDiffResult() *ReadOnlySchedulerGetJobUpdateDiffResult {
	return &ReadOnlySchedulerGetJobUpdateDiffResult{}
}

var ReadOnlySchedulerGetJobUpdateDiffResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetJobUpdateDiffResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetJobUpdateDiffResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getJobUpdateDiff_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetJobUpdateDiffResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetJobUpdateDiffResult(%+v)", *p)
}

type ReadOnlySchedulerGetTierConfigsArgs struct {
}

func NewReadOnlySchedulerGetTierConfigsArgs() *ReadOnlySchedulerGetTierConfigsArgs {
	return &ReadOnlySchedulerGetTierConfigsArgs{}
}

func (p *ReadOnlySchedulerGetTierConfigsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTierConfigsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTierConfigs_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTierConfigsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetTierConfigsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type ReadOnlySchedulerGetTierConfigsResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewReadOnlySchedulerGetTierConfigsResult() *ReadOnlySchedulerGetTierConfigsResult {
	return &ReadOnlySchedulerGetTierConfigsResult{}
}

var ReadOnlySchedulerGetTierConfigsResult_Success_DEFAULT *Response

func (p *ReadOnlySchedulerGetTierConfigsResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return ReadOnlySchedulerGetTierConfigsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ReadOnlySchedulerGetTierConfigsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTierConfigs_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ReadOnlySchedulerGetTierConfigsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ReadOnlySchedulerGetTierConfigsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ReadOnlySchedulerGetTierConfigsResult(%+v)", *p)
}
