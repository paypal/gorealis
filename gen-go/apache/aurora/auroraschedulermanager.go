// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package aurora

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type AuroraSchedulerManager interface {
	ReadOnlyScheduler

	// Creates a new job.  The request will be denied if a job with the provided name already exists
	// in the cluster.
	//
	// Parameters:
	//  - Description
	CreateJob(description *JobConfiguration) (r *Response, err error)
	// Enters a job into the cron schedule, without actually starting the job.
	// If the job is already present in the schedule, this will update the schedule entry with the new
	// configuration.
	//
	// Parameters:
	//  - Description
	ScheduleCronJob(description *JobConfiguration) (r *Response, err error)
	// Removes a job from the cron schedule. The request will be denied if the job was not previously
	// scheduled with scheduleCronJob.
	//
	// Parameters:
	//  - Job
	DescheduleCronJob(job *JobKey) (r *Response, err error)
	// Starts a cron job immediately.  The request will be denied if the specified job does not
	// exist for the role account, or the job is not a cron job.
	//
	// Parameters:
	//  - Job
	StartCronJob(job *JobKey) (r *Response, err error)
	// Restarts a batch of shards.
	//
	// Parameters:
	//  - Job
	//  - ShardIds
	RestartShards(job *JobKey, shardIds map[int32]bool) (r *Response, err error)
	// Initiates a kill on tasks.
	//
	// Parameters:
	//  - Job
	//  - Instances
	//  - Message
	KillTasks(job *JobKey, instances map[int32]bool, message string) (r *Response, err error)
	// Adds new instances with the TaskConfig of the existing instance pointed by the key.
	//
	// Parameters:
	//  - Key
	//  - Count
	AddInstances(key *InstanceKey, count int32) (r *Response, err error)
	// Replaces the template (configuration) for the existing cron job.
	// The cron job template (configuration) must exist for the call to succeed.
	//
	// Parameters:
	//  - Config
	ReplaceCronTemplate(config *JobConfiguration) (r *Response, err error)
	// Starts update of the existing service job.
	//
	// Parameters:
	//  - Request: A description of how to change the job.
	//  - Message: A user-specified message to include with the induced job update state change.
	StartJobUpdate(request *JobUpdateRequest, message string) (r *Response, err error)
	// Pauses the specified job update. Can be resumed by resumeUpdate call.
	//
	// Parameters:
	//  - Key: The update to pause.
	//  - Message: A user-specified message to include with the induced job update state change.
	PauseJobUpdate(key *JobUpdateKey, message string) (r *Response, err error)
	// Resumes progress of a previously paused job update.
	//
	// Parameters:
	//  - Key: The update to resume.
	//  - Message: A user-specified message to include with the induced job update state change.
	ResumeJobUpdate(key *JobUpdateKey, message string) (r *Response, err error)
	// Permanently aborts the job update. Does not remove the update history.
	//
	// Parameters:
	//  - Key: The update to abort.
	//  - Message: A user-specified message to include with the induced job update state change.
	AbortJobUpdate(key *JobUpdateKey, message string) (r *Response, err error)
	// Rollbacks the specified active job update to the initial state.
	//
	// Parameters:
	//  - Key: The update to rollback.
	//  - Message: A user-specified message to include with the induced job update state change.
	RollbackJobUpdate(key *JobUpdateKey, message string) (r *Response, err error)
	// Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in
	// JobUpdateSettings. Unblocks progress if the update was previously blocked.
	// Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.
	//
	// Parameters:
	//  - Key
	PulseJobUpdate(key *JobUpdateKey) (r *Response, err error)
}

type AuroraSchedulerManagerClient struct {
	*ReadOnlySchedulerClient
}

func NewAuroraSchedulerManagerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *AuroraSchedulerManagerClient {
	return &AuroraSchedulerManagerClient{ReadOnlySchedulerClient: NewReadOnlySchedulerClientFactory(t, f)}
}

func NewAuroraSchedulerManagerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *AuroraSchedulerManagerClient {
	return &AuroraSchedulerManagerClient{ReadOnlySchedulerClient: NewReadOnlySchedulerClientProtocol(t, iprot, oprot)}
}

// Creates a new job.  The request will be denied if a job with the provided name already exists
// in the cluster.
//
// Parameters:
//  - Description
func (p *AuroraSchedulerManagerClient) CreateJob(description *JobConfiguration) (r *Response, err error) {
	if err = p.sendCreateJob(description); err != nil {
		return
	}
	return p.recvCreateJob()
}

func (p *AuroraSchedulerManagerClient) sendCreateJob(description *JobConfiguration) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("createJob", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerCreateJobArgs{
		Description: description,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvCreateJob() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "createJob" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "createJob failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createJob failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error132 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error133 error
		error133, err = error132.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error133
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "createJob failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerCreateJobResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Enters a job into the cron schedule, without actually starting the job.
// If the job is already present in the schedule, this will update the schedule entry with the new
// configuration.
//
// Parameters:
//  - Description
func (p *AuroraSchedulerManagerClient) ScheduleCronJob(description *JobConfiguration) (r *Response, err error) {
	if err = p.sendScheduleCronJob(description); err != nil {
		return
	}
	return p.recvScheduleCronJob()
}

func (p *AuroraSchedulerManagerClient) sendScheduleCronJob(description *JobConfiguration) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scheduleCronJob", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerScheduleCronJobArgs{
		Description: description,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvScheduleCronJob() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "scheduleCronJob" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "scheduleCronJob failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scheduleCronJob failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error134 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error135 error
		error135, err = error134.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error135
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "scheduleCronJob failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerScheduleCronJobResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Removes a job from the cron schedule. The request will be denied if the job was not previously
// scheduled with scheduleCronJob.
//
// Parameters:
//  - Job
func (p *AuroraSchedulerManagerClient) DescheduleCronJob(job *JobKey) (r *Response, err error) {
	if err = p.sendDescheduleCronJob(job); err != nil {
		return
	}
	return p.recvDescheduleCronJob()
}

func (p *AuroraSchedulerManagerClient) sendDescheduleCronJob(job *JobKey) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("descheduleCronJob", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerDescheduleCronJobArgs{
		Job: job,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvDescheduleCronJob() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "descheduleCronJob" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "descheduleCronJob failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "descheduleCronJob failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error136 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error137 error
		error137, err = error136.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error137
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "descheduleCronJob failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerDescheduleCronJobResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Starts a cron job immediately.  The request will be denied if the specified job does not
// exist for the role account, or the job is not a cron job.
//
// Parameters:
//  - Job
func (p *AuroraSchedulerManagerClient) StartCronJob(job *JobKey) (r *Response, err error) {
	if err = p.sendStartCronJob(job); err != nil {
		return
	}
	return p.recvStartCronJob()
}

func (p *AuroraSchedulerManagerClient) sendStartCronJob(job *JobKey) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("startCronJob", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerStartCronJobArgs{
		Job: job,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvStartCronJob() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "startCronJob" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "startCronJob failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "startCronJob failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error138 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error139 error
		error139, err = error138.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error139
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "startCronJob failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerStartCronJobResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Restarts a batch of shards.
//
// Parameters:
//  - Job
//  - ShardIds
func (p *AuroraSchedulerManagerClient) RestartShards(job *JobKey, shardIds map[int32]bool) (r *Response, err error) {
	if err = p.sendRestartShards(job, shardIds); err != nil {
		return
	}
	return p.recvRestartShards()
}

func (p *AuroraSchedulerManagerClient) sendRestartShards(job *JobKey, shardIds map[int32]bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("restartShards", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerRestartShardsArgs{
		Job:      job,
		ShardIds: shardIds,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvRestartShards() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "restartShards" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "restartShards failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "restartShards failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error140 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error141 error
		error141, err = error140.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error141
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "restartShards failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerRestartShardsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Initiates a kill on tasks.
//
// Parameters:
//  - Job
//  - Instances
//  - Message
func (p *AuroraSchedulerManagerClient) KillTasks(job *JobKey, instances map[int32]bool, message string) (r *Response, err error) {
	if err = p.sendKillTasks(job, instances, message); err != nil {
		return
	}
	return p.recvKillTasks()
}

func (p *AuroraSchedulerManagerClient) sendKillTasks(job *JobKey, instances map[int32]bool, message string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("killTasks", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerKillTasksArgs{
		Job:       job,
		Instances: instances,
		Message:   message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvKillTasks() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "killTasks" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "killTasks failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "killTasks failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error142 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error143 error
		error143, err = error142.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error143
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "killTasks failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerKillTasksResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Adds new instances with the TaskConfig of the existing instance pointed by the key.
//
// Parameters:
//  - Key
//  - Count
func (p *AuroraSchedulerManagerClient) AddInstances(key *InstanceKey, count int32) (r *Response, err error) {
	if err = p.sendAddInstances(key, count); err != nil {
		return
	}
	return p.recvAddInstances()
}

func (p *AuroraSchedulerManagerClient) sendAddInstances(key *InstanceKey, count int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("addInstances", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerAddInstancesArgs{
		Key:   key,
		Count: count,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvAddInstances() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "addInstances" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "addInstances failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "addInstances failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error144 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error145 error
		error145, err = error144.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error145
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "addInstances failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerAddInstancesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Replaces the template (configuration) for the existing cron job.
// The cron job template (configuration) must exist for the call to succeed.
//
// Parameters:
//  - Config
func (p *AuroraSchedulerManagerClient) ReplaceCronTemplate(config *JobConfiguration) (r *Response, err error) {
	if err = p.sendReplaceCronTemplate(config); err != nil {
		return
	}
	return p.recvReplaceCronTemplate()
}

func (p *AuroraSchedulerManagerClient) sendReplaceCronTemplate(config *JobConfiguration) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("replaceCronTemplate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerReplaceCronTemplateArgs{
		Config: config,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvReplaceCronTemplate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "replaceCronTemplate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "replaceCronTemplate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "replaceCronTemplate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error146 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error147 error
		error147, err = error146.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error147
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "replaceCronTemplate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerReplaceCronTemplateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Starts update of the existing service job.
//
// Parameters:
//  - Request: A description of how to change the job.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) StartJobUpdate(request *JobUpdateRequest, message string) (r *Response, err error) {
	if err = p.sendStartJobUpdate(request, message); err != nil {
		return
	}
	return p.recvStartJobUpdate()
}

func (p *AuroraSchedulerManagerClient) sendStartJobUpdate(request *JobUpdateRequest, message string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("startJobUpdate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerStartJobUpdateArgs{
		Request: request,
		Message: message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvStartJobUpdate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "startJobUpdate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "startJobUpdate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "startJobUpdate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error148 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error149 error
		error149, err = error148.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error149
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "startJobUpdate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerStartJobUpdateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Pauses the specified job update. Can be resumed by resumeUpdate call.
//
// Parameters:
//  - Key: The update to pause.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) PauseJobUpdate(key *JobUpdateKey, message string) (r *Response, err error) {
	if err = p.sendPauseJobUpdate(key, message); err != nil {
		return
	}
	return p.recvPauseJobUpdate()
}

func (p *AuroraSchedulerManagerClient) sendPauseJobUpdate(key *JobUpdateKey, message string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("pauseJobUpdate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerPauseJobUpdateArgs{
		Key:     key,
		Message: message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvPauseJobUpdate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "pauseJobUpdate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "pauseJobUpdate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "pauseJobUpdate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error150 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error151 error
		error151, err = error150.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error151
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "pauseJobUpdate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerPauseJobUpdateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Resumes progress of a previously paused job update.
//
// Parameters:
//  - Key: The update to resume.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) ResumeJobUpdate(key *JobUpdateKey, message string) (r *Response, err error) {
	if err = p.sendResumeJobUpdate(key, message); err != nil {
		return
	}
	return p.recvResumeJobUpdate()
}

func (p *AuroraSchedulerManagerClient) sendResumeJobUpdate(key *JobUpdateKey, message string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("resumeJobUpdate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerResumeJobUpdateArgs{
		Key:     key,
		Message: message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvResumeJobUpdate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "resumeJobUpdate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "resumeJobUpdate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "resumeJobUpdate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error152 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error153 error
		error153, err = error152.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error153
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "resumeJobUpdate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerResumeJobUpdateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Permanently aborts the job update. Does not remove the update history.
//
// Parameters:
//  - Key: The update to abort.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) AbortJobUpdate(key *JobUpdateKey, message string) (r *Response, err error) {
	if err = p.sendAbortJobUpdate(key, message); err != nil {
		return
	}
	return p.recvAbortJobUpdate()
}

func (p *AuroraSchedulerManagerClient) sendAbortJobUpdate(key *JobUpdateKey, message string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("abortJobUpdate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerAbortJobUpdateArgs{
		Key:     key,
		Message: message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvAbortJobUpdate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "abortJobUpdate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "abortJobUpdate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "abortJobUpdate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error154 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error155 error
		error155, err = error154.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error155
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "abortJobUpdate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerAbortJobUpdateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Rollbacks the specified active job update to the initial state.
//
// Parameters:
//  - Key: The update to rollback.
//  - Message: A user-specified message to include with the induced job update state change.
func (p *AuroraSchedulerManagerClient) RollbackJobUpdate(key *JobUpdateKey, message string) (r *Response, err error) {
	if err = p.sendRollbackJobUpdate(key, message); err != nil {
		return
	}
	return p.recvRollbackJobUpdate()
}

func (p *AuroraSchedulerManagerClient) sendRollbackJobUpdate(key *JobUpdateKey, message string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("rollbackJobUpdate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerRollbackJobUpdateArgs{
		Key:     key,
		Message: message,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvRollbackJobUpdate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "rollbackJobUpdate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "rollbackJobUpdate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "rollbackJobUpdate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error156 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error157 error
		error157, err = error156.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error157
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "rollbackJobUpdate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerRollbackJobUpdateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Allows progress of the job update in case blockIfNoPulsesAfterMs is specified in
// JobUpdateSettings. Unblocks progress if the update was previously blocked.
// Responds with ResponseCode.INVALID_REQUEST in case an unknown update key is specified.
//
// Parameters:
//  - Key
func (p *AuroraSchedulerManagerClient) PulseJobUpdate(key *JobUpdateKey) (r *Response, err error) {
	if err = p.sendPulseJobUpdate(key); err != nil {
		return
	}
	return p.recvPulseJobUpdate()
}

func (p *AuroraSchedulerManagerClient) sendPulseJobUpdate(key *JobUpdateKey) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("pulseJobUpdate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AuroraSchedulerManagerPulseJobUpdateArgs{
		Key: key,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *AuroraSchedulerManagerClient) recvPulseJobUpdate() (value *Response, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "pulseJobUpdate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "pulseJobUpdate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "pulseJobUpdate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error158 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error159 error
		error159, err = error158.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error159
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "pulseJobUpdate failed: invalid message type")
		return
	}
	result := AuroraSchedulerManagerPulseJobUpdateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

type AuroraSchedulerManagerProcessor struct {
	*ReadOnlySchedulerProcessor
}

func NewAuroraSchedulerManagerProcessor(handler AuroraSchedulerManager) *AuroraSchedulerManagerProcessor {
	self160 := &AuroraSchedulerManagerProcessor{NewReadOnlySchedulerProcessor(handler)}
	self160.AddToProcessorMap("createJob", &auroraSchedulerManagerProcessorCreateJob{handler: handler})
	self160.AddToProcessorMap("scheduleCronJob", &auroraSchedulerManagerProcessorScheduleCronJob{handler: handler})
	self160.AddToProcessorMap("descheduleCronJob", &auroraSchedulerManagerProcessorDescheduleCronJob{handler: handler})
	self160.AddToProcessorMap("startCronJob", &auroraSchedulerManagerProcessorStartCronJob{handler: handler})
	self160.AddToProcessorMap("restartShards", &auroraSchedulerManagerProcessorRestartShards{handler: handler})
	self160.AddToProcessorMap("killTasks", &auroraSchedulerManagerProcessorKillTasks{handler: handler})
	self160.AddToProcessorMap("addInstances", &auroraSchedulerManagerProcessorAddInstances{handler: handler})
	self160.AddToProcessorMap("replaceCronTemplate", &auroraSchedulerManagerProcessorReplaceCronTemplate{handler: handler})
	self160.AddToProcessorMap("startJobUpdate", &auroraSchedulerManagerProcessorStartJobUpdate{handler: handler})
	self160.AddToProcessorMap("pauseJobUpdate", &auroraSchedulerManagerProcessorPauseJobUpdate{handler: handler})
	self160.AddToProcessorMap("resumeJobUpdate", &auroraSchedulerManagerProcessorResumeJobUpdate{handler: handler})
	self160.AddToProcessorMap("abortJobUpdate", &auroraSchedulerManagerProcessorAbortJobUpdate{handler: handler})
	self160.AddToProcessorMap("rollbackJobUpdate", &auroraSchedulerManagerProcessorRollbackJobUpdate{handler: handler})
	self160.AddToProcessorMap("pulseJobUpdate", &auroraSchedulerManagerProcessorPulseJobUpdate{handler: handler})
	return self160
}

type auroraSchedulerManagerProcessorCreateJob struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorCreateJob) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerCreateJobArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerCreateJobResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.CreateJob(args.Description); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createJob: "+err2.Error())
		oprot.WriteMessageBegin("createJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("createJob", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorScheduleCronJob struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorScheduleCronJob) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerScheduleCronJobArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scheduleCronJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerScheduleCronJobResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.ScheduleCronJob(args.Description); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scheduleCronJob: "+err2.Error())
		oprot.WriteMessageBegin("scheduleCronJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("scheduleCronJob", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorDescheduleCronJob struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorDescheduleCronJob) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerDescheduleCronJobArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("descheduleCronJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerDescheduleCronJobResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.DescheduleCronJob(args.Job); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing descheduleCronJob: "+err2.Error())
		oprot.WriteMessageBegin("descheduleCronJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("descheduleCronJob", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorStartCronJob struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorStartCronJob) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerStartCronJobArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("startCronJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerStartCronJobResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.StartCronJob(args.Job); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startCronJob: "+err2.Error())
		oprot.WriteMessageBegin("startCronJob", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("startCronJob", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorRestartShards struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorRestartShards) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerRestartShardsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("restartShards", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerRestartShardsResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.RestartShards(args.Job, args.ShardIds); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing restartShards: "+err2.Error())
		oprot.WriteMessageBegin("restartShards", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("restartShards", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorKillTasks struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorKillTasks) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerKillTasksArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("killTasks", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerKillTasksResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.KillTasks(args.Job, args.Instances, args.Message); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing killTasks: "+err2.Error())
		oprot.WriteMessageBegin("killTasks", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("killTasks", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorAddInstances struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorAddInstances) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerAddInstancesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("addInstances", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerAddInstancesResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.AddInstances(args.Key, args.Count); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addInstances: "+err2.Error())
		oprot.WriteMessageBegin("addInstances", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("addInstances", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorReplaceCronTemplate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorReplaceCronTemplate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerReplaceCronTemplateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("replaceCronTemplate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerReplaceCronTemplateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.ReplaceCronTemplate(args.Config); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing replaceCronTemplate: "+err2.Error())
		oprot.WriteMessageBegin("replaceCronTemplate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("replaceCronTemplate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorStartJobUpdate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorStartJobUpdate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerStartJobUpdateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("startJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerStartJobUpdateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.StartJobUpdate(args.Request, args.Message); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing startJobUpdate: "+err2.Error())
		oprot.WriteMessageBegin("startJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("startJobUpdate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorPauseJobUpdate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorPauseJobUpdate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerPauseJobUpdateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("pauseJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerPauseJobUpdateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.PauseJobUpdate(args.Key, args.Message); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pauseJobUpdate: "+err2.Error())
		oprot.WriteMessageBegin("pauseJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("pauseJobUpdate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorResumeJobUpdate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorResumeJobUpdate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerResumeJobUpdateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("resumeJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerResumeJobUpdateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.ResumeJobUpdate(args.Key, args.Message); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing resumeJobUpdate: "+err2.Error())
		oprot.WriteMessageBegin("resumeJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("resumeJobUpdate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorAbortJobUpdate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorAbortJobUpdate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerAbortJobUpdateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("abortJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerAbortJobUpdateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.AbortJobUpdate(args.Key, args.Message); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing abortJobUpdate: "+err2.Error())
		oprot.WriteMessageBegin("abortJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("abortJobUpdate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorRollbackJobUpdate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorRollbackJobUpdate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerRollbackJobUpdateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("rollbackJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerRollbackJobUpdateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.RollbackJobUpdate(args.Key, args.Message); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing rollbackJobUpdate: "+err2.Error())
		oprot.WriteMessageBegin("rollbackJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("rollbackJobUpdate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type auroraSchedulerManagerProcessorPulseJobUpdate struct {
	handler AuroraSchedulerManager
}

func (p *auroraSchedulerManagerProcessorPulseJobUpdate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AuroraSchedulerManagerPulseJobUpdateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("pulseJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AuroraSchedulerManagerPulseJobUpdateResult{}
	var retval *Response
	var err2 error
	if retval, err2 = p.handler.PulseJobUpdate(args.Key); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing pulseJobUpdate: "+err2.Error())
		oprot.WriteMessageBegin("pulseJobUpdate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("pulseJobUpdate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Description
type AuroraSchedulerManagerCreateJobArgs struct {
	Description *JobConfiguration `thrift:"description,1" json:"description"`
}

func NewAuroraSchedulerManagerCreateJobArgs() *AuroraSchedulerManagerCreateJobArgs {
	return &AuroraSchedulerManagerCreateJobArgs{}
}

var AuroraSchedulerManagerCreateJobArgs_Description_DEFAULT *JobConfiguration

func (p *AuroraSchedulerManagerCreateJobArgs) GetDescription() *JobConfiguration {
	if !p.IsSetDescription() {
		return AuroraSchedulerManagerCreateJobArgs_Description_DEFAULT
	}
	return p.Description
}
func (p *AuroraSchedulerManagerCreateJobArgs) IsSetDescription() bool {
	return p.Description != nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) readField1(iprot thrift.TProtocol) error {
	p.Description = &JobConfiguration{}
	if err := p.Description.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Description), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createJob_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerCreateJobArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("description", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:description: ", p), err)
	}
	if err := p.Description.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Description), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:description: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerCreateJobArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerCreateJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerCreateJobResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerCreateJobResult() *AuroraSchedulerManagerCreateJobResult {
	return &AuroraSchedulerManagerCreateJobResult{}
}

var AuroraSchedulerManagerCreateJobResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerCreateJobResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerCreateJobResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerCreateJobResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerCreateJobResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerCreateJobResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerCreateJobResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createJob_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerCreateJobResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerCreateJobResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerCreateJobResult(%+v)", *p)
}

// Attributes:
//  - Description
type AuroraSchedulerManagerScheduleCronJobArgs struct {
	Description *JobConfiguration `thrift:"description,1" json:"description"`
}

func NewAuroraSchedulerManagerScheduleCronJobArgs() *AuroraSchedulerManagerScheduleCronJobArgs {
	return &AuroraSchedulerManagerScheduleCronJobArgs{}
}

var AuroraSchedulerManagerScheduleCronJobArgs_Description_DEFAULT *JobConfiguration

func (p *AuroraSchedulerManagerScheduleCronJobArgs) GetDescription() *JobConfiguration {
	if !p.IsSetDescription() {
		return AuroraSchedulerManagerScheduleCronJobArgs_Description_DEFAULT
	}
	return p.Description
}
func (p *AuroraSchedulerManagerScheduleCronJobArgs) IsSetDescription() bool {
	return p.Description != nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) readField1(iprot thrift.TProtocol) error {
	p.Description = &JobConfiguration{}
	if err := p.Description.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Description), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scheduleCronJob_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("description", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:description: ", p), err)
	}
	if err := p.Description.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Description), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:description: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerScheduleCronJobArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerScheduleCronJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerScheduleCronJobResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerScheduleCronJobResult() *AuroraSchedulerManagerScheduleCronJobResult {
	return &AuroraSchedulerManagerScheduleCronJobResult{}
}

var AuroraSchedulerManagerScheduleCronJobResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerScheduleCronJobResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerScheduleCronJobResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerScheduleCronJobResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scheduleCronJob_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerScheduleCronJobResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerScheduleCronJobResult(%+v)", *p)
}

// Attributes:
//  - Job
type AuroraSchedulerManagerDescheduleCronJobArgs struct {
	// unused fields # 1 to 3
	Job *JobKey `thrift:"job,4" json:"job"`
}

func NewAuroraSchedulerManagerDescheduleCronJobArgs() *AuroraSchedulerManagerDescheduleCronJobArgs {
	return &AuroraSchedulerManagerDescheduleCronJobArgs{}
}

var AuroraSchedulerManagerDescheduleCronJobArgs_Job_DEFAULT *JobKey

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) GetJob() *JobKey {
	if !p.IsSetJob() {
		return AuroraSchedulerManagerDescheduleCronJobArgs_Job_DEFAULT
	}
	return p.Job
}
func (p *AuroraSchedulerManagerDescheduleCronJobArgs) IsSetJob() bool {
	return p.Job != nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) readField4(iprot thrift.TProtocol) error {
	p.Job = &JobKey{}
	if err := p.Job.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("descheduleCronJob_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("job", thrift.STRUCT, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:job: ", p), err)
	}
	if err := p.Job.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:job: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerDescheduleCronJobArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerDescheduleCronJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerDescheduleCronJobResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerDescheduleCronJobResult() *AuroraSchedulerManagerDescheduleCronJobResult {
	return &AuroraSchedulerManagerDescheduleCronJobResult{}
}

var AuroraSchedulerManagerDescheduleCronJobResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerDescheduleCronJobResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerDescheduleCronJobResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerDescheduleCronJobResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("descheduleCronJob_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerDescheduleCronJobResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerDescheduleCronJobResult(%+v)", *p)
}

// Attributes:
//  - Job
type AuroraSchedulerManagerStartCronJobArgs struct {
	// unused fields # 1 to 3
	Job *JobKey `thrift:"job,4" json:"job"`
}

func NewAuroraSchedulerManagerStartCronJobArgs() *AuroraSchedulerManagerStartCronJobArgs {
	return &AuroraSchedulerManagerStartCronJobArgs{}
}

var AuroraSchedulerManagerStartCronJobArgs_Job_DEFAULT *JobKey

func (p *AuroraSchedulerManagerStartCronJobArgs) GetJob() *JobKey {
	if !p.IsSetJob() {
		return AuroraSchedulerManagerStartCronJobArgs_Job_DEFAULT
	}
	return p.Job
}
func (p *AuroraSchedulerManagerStartCronJobArgs) IsSetJob() bool {
	return p.Job != nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) readField4(iprot thrift.TProtocol) error {
	p.Job = &JobKey{}
	if err := p.Job.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("startCronJob_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartCronJobArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("job", thrift.STRUCT, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:job: ", p), err)
	}
	if err := p.Job.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:job: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerStartCronJobArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerStartCronJobArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerStartCronJobResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerStartCronJobResult() *AuroraSchedulerManagerStartCronJobResult {
	return &AuroraSchedulerManagerStartCronJobResult{}
}

var AuroraSchedulerManagerStartCronJobResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerStartCronJobResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerStartCronJobResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerStartCronJobResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("startCronJob_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartCronJobResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerStartCronJobResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerStartCronJobResult(%+v)", *p)
}

// Attributes:
//  - Job
//  - ShardIds
type AuroraSchedulerManagerRestartShardsArgs struct {
	// unused fields # 1 to 2
	ShardIds map[int32]bool `thrift:"shardIds,3" json:"shardIds"`
	// unused field # 4
	Job *JobKey `thrift:"job,5" json:"job"`
}

func NewAuroraSchedulerManagerRestartShardsArgs() *AuroraSchedulerManagerRestartShardsArgs {
	return &AuroraSchedulerManagerRestartShardsArgs{}
}

var AuroraSchedulerManagerRestartShardsArgs_Job_DEFAULT *JobKey

func (p *AuroraSchedulerManagerRestartShardsArgs) GetJob() *JobKey {
	if !p.IsSetJob() {
		return AuroraSchedulerManagerRestartShardsArgs_Job_DEFAULT
	}
	return p.Job
}

func (p *AuroraSchedulerManagerRestartShardsArgs) GetShardIds() map[int32]bool {
	return p.ShardIds
}
func (p *AuroraSchedulerManagerRestartShardsArgs) IsSetJob() bool {
	return p.Job != nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) readField5(iprot thrift.TProtocol) error {
	p.Job = &JobKey{}
	if err := p.Job.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return thrift.PrependError("error reading set begin: ", err)
	}
	tSet := make(map[int32]bool, size)
	p.ShardIds = tSet
	for i := 0; i < size; i++ {
		var _elem161 int32
		if v, err := iprot.ReadI32(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem161 = v
		}
		p.ShardIds[_elem161] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return thrift.PrependError("error reading set end: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("restartShards_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("shardIds", thrift.SET, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:shardIds: ", p), err)
	}
	if err := oprot.WriteSetBegin(thrift.I32, len(p.ShardIds)); err != nil {
		return thrift.PrependError("error writing set begin: ", err)
	}
	for v, _ := range p.ShardIds {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteSetEnd(); err != nil {
		return thrift.PrependError("error writing set end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:shardIds: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerRestartShardsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("job", thrift.STRUCT, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:job: ", p), err)
	}
	if err := p.Job.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:job: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerRestartShardsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerRestartShardsArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerRestartShardsResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerRestartShardsResult() *AuroraSchedulerManagerRestartShardsResult {
	return &AuroraSchedulerManagerRestartShardsResult{}
}

var AuroraSchedulerManagerRestartShardsResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerRestartShardsResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerRestartShardsResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerRestartShardsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("restartShards_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRestartShardsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerRestartShardsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerRestartShardsResult(%+v)", *p)
}

// Attributes:
//  - Job
//  - Instances
//  - Message
type AuroraSchedulerManagerKillTasksArgs struct {
	// unused fields # 1 to 3
	Job       *JobKey        `thrift:"job,4" json:"job"`
	Instances map[int32]bool `thrift:"instances,5" json:"instances"`
	Message   string         `thrift:"message,6" json:"message"`
}

func NewAuroraSchedulerManagerKillTasksArgs() *AuroraSchedulerManagerKillTasksArgs {
	return &AuroraSchedulerManagerKillTasksArgs{}
}

var AuroraSchedulerManagerKillTasksArgs_Job_DEFAULT *JobKey

func (p *AuroraSchedulerManagerKillTasksArgs) GetJob() *JobKey {
	if !p.IsSetJob() {
		return AuroraSchedulerManagerKillTasksArgs_Job_DEFAULT
	}
	return p.Job
}

func (p *AuroraSchedulerManagerKillTasksArgs) GetInstances() map[int32]bool {
	return p.Instances
}

func (p *AuroraSchedulerManagerKillTasksArgs) GetMessage() string {
	return p.Message
}
func (p *AuroraSchedulerManagerKillTasksArgs) IsSetJob() bool {
	return p.Job != nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) readField4(iprot thrift.TProtocol) error {
	p.Job = &JobKey{}
	if err := p.Job.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Job), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return thrift.PrependError("error reading set begin: ", err)
	}
	tSet := make(map[int32]bool, size)
	p.Instances = tSet
	for i := 0; i < size; i++ {
		var _elem162 int32
		if v, err := iprot.ReadI32(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem162 = v
		}
		p.Instances[_elem162] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return thrift.PrependError("error reading set end: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("killTasks_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("job", thrift.STRUCT, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:job: ", p), err)
	}
	if err := p.Job.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Job), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:job: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerKillTasksArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("instances", thrift.SET, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:instances: ", p), err)
	}
	if err := oprot.WriteSetBegin(thrift.I32, len(p.Instances)); err != nil {
		return thrift.PrependError("error writing set begin: ", err)
	}
	for v, _ := range p.Instances {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteSetEnd(); err != nil {
		return thrift.PrependError("error writing set end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:instances: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerKillTasksArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:message: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerKillTasksArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerKillTasksArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerKillTasksResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerKillTasksResult() *AuroraSchedulerManagerKillTasksResult {
	return &AuroraSchedulerManagerKillTasksResult{}
}

var AuroraSchedulerManagerKillTasksResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerKillTasksResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerKillTasksResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerKillTasksResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerKillTasksResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("killTasks_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerKillTasksResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerKillTasksResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerKillTasksResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - Count
type AuroraSchedulerManagerAddInstancesArgs struct {
	// unused fields # 1 to 2
	Key   *InstanceKey `thrift:"key,3" json:"key"`
	Count int32        `thrift:"count,4" json:"count"`
}

func NewAuroraSchedulerManagerAddInstancesArgs() *AuroraSchedulerManagerAddInstancesArgs {
	return &AuroraSchedulerManagerAddInstancesArgs{}
}

var AuroraSchedulerManagerAddInstancesArgs_Key_DEFAULT *InstanceKey

func (p *AuroraSchedulerManagerAddInstancesArgs) GetKey() *InstanceKey {
	if !p.IsSetKey() {
		return AuroraSchedulerManagerAddInstancesArgs_Key_DEFAULT
	}
	return p.Key
}

func (p *AuroraSchedulerManagerAddInstancesArgs) GetCount() int32 {
	return p.Count
}
func (p *AuroraSchedulerManagerAddInstancesArgs) IsSetKey() bool {
	return p.Key != nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) readField3(iprot thrift.TProtocol) error {
	p.Key = &InstanceKey{}
	if err := p.Key.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("addInstances_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:key: ", p), err)
	}
	if err := p.Key.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:key: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerAddInstancesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:count: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.count (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:count: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerAddInstancesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerAddInstancesArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerAddInstancesResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerAddInstancesResult() *AuroraSchedulerManagerAddInstancesResult {
	return &AuroraSchedulerManagerAddInstancesResult{}
}

var AuroraSchedulerManagerAddInstancesResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerAddInstancesResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerAddInstancesResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerAddInstancesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("addInstances_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAddInstancesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerAddInstancesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerAddInstancesResult(%+v)", *p)
}

// Attributes:
//  - Config
type AuroraSchedulerManagerReplaceCronTemplateArgs struct {
	Config *JobConfiguration `thrift:"config,1" json:"config"`
}

func NewAuroraSchedulerManagerReplaceCronTemplateArgs() *AuroraSchedulerManagerReplaceCronTemplateArgs {
	return &AuroraSchedulerManagerReplaceCronTemplateArgs{}
}

var AuroraSchedulerManagerReplaceCronTemplateArgs_Config_DEFAULT *JobConfiguration

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) GetConfig() *JobConfiguration {
	if !p.IsSetConfig() {
		return AuroraSchedulerManagerReplaceCronTemplateArgs_Config_DEFAULT
	}
	return p.Config
}
func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) IsSetConfig() bool {
	return p.Config != nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) readField1(iprot thrift.TProtocol) error {
	p.Config = &JobConfiguration{}
	if err := p.Config.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Config), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("replaceCronTemplate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("config", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:config: ", p), err)
	}
	if err := p.Config.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Config), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:config: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerReplaceCronTemplateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerReplaceCronTemplateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerReplaceCronTemplateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerReplaceCronTemplateResult() *AuroraSchedulerManagerReplaceCronTemplateResult {
	return &AuroraSchedulerManagerReplaceCronTemplateResult{}
}

var AuroraSchedulerManagerReplaceCronTemplateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerReplaceCronTemplateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerReplaceCronTemplateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("replaceCronTemplate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerReplaceCronTemplateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerReplaceCronTemplateResult(%+v)", *p)
}

// Attributes:
//  - Request: A description of how to change the job.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerStartJobUpdateArgs struct {
	Request *JobUpdateRequest `thrift:"request,1" json:"request"`
	// unused field # 2
	Message string `thrift:"message,3" json:"message"`
}

func NewAuroraSchedulerManagerStartJobUpdateArgs() *AuroraSchedulerManagerStartJobUpdateArgs {
	return &AuroraSchedulerManagerStartJobUpdateArgs{}
}

var AuroraSchedulerManagerStartJobUpdateArgs_Request_DEFAULT *JobUpdateRequest

func (p *AuroraSchedulerManagerStartJobUpdateArgs) GetRequest() *JobUpdateRequest {
	if !p.IsSetRequest() {
		return AuroraSchedulerManagerStartJobUpdateArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) GetMessage() string {
	return p.Message
}
func (p *AuroraSchedulerManagerStartJobUpdateArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) readField1(iprot thrift.TProtocol) error {
	p.Request = &JobUpdateRequest{}
	if err := p.Request.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("startJobUpdate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerStartJobUpdateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerStartJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerStartJobUpdateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerStartJobUpdateResult() *AuroraSchedulerManagerStartJobUpdateResult {
	return &AuroraSchedulerManagerStartJobUpdateResult{}
}

var AuroraSchedulerManagerStartJobUpdateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerStartJobUpdateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerStartJobUpdateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerStartJobUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("startJobUpdate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerStartJobUpdateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerStartJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to pause.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerPauseJobUpdateArgs struct {
	Key *JobUpdateKey `thrift:"key,1" json:"key"`
	// unused field # 2
	Message string `thrift:"message,3" json:"message"`
}

func NewAuroraSchedulerManagerPauseJobUpdateArgs() *AuroraSchedulerManagerPauseJobUpdateArgs {
	return &AuroraSchedulerManagerPauseJobUpdateArgs{}
}

var AuroraSchedulerManagerPauseJobUpdateArgs_Key_DEFAULT *JobUpdateKey

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) GetKey() *JobUpdateKey {
	if !p.IsSetKey() {
		return AuroraSchedulerManagerPauseJobUpdateArgs_Key_DEFAULT
	}
	return p.Key
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) GetMessage() string {
	return p.Message
}
func (p *AuroraSchedulerManagerPauseJobUpdateArgs) IsSetKey() bool {
	return p.Key != nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) readField1(iprot thrift.TProtocol) error {
	p.Key = &JobUpdateKey{}
	if err := p.Key.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("pauseJobUpdate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := p.Key.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerPauseJobUpdateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerPauseJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerPauseJobUpdateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerPauseJobUpdateResult() *AuroraSchedulerManagerPauseJobUpdateResult {
	return &AuroraSchedulerManagerPauseJobUpdateResult{}
}

var AuroraSchedulerManagerPauseJobUpdateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerPauseJobUpdateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerPauseJobUpdateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerPauseJobUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("pauseJobUpdate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerPauseJobUpdateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerPauseJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to resume.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerResumeJobUpdateArgs struct {
	Key *JobUpdateKey `thrift:"key,1" json:"key"`
	// unused field # 2
	Message string `thrift:"message,3" json:"message"`
}

func NewAuroraSchedulerManagerResumeJobUpdateArgs() *AuroraSchedulerManagerResumeJobUpdateArgs {
	return &AuroraSchedulerManagerResumeJobUpdateArgs{}
}

var AuroraSchedulerManagerResumeJobUpdateArgs_Key_DEFAULT *JobUpdateKey

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) GetKey() *JobUpdateKey {
	if !p.IsSetKey() {
		return AuroraSchedulerManagerResumeJobUpdateArgs_Key_DEFAULT
	}
	return p.Key
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) GetMessage() string {
	return p.Message
}
func (p *AuroraSchedulerManagerResumeJobUpdateArgs) IsSetKey() bool {
	return p.Key != nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) readField1(iprot thrift.TProtocol) error {
	p.Key = &JobUpdateKey{}
	if err := p.Key.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("resumeJobUpdate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := p.Key.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerResumeJobUpdateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerResumeJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerResumeJobUpdateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerResumeJobUpdateResult() *AuroraSchedulerManagerResumeJobUpdateResult {
	return &AuroraSchedulerManagerResumeJobUpdateResult{}
}

var AuroraSchedulerManagerResumeJobUpdateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerResumeJobUpdateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerResumeJobUpdateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerResumeJobUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("resumeJobUpdate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerResumeJobUpdateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerResumeJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to abort.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerAbortJobUpdateArgs struct {
	Key *JobUpdateKey `thrift:"key,1" json:"key"`
	// unused field # 2
	Message string `thrift:"message,3" json:"message"`
}

func NewAuroraSchedulerManagerAbortJobUpdateArgs() *AuroraSchedulerManagerAbortJobUpdateArgs {
	return &AuroraSchedulerManagerAbortJobUpdateArgs{}
}

var AuroraSchedulerManagerAbortJobUpdateArgs_Key_DEFAULT *JobUpdateKey

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) GetKey() *JobUpdateKey {
	if !p.IsSetKey() {
		return AuroraSchedulerManagerAbortJobUpdateArgs_Key_DEFAULT
	}
	return p.Key
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) GetMessage() string {
	return p.Message
}
func (p *AuroraSchedulerManagerAbortJobUpdateArgs) IsSetKey() bool {
	return p.Key != nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) readField1(iprot thrift.TProtocol) error {
	p.Key = &JobUpdateKey{}
	if err := p.Key.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("abortJobUpdate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := p.Key.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:message: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerAbortJobUpdateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerAbortJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerAbortJobUpdateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerAbortJobUpdateResult() *AuroraSchedulerManagerAbortJobUpdateResult {
	return &AuroraSchedulerManagerAbortJobUpdateResult{}
}

var AuroraSchedulerManagerAbortJobUpdateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerAbortJobUpdateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerAbortJobUpdateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerAbortJobUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("abortJobUpdate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerAbortJobUpdateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerAbortJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key: The update to rollback.
//  - Message: A user-specified message to include with the induced job update state change.
type AuroraSchedulerManagerRollbackJobUpdateArgs struct {
	Key     *JobUpdateKey `thrift:"key,1" json:"key"`
	Message string        `thrift:"message,2" json:"message"`
}

func NewAuroraSchedulerManagerRollbackJobUpdateArgs() *AuroraSchedulerManagerRollbackJobUpdateArgs {
	return &AuroraSchedulerManagerRollbackJobUpdateArgs{}
}

var AuroraSchedulerManagerRollbackJobUpdateArgs_Key_DEFAULT *JobUpdateKey

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) GetKey() *JobUpdateKey {
	if !p.IsSetKey() {
		return AuroraSchedulerManagerRollbackJobUpdateArgs_Key_DEFAULT
	}
	return p.Key
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) GetMessage() string {
	return p.Message
}
func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) IsSetKey() bool {
	return p.Key != nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) readField1(iprot thrift.TProtocol) error {
	p.Key = &JobUpdateKey{}
	if err := p.Key.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rollbackJobUpdate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := p.Key.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerRollbackJobUpdateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerRollbackJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerRollbackJobUpdateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerRollbackJobUpdateResult() *AuroraSchedulerManagerRollbackJobUpdateResult {
	return &AuroraSchedulerManagerRollbackJobUpdateResult{}
}

var AuroraSchedulerManagerRollbackJobUpdateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerRollbackJobUpdateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerRollbackJobUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("rollbackJobUpdate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerRollbackJobUpdateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerRollbackJobUpdateResult(%+v)", *p)
}

// Attributes:
//  - Key
type AuroraSchedulerManagerPulseJobUpdateArgs struct {
	Key *JobUpdateKey `thrift:"key,1" json:"key"`
}

func NewAuroraSchedulerManagerPulseJobUpdateArgs() *AuroraSchedulerManagerPulseJobUpdateArgs {
	return &AuroraSchedulerManagerPulseJobUpdateArgs{}
}

var AuroraSchedulerManagerPulseJobUpdateArgs_Key_DEFAULT *JobUpdateKey

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) GetKey() *JobUpdateKey {
	if !p.IsSetKey() {
		return AuroraSchedulerManagerPulseJobUpdateArgs_Key_DEFAULT
	}
	return p.Key
}
func (p *AuroraSchedulerManagerPulseJobUpdateArgs) IsSetKey() bool {
	return p.Key != nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) readField1(iprot thrift.TProtocol) error {
	p.Key = &JobUpdateKey{}
	if err := p.Key.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Key), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("pulseJobUpdate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := p.Key.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Key), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *AuroraSchedulerManagerPulseJobUpdateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerPulseJobUpdateArgs(%+v)", *p)
}

// Attributes:
//  - Success
type AuroraSchedulerManagerPulseJobUpdateResult struct {
	Success *Response `thrift:"success,0" json:"success,omitempty"`
}

func NewAuroraSchedulerManagerPulseJobUpdateResult() *AuroraSchedulerManagerPulseJobUpdateResult {
	return &AuroraSchedulerManagerPulseJobUpdateResult{}
}

var AuroraSchedulerManagerPulseJobUpdateResult_Success_DEFAULT *Response

func (p *AuroraSchedulerManagerPulseJobUpdateResult) GetSuccess() *Response {
	if !p.IsSetSuccess() {
		return AuroraSchedulerManagerPulseJobUpdateResult_Success_DEFAULT
	}
	return p.Success
}
func (p *AuroraSchedulerManagerPulseJobUpdateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &Response{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("pulseJobUpdate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *AuroraSchedulerManagerPulseJobUpdateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuroraSchedulerManagerPulseJobUpdateResult(%+v)", *p)
}
